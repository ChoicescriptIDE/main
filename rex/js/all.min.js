/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l="1.11.3",m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:"jQuery"+(l+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===m.type(a)},isArray:Array.isArray||function(a){return"array"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,"ms-").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(n,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function r(a){var b="length"in a&&a.length,c=m.type(a);return"function"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);m.find=s,m.expr=s.selectors,m.expr[":"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,v=/^.[^:#\[\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,"string"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?"undefined"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||"string"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?"string"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,"parentNode")},parentsUntil:function(a,b,c){return m.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return m.dir(a,"nextSibling")},prevAll:function(a){return m.dir(a,"previousSibling")},nextUntil:function(a,b,c){return m.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return m.dir(a,"previousSibling",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[["resolve","done",m.Callbacks("once memory"),"resolved"],["reject","fail",m.Callbacks("once memory"),"rejected"],["notify","progress",m.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler("ready"),m(y).off("ready")))}}});function I(){y.addEventListener?(y.removeEventListener("DOMContentLoaded",J,!1),a.removeEventListener("load",J,!1)):(y.detachEvent("onreadystatechange",J),a.detachEvent("onload",J))}function J(){(y.addEventListener||"load"===event.type||"complete"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),"complete"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener("DOMContentLoaded",J,!1),a.addEventListener("load",J,!1);else{y.attachEvent("onreadystatechange",J),a.attachEvent("onload",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K="undefined",L;for(L in m(k))break;k.ownLast="0"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement("div");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var M=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(N,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if(("data"!==b||!m.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;

return!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks("once memory").add(function(){m._removeData(a,b+"queue"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=m._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=["Top","Right","Bottom","Left"],U=function(a,b){return a=b||a,"none"===m.css(a,"display")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement("input"),b=y.createElement("div"),c=y.createDocumentFragment();if(b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName("tbody").length,k.htmlSerialize=!!b.getElementsByTagName("link").length,k.html5Clone="<:nav></:nav>"!==y.createElement("nav").cloneNode(!0).outerHTML,a.type="checkbox",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(k[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),k[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\.(.+)|)$/;function aa(){return!0}function ba(){return!1}function ca(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(E)||[""],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(".")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[m.expando]?b:new m.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,"events")||{})[b.type]&&m._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,"events")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ca()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ca()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return m.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?aa:ba):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=aa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=aa,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=aa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,"form")?!1:void m.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=m.nodeName(b,"input")||m.nodeName(b,"button")?b.form:void 0;c&&!m._data(c,"submitBubbles")&&(m.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),m._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,"form")?!1:void m.event.remove(this,"._submit")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(m.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate("change",this,a,!0)})),!1):void m.event.add(this,"beforeactivate._change",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,"changeBubbles")&&(m.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate("change",this.parentNode,a,!0)}),m._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,"._change"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=ba;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=ba),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function da(a){var b=ea.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var ea="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",fa=/ jQuery\d+="(?:null|\d+)"/g,ga=new RegExp("<(?:"+ea+")[\\s/>]","i"),ha=/^\s+/,ia=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ja=/<([\w:]+)/,ka=/<tbody/i,la=/<|&#?\w+;/,ma=/<(?:script|style|link)/i,na=/checked\s*(?:[^=]|=\s*.checked.)/i,oa=/^$|\/(?:java|ecma)script/i,pa=/^true\/(.*)/,qa=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ra={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:k.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},sa=da(y),ta=sa.appendChild(y.createElement("div"));ra.optgroup=ra.option,ra.tbody=ra.tfoot=ra.colgroup=ra.caption=ra.thead,ra.th=ra.td;function ua(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ua(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function va(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wa(a,b){return m.nodeName(a,"table")&&m.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function xa(a){return a.type=(null!==m.find.attr(a,"type"))+"/"+a.type,a}function ya(a){var b=pa.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function za(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,"globalEval",!b||m._data(b[d],"globalEval"))}function Aa(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Ba(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}"script"===c&&b.text!==a.text?(xa(b).text=a.text,ya(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!ga.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ta.innerHTML=a.outerHTML,ta.removeChild(f=ta.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ua(f),h=ua(a),g=0;null!=(e=h[g]);++g)d[g]&&Ba(e,d[g]);if(b)if(c)for(h=h||ua(a),d=d||ua(f),g=0;null!=(e=h[g]);g++)Aa(e,d[g]);else Aa(a,f);return d=ua(f,"script"),d.length>0&&za(d,!i&&ua(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=da(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if("object"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(la.test(f)){h=h||o.appendChild(b.createElement("div")),i=(ja.exec(f)||["",""])[1].toLowerCase(),l=ra[i]||ra._default,h.innerHTML=l[1]+f.replace(ia,"<$1></$2>")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&ha.test(f)&&p.push(b.createTextNode(ha.exec(f)[0])),!k.tbody){f="table"!==i||ka.test(f)?"<table>"!==l[1]||ka.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ua(p,"input"),va),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ua(o.appendChild(f),"script"),g&&za(h),c)){e=0;while(f=h[e++])oa.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wa(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ua(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&za(ua(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ua(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fa,""):void 0;if(!("string"!=typeof a||ma.test(a)||!k.htmlSerialize&&ga.test(a)||!k.leadingWhitespace&&ha.test(a)||ra[(ja.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(ia,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ua(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ua(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&na.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ua(i,"script"),xa),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ua(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,ya),j=0;f>j;j++)d=g[j],oa.test(d.type||"")&&!m._data(d,"globalEval")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||"").replace(qa,"")));i=c=null}return this}}),m.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Ca,Da={};function Ea(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],"display");return e.detach(),f}function Fa(a){var b=y,c=Da[a];return c||(c=Ea(a,b),"none"!==c&&c||(Ca=(Ca||m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ca[0].contentWindow||Ca[0].contentDocument).document,b.write(),b.close(),c=Ea(a,b),Ca.detach()),Da[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName("body")[0],c&&c.style?(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(y.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Ga=/^margin/,Ha=new RegExp("^("+S+")(?!px)[a-z%]+$","i"),Ia,Ja,Ka=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ia=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Ha.test(g)&&Ga.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):y.documentElement.currentStyle&&(Ia=function(a){return a.currentStyle},Ja=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ia(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ha.test(g)&&!Ka.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function La(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement("div"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=d&&d.style){c.cssText="float:left;opacity:.5",k.opacity="0.5"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip="content-box",b.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===b.style.backgroundClip,k.boxSizing=""===c.boxSizing||""===c.MozBoxSizing||""===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName("body")[0],c&&c.style&&(b=y.createElement("div"),d=y.createElement("div"),d.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(d).appendChild(b),b.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",e=f=!1,h=!0,a.getComputedStyle&&(e="1%"!==(a.getComputedStyle(b,null)||{}).top,f="4px"===(a.getComputedStyle(b,null)||{width:"4px"}).width,i=b.appendChild(y.createElement("div")),i.style.cssText=b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",i.style.marginRight=i.style.width="0",b.style.width="1px",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML="<table><tr><td></td><td>t</td></tr></table>",i=b.getElementsByTagName("td"),i[0].style.cssText="margin:0;border:0;padding:0;display:none",g=0===i[0].offsetHeight,g&&(i[0].style.display="",i[1].style.display="none",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Ma=/alpha\([^)]*\)/i,Na=/opacity\s*=\s*([^)]*)/,Oa=/^(none|table(?!-c[ea]).+)/,Pa=new RegExp("^("+S+")(.*)$","i"),Qa=new RegExp("^([+-])=("+S+")","i"),Ra={position:"absolute",visibility:"hidden",display:"block"},Sa={letterSpacing:"0",fontWeight:"400"},Ta=["Webkit","O","Moz","ms"];function Ua(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ta.length;while(e--)if(b=Ta[e]+c,b in a)return b;return d}function Va(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&U(d)&&(f[g]=m._data(d,"olddisplay",Fa(d.nodeName)))):(e=U(d),(c&&"none"!==c||!e)&&m._data(d,"olddisplay",e?c:m.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Wa(a,b,c){var d=Pa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Xa(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=m.css(a,c+T[f],!0,e)),d?("content"===c&&(g-=m.css(a,"padding"+T[f],!0,e)),"margin"!==c&&(g-=m.css(a,"border"+T[f]+"Width",!0,e))):(g+=m.css(a,"padding"+T[f],!0,e),"padding"!==c&&(g+=m.css(a,"border"+T[f]+"Width",!0,e)));return g}function Ya(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Ia(a),g=k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Ja(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ha.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xa(a,b,c||(g?"border":"content"),d,f)+"px"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Ja(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":k.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ua(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Qa.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||m.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ua(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Ja(a,b,d)),"normal"===f&&b in Sa&&(f=Sa[b]),""===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each(["height","width"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Oa.test(m.css(a,"display"))&&0===a.offsetWidth?m.swap(a,Ra,function(){return Ya(a,b,d)}):Ya(a,b,d):void 0},set:function(a,c,d){var e=d&&Ia(a);return Wa(a,c,d?Xa(a,b,d,k.boxSizing&&"border-box"===m.css(a,"boxSizing",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Na.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===m.trim(f.replace(Ma,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Ma.test(f)?f.replace(Ma,e):f+" "+e)}}),m.cssHooks.marginRight=La(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:"inline-block"},Ja,[a,"marginRight"]):void 0}),m.each({margin:"",padding:"",border:"Width"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Ga.test(a)||(m.cssHooks[a+b].set=Wa)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ia(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Va(this,!0)},hide:function(){return Va(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Za(a,b,c,d,e){
return new Za.prototype.init(a,b,c,d,e)}m.Tween=Za,Za.prototype={constructor:Za,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?"":"px")},cur:function(){var a=Za.propHooks[this.prop];return a&&a.get?a.get(this):Za.propHooks._default.get(this)},run:function(a){var b,c=Za.propHooks[this.prop];return this.options.duration?this.pos=b=m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Za.propHooks._default.set(this),this}},Za.prototype.init.prototype=Za.prototype,Za.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Za.propHooks.scrollTop=Za.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Za.prototype.init,m.fx.step={};var $a,_a,ab=/^(?:toggle|show|hide)$/,bb=new RegExp("^(?:([+-])=|)("+S+")([a-z%]*)$","i"),cb=/queueHooks$/,db=[ib],eb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bb.exec(b),f=e&&e[3]||(m.cssNumber[a]?"":"px"),g=(m.cssNumber[a]||"px"!==f&&+d)&&bb.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fb(){return setTimeout(function(){$a=void 0}),$a=m.now()}function gb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function hb(a,b,c){for(var d,e=(eb[b]||[]).concat(eb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,"fxshow");c.queue||(h=m._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,"display"),l="none"===j?m._data(a,"olddisplay")||Fa(a.nodeName):j,"inline"===l&&"none"===m.css(a,"float")&&(k.inlineBlockNeedsLayout&&"inline"!==Fa(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ab.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))"inline"===("none"===j?Fa(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=m._data(a,"fxshow",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,"fxshow");for(b in o)m.style(a,b,o[b])});for(d in o)g=hb(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=db.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$a||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$a||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);g>f;f++)if(d=db[f].call(j,a,k,j.opts))return d;return m.map(k,hb,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kb,{tweener:function(a,b){m.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],eb[c]=eb[c]||[],eb[c].unshift(b)},prefilter:function(a,b){b?db.unshift(a):db.push(a)}}),m.speed=function(a,b,c){var d=a&&"object"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kb(this,m.extend({},a),f);(e||m._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=m._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each(["toggle","show","hide"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),m.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($a=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$a=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_a||(_a=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_a),_a=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement("div"),b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",d=b.getElementsByTagName("a")[0],c=y.createElement("select"),e=c.appendChild(y.createElement("option")),a=b.getElementsByTagName("input")[0],d.style.cssText="top:1px",k.getSetAttribute="t"!==b.className,k.style=/top/.test(d.getAttribute("style")),k.hrefNormalized="/a"===d.getAttribute("href"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement("form").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement("input"),a.setAttribute("value",""),k.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),k.radioValue="t"===a.value}();var lb=/\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e="":"number"==typeof e?e+="":m.isArray(e)&&(e=m.map(e,function(a){return null==a?"":a+""})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(lb,""):null==c?"":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,"value");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&m.nodeName(c.parentNode,"optgroup"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each(["radio","checkbox"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var mb,nb,ob=m.expr.attrHandle,pb=/^(?:checked|selected)$/i,qb=k.getSetAttribute,rb=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nb:mb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rb&&qb||!pb.test(c)?a[d]=!1:a[m.camelCase("default-"+c)]=a[d]=!1:m.attr(a,c,""),a.removeAttribute(qb?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&m.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),nb={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rb&&qb||!pb.test(c)?a.setAttribute(!qb&&m.propFix[c]||c,c):a[m.camelCase("default-"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ob[b]||m.find.attr;ob[b]=rb&&qb||!pb.test(b)?function(a,b,d){var e,f;return d||(f=ob[b],ob[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ob[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase("default-"+b)]?b.toLowerCase():null}}),rb&&qb||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,"input")?void(a.defaultValue=b):mb&&mb.set(a,b,c)}}),qb||(mb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ob.id=ob.name=ob.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mb.set},m.attrHooks.contenteditable={set:function(a,b,c){mb.set(a,""===b?!1:b,c)}},m.each(["width","height"],function(a,b){m.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var sb=/^(?:input|select|textarea|button|object)$/i,tb=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,"tabindex");return b?parseInt(b,10):sb.test(a.nodeName)||tb.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each(["href","src"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype="encoding");var ub=/[\t\r\n\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ub," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?m.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||"boolean"===c)&&(this.className&&m._data(this,"__className__",this.className),this.className=this.className||a===!1?"":m._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ub," ").indexOf(b)>=0)return!0;return!1}}),m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var vb=m.now(),wb=/\?/,xb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=m.trim(b+"");return e&&!m.trim(e.replace(xb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():m.error("Invalid JSON: "+b)},m.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||m.error("Invalid XML: "+b),c};var yb,zb,Ab=/#.*$/,Bb=/([?&])_=[^&]*/,Cb=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Db=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Eb=/^(?:GET|HEAD)$/,Fb=/^\/\//,Gb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Hb={},Ib={},Jb="*/".concat("*");try{zb=location.href}catch(Kb){zb=y.createElement("a"),zb.href="",zb=zb.href}yb=Gb.exec(zb.toLowerCase())||[];function Lb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mb(a,b,c,d){var e={},f=a===Ib;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Nb(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Ob(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zb,type:"GET",isLocal:Db.test(yb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Jb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":m.parseJSON,"text xml":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nb(Nb(a,m.ajaxSettings),b):Nb(m.ajaxSettings,a)},ajaxPrefilter:Lb(Hb),ajaxTransport:Lb(Ib),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cb.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zb)+"").replace(Ab,"").replace(Fb,yb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(c=Gb.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yb[1]&&c[2]===yb[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(yb[3]||("http:"===yb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mb(Hb,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Eb.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wb.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Bb.test(e)?e.replace(Bb,"$1_="+vb++):e+(wb.test(e)?"&":"?")+"_="+vb++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader("If-Modified-Since",m.lastModified[e]),m.etag[e]&&v.setRequestHeader("If-None-Match",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Jb+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mb(Ib,k,b,v)){v.readyState=1,h&&n.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Ob(k,v,c)),u=Pb(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(m.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(m.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger("ajaxComplete",[v,k]),--m.active||m.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,"json")},getScript:function(a,b){return m.get(a,void 0,b,"script")}}),m.each(["get","post"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,"body")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||m.css(a,"display"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qb=/%20/g,Rb=/\[\]$/,Sb=/\r?\n/g,Tb=/^(?:submit|button|image|reset|file)$/i,Ub=/^(?:input|select|textarea|keygen)/i;function Vb(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rb.test(a)?d(a,e):Vb(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==m.type(b))d(a,b);else for(e in b)Vb(a+"["+e+"]",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vb(c,a[c],b,e);return d.join("&").replace(Qb,"+")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,"elements");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(":disabled")&&Ub.test(this.nodeName)&&!Tb.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sb,"\r\n")}}):{name:b.name,value:c.replace(Sb,"\r\n")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zb()||$b()}:Zb;var Wb=0,Xb={},Yb=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Xb)Xb[a](void 0,!0)}),k.cors=!!Yb&&"withCredentials"in Yb,Yb=k.ajax=!!Yb,Yb&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xb[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xb[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zb(){try{return new a.XMLHttpRequest}catch(b){}}function $b(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}m.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),m.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=y.head||m("head")[0]||y.documentElement;return{send:function(d,e){b=y.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _b=[],ac=/(=)\?(?=&|$)|\?\?/;m.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=_b.pop()||m.expando+"_"+vb++;return this[a]=!0,a}}),m.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ac.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&ac.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ac,"$1"+e):b.jsonp!==!1&&(b.url+=(wb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||m.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_b.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),m.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bc=m.fn.load;m.fn.load=function(a,b,c){if("string"!=typeof a&&bc)return bc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&m.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?m("<div>").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cc=a.document.documentElement;function dc(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,"position"),l=m(a),n={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=m.css(a,"top"),i=m.css(a,"left"),j=("absolute"===k||"fixed"===k)&&m.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),"using"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===m.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],"html")||(c=a.offset()),c.top+=m.css(a[0],"borderTopWidth",!0),c.left+=m.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-m.css(d,"marginTop",!0),left:b.left-c.left-m.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cc;while(a&&!m.nodeName(a,"html")&&"static"===m.css(a,"position"))a=a.offsetParent;return a||cc})}}),m.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each(["top","left"],function(a,b){m.cssHooks[b]=La(k.pixelPosition,function(a,c){return c?(c=Ja(a,b),Ha.test(c)?m(a).position()[b]+"px":c):void 0})}),m.each({Height:"height",Width:"width"},function(a,b){m.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return m});var ec=a.jQuery,fc=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fc),b&&a.jQuery===m&&(a.jQuery=ec),m},typeof b===K&&(a.jQuery=a.$=m),m});


;/*! jQuery UI - v1.11.4 - 2015-09-13
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js, tabs.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function(e){"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)})(function(e){function t(t,s){var n,a,o,r=t.nodeName.toLowerCase();return"area"===r?(n=t.parentNode,a=n.name,t.href&&a&&"map"===n.nodeName.toLowerCase()?(o=e("img[usemap='#"+a+"']")[0],!!o&&i(o)):!1):(/^(input|select|textarea|button|object)$/.test(r)?!t.disabled:"a"===r?t.href||s:s)&&i(t)}function i(t){return e.expr.filters.visible(t)&&!e(t).parents().addBack().filter(function(){return"hidden"===e.css(this,"visibility")}).length}e.ui=e.ui||{},e.extend(e.ui,{version:"1.11.4",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({scrollParent:function(t){var i=this.css("position"),s="absolute"===i,n=t?/(auto|scroll|hidden)/:/(auto|scroll)/,a=this.parents().filter(function(){var t=e(this);return s&&"static"===t.css("position")?!1:n.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==i&&a.length?a:e(this[0].ownerDocument||document)},uniqueId:function(){var e=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++e)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&e(this).removeAttr("id")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(i){return!!e.data(i,t)}}):function(t,i,s){return!!e.data(t,s[3])},focusable:function(i){return t(i,!isNaN(e.attr(i,"tabindex")))},tabbable:function(i){var s=e.attr(i,"tabindex"),n=isNaN(s);return(n||s>=0)&&t(i,!n)}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(t,i){function s(t,i,s,a){return e.each(n,function(){i-=parseFloat(e.css(t,"padding"+this))||0,s&&(i-=parseFloat(e.css(t,"border"+this+"Width"))||0),a&&(i-=parseFloat(e.css(t,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],a=i.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+i]=function(t){return void 0===t?o["inner"+i].call(this):this.each(function(){e(this).css(a,s(this,t)+"px")})},e.fn["outer"+i]=function(t,n){return"number"!=typeof t?o["outer"+i].call(this,t):this.each(function(){e(this).css(a,s(this,t,!0,n)+"px")})}}),e.fn.addBack||(e.fn.addBack=function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}),e("<a>").data("a-b","a").removeData("a-b").data("a-b")&&(e.fn.removeData=function(t){return function(i){return arguments.length?t.call(this,e.camelCase(i)):t.call(this)}}(e.fn.removeData)),e.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()),e.fn.extend({focus:function(t){return function(i,s){return"number"==typeof i?this.each(function(){var t=this;setTimeout(function(){e(t).focus(),s&&s.call(t)},i)}):t.apply(this,arguments)}}(e.fn.focus),disableSelection:function(){var e="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.bind(e+".ui-disableSelection",function(e){e.preventDefault()})}}(),enableSelection:function(){return this.unbind(".ui-disableSelection")},zIndex:function(t){if(void 0!==t)return this.css("zIndex",t);if(this.length)for(var i,s,n=e(this[0]);n.length&&n[0]!==document;){if(i=n.css("position"),("absolute"===i||"relative"===i||"fixed"===i)&&(s=parseInt(n.css("zIndex"),10),!isNaN(s)&&0!==s))return s;n=n.parent()}return 0}}),e.ui.plugin={add:function(t,i,s){var n,a=e.ui[t].prototype;for(n in s)a.plugins[n]=a.plugins[n]||[],a.plugins[n].push([i,s[n]])},call:function(e,t,i,s){var n,a=e.plugins[t];if(a&&(s||e.element[0].parentNode&&11!==e.element[0].parentNode.nodeType))for(n=0;a.length>n;n++)e.options[a[n][0]]&&a[n][1].apply(e.element,i)}};var s=0,n=Array.prototype.slice;e.cleanData=function(t){return function(i){var s,n,a;for(a=0;null!=(n=i[a]);a++)try{s=e._data(n,"events"),s&&s.remove&&e(n).triggerHandler("remove")}catch(o){}t(i)}}(e.cleanData),e.widget=function(t,i,s){var n,a,o,r,h={},l=t.split(".")[0];return t=t.split(".")[1],n=l+"-"+t,s||(s=i,i=e.Widget),e.expr[":"][n.toLowerCase()]=function(t){return!!e.data(t,n)},e[l]=e[l]||{},a=e[l][t],o=e[l][t]=function(e,t){return this._createWidget?(arguments.length&&this._createWidget(e,t),void 0):new o(e,t)},e.extend(o,a,{version:s.version,_proto:e.extend({},s),_childConstructors:[]}),r=new i,r.options=e.widget.extend({},r.options),e.each(s,function(t,s){return e.isFunction(s)?(h[t]=function(){var e=function(){return i.prototype[t].apply(this,arguments)},n=function(e){return i.prototype[t].apply(this,e)};return function(){var t,i=this._super,a=this._superApply;return this._super=e,this._superApply=n,t=s.apply(this,arguments),this._super=i,this._superApply=a,t}}(),void 0):(h[t]=s,void 0)}),o.prototype=e.widget.extend(r,{widgetEventPrefix:a?r.widgetEventPrefix||t:t},h,{constructor:o,namespace:l,widgetName:t,widgetFullName:n}),a?(e.each(a._childConstructors,function(t,i){var s=i.prototype;e.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete a._childConstructors):i._childConstructors.push(o),e.widget.bridge(t,o),o},e.widget.extend=function(t){for(var i,s,a=n.call(arguments,1),o=0,r=a.length;r>o;o++)for(i in a[o])s=a[o][i],a[o].hasOwnProperty(i)&&void 0!==s&&(t[i]=e.isPlainObject(s)?e.isPlainObject(t[i])?e.widget.extend({},t[i],s):e.widget.extend({},s):s);return t},e.widget.bridge=function(t,i){var s=i.prototype.widgetFullName||t;e.fn[t]=function(a){var o="string"==typeof a,r=n.call(arguments,1),h=this;return o?this.each(function(){var i,n=e.data(this,s);return"instance"===a?(h=n,!1):n?e.isFunction(n[a])&&"_"!==a.charAt(0)?(i=n[a].apply(n,r),i!==n&&void 0!==i?(h=i&&i.jquery?h.pushStack(i.get()):i,!1):void 0):e.error("no such method '"+a+"' for "+t+" widget instance"):e.error("cannot call methods on "+t+" prior to initialization; "+"attempted to call method '"+a+"'")}):(r.length&&(a=e.widget.extend.apply(null,[a].concat(r))),this.each(function(){var t=e.data(this,s);t?(t.option(a||{}),t._init&&t._init()):e.data(this,s,new i(a,this))})),h}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,i){i=e(i||this.defaultElement||this)[0],this.element=e(i),this.uuid=s++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=e(),this.hoverable=e(),this.focusable=e(),i!==this&&(e.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(e){e.target===i&&this.destroy()}}),this.document=e(i.style?i.ownerDocument:i.document||i),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(t,i){var s,n,a,o=t;if(0===arguments.length)return e.widget.extend({},this.options);if("string"==typeof t)if(o={},s=t.split("."),t=s.shift(),s.length){for(n=o[t]=e.widget.extend({},this.options[t]),a=0;s.length-1>a;a++)n[s[a]]=n[s[a]]||{},n=n[s[a]];if(t=s.pop(),1===arguments.length)return void 0===n[t]?null:n[t];n[t]=i}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=i}return this._setOptions(o),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,"disabled"===e&&(this.widget().toggleClass(this.widgetFullName+"-disabled",!!t),t&&(this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus"))),this},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_on:function(t,i,s){var n,a=this;"boolean"!=typeof t&&(s=i,i=t,t=!1),s?(i=n=e(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),e.each(s,function(s,o){function r(){return t||a.options.disabled!==!0&&!e(this).hasClass("ui-state-disabled")?("string"==typeof o?a[o]:o).apply(a,arguments):void 0}"string"!=typeof o&&(r.guid=o.guid=o.guid||r.guid||e.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+a.eventNamespace,u=h[2];u?n.delegate(u,l,r):i.bind(l,r)})},_off:function(t,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.unbind(i).undelegate(i),this.bindings=e(this.bindings.not(t).get()),this.focusable=e(this.focusable.not(t).get()),this.hoverable=e(this.hoverable.not(t).get())},_delay:function(e,t){function i(){return("string"==typeof e?s[e]:e).apply(s,arguments)}var s=this;return setTimeout(i,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,i,s){var n,a,o=this.options[t];if(s=s||{},i=e.Event(i),i.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),i.target=this.element[0],a=i.originalEvent)for(n in a)n in i||(i[n]=a[n]);return this.element.trigger(i,s),!(e.isFunction(o)&&o.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,i){e.Widget.prototype["_"+t]=function(s,n,a){"string"==typeof n&&(n={effect:n});var o,r=n?n===!0||"number"==typeof n?i:n.effect||i:t;n=n||{},"number"==typeof n&&(n={duration:n}),o=!e.isEmptyObject(n),n.complete=a,n.delay&&s.delay(n.delay),o&&e.effects&&e.effects.effect[r]?s[t](n):r!==t&&s[r]?s[r](n.duration,n.easing,a):s.queue(function(i){e(this)[t](),a&&a.call(s[0]),i()})}}),e.widget;var a=!1;e(document).mouseup(function(){a=!1}),e.widget("ui.mouse",{version:"1.11.4",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(i){return!0===e.data(i.target,t.widgetName+".preventClickEvent")?(e.removeData(i.target,t.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!a){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var i=this,s=1===t.which,n="string"==typeof this.options.cancel&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(t)!==!1,!this._mouseStarted)?(t.preventDefault(),!0):(!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return i._mouseMove(e)},this._mouseUpDelegate=function(e){return i._mouseUp(e)},this.document.bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),a=!0,!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(e.ui.ie&&(!document.documentMode||9>document.documentMode)&&!t.button)return this._mouseUp(t);if(!t.which)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){return this.document.unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),a=!1,!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),e.widget("ui.draggable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._setHandleClassName(),this._mouseInit()},_setOption:function(e,t){this._super(e,t),"handle"===e&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(t){var i=this.options;return this._blurActiveElement(t),this.helper||i.disabled||e(t.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(t),this.handle?(this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=e(this);return e("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var i=this.document[0];if(this.handleElement.is(t.target))try{i.activeElement&&"body"!==i.activeElement.nodeName.toLowerCase()&&e(i.activeElement).blur()}catch(s){}},_mouseStart:function(t){var i=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===e(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._normalizeRightBottom(),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(e){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:e.pageX-this.offset.left,top:e.pageY-this.offset.top}},_mouseDrag:function(t,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",t,s)===!1)return this._mouseUp({}),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var i=this,s=!1;return e.ui.ddmanager&&!this.options.dropBehaviour&&(s=e.ui.ddmanager.drop(this,t)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",t)!==!1&&i._clear()}):this._trigger("stop",t)!==!1&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.focus(),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){return this.options.handle?!!e(t.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this.handleElement.addClass("ui-draggable-handle")},_removeHandleClassName:function(){this.handleElement.removeClass("ui-draggable-handle")},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper),n=s?e(i.helper.apply(this.element[0],[t])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(e){return/(html|body)/i.test(e.tagName)||e===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var e=this.element.position(),t=this._isRootNode(this.scrollParent[0]);return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+(t?0:this.scrollParent.scrollTop()),left:e.left-(parseInt(this.helper.css("left"),10)||0)+(t?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options,a=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,e(window).scrollLeft()+e(window).width()-this.helperProportions.width-this.margins.left,e(window).scrollTop()+(e(window).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,e(a).width()-this.helperProportions.width-this.margins.left,(e(a).height()||a.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=e(n.containment),s=i[0],s&&(t=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(t?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(e,t){t||(t=this.position);var i="absolute"===e?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:t.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:t.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(e,t){var i,s,n,a,o=this.options,r=this._isRootNode(this.scrollParent[0]),h=e.pageX,l=e.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),t&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,e.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),e.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),e.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),e.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),o.grid&&(n=o.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/o.grid[1])*o.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-o.grid[1]:n+o.grid[1]:n,a=o.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/o.grid[0])*o.grid[0]:this.originalPageX,h=i?a-this.offset.click.left>=i[0]||a-this.offset.click.left>i[2]?a:a-this.offset.click.left>=i[0]?a-o.grid[0]:a+o.grid[0]:a),"y"===o.axis&&(h=this.originalPageX),"x"===o.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_normalizeRightBottom:function(){"y"!==this.options.axis&&"auto"!==this.helper.css("right")&&(this.helper.width(this.helper.width()),this.helper.css("right","auto")),"x"!==this.options.axis&&"auto"!==this.helper.css("bottom")&&(this.helper.height(this.helper.height()),this.helper.css("bottom","auto"))},_trigger:function(t,i,s){return s=s||this._uiHash(),e.ui.plugin.call(this,t,[i,s,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),e.Widget.prototype._trigger.call(this,t,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,i,s){var n=e.extend({},i,{item:s.element});s.sortables=[],e(s.options.connectToSortable).each(function(){var i=e(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",t,n))})},stop:function(t,i,s){var n=e.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,e.each(s.sortables,function(){var e=this;e.isOver?(e.isOver=0,s.cancelHelperRemoval=!0,e.cancelHelperRemoval=!1,e._storedCSS={position:e.placeholder.css("position"),top:e.placeholder.css("top"),left:e.placeholder.css("left")},e._mouseStop(t),e.options.helper=e.options._helper):(e.cancelHelperRemoval=!0,e._trigger("deactivate",t,n))})},drag:function(t,i,s){e.each(s.sortables,function(){var n=!1,a=this;a.positionAbs=s.positionAbs,a.helperProportions=s.helperProportions,a.offset.click=s.offset.click,a._intersectsWith(a.containerCache)&&(n=!0,e.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==a&&this._intersectsWith(this.containerCache)&&e.contains(a.element[0],this.element[0])&&(n=!1),n})),n?(a.isOver||(a.isOver=1,s._parent=i.helper.parent(),a.currentItem=i.helper.appendTo(a.element).data("ui-sortable-item",!0),a.options._helper=a.options.helper,a.options.helper=function(){return i.helper[0]},t.target=a.currentItem[0],a._mouseCapture(t,!0),a._mouseStart(t,!0,!0),a.offset.click.top=s.offset.click.top,a.offset.click.left=s.offset.click.left,a.offset.parent.left-=s.offset.parent.left-a.offset.parent.left,a.offset.parent.top-=s.offset.parent.top-a.offset.parent.top,s._trigger("toSortable",t),s.dropped=a.element,e.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,a.fromOutside=s),a.currentItem&&(a._mouseDrag(t),i.position=a.position)):a.isOver&&(a.isOver=0,a.cancelHelperRemoval=!0,a.options._revert=a.options.revert,a.options.revert=!1,a._trigger("out",t,a._uiHash(a)),a._mouseStop(t,!0),a.options.revert=a.options._revert,a.options.helper=a.options._helper,a.placeholder&&a.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(t),i.position=s._generatePosition(t,!0),s._trigger("fromSortable",t),s.dropped=!1,e.each(s.sortables,function(){this.refreshPositions()}))})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,i,s){var n=e("body"),a=s.options;n.css("cursor")&&(a._cursor=n.css("cursor")),n.css("cursor",a.cursor)},stop:function(t,i,s){var n=s.options;n._cursor&&e("body").css("cursor",n._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("opacity")&&(a._opacity=n.css("opacity")),n.css("opacity",a.opacity)},stop:function(t,i,s){var n=s.options;n._opacity&&e(i.helper).css("opacity",n._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(e,t,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,i,s){var n=s.options,a=!1,o=s.scrollParentNotHidden[0],r=s.document[0];o!==r&&"HTML"!==o.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+o.offsetHeight-t.pageY<n.scrollSensitivity?o.scrollTop=a=o.scrollTop+n.scrollSpeed:t.pageY-s.overflowOffset.top<n.scrollSensitivity&&(o.scrollTop=a=o.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+o.offsetWidth-t.pageX<n.scrollSensitivity?o.scrollLeft=a=o.scrollLeft+n.scrollSpeed:t.pageX-s.overflowOffset.left<n.scrollSensitivity&&(o.scrollLeft=a=o.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(t.pageY-e(r).scrollTop()<n.scrollSensitivity?a=e(r).scrollTop(e(r).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(r).scrollTop())<n.scrollSensitivity&&(a=e(r).scrollTop(e(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(t.pageX-e(r).scrollLeft()<n.scrollSensitivity?a=e(r).scrollLeft(e(r).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(r).scrollLeft())<n.scrollSensitivity&&(a=e(r).scrollLeft(e(r).scrollLeft()+n.scrollSpeed)))),a!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(s,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,i,s){var n=s.options;s.snapElements=[],e(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var t=e(this),i=t.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:i.top,left:i.left})})},drag:function(t,i,s){var n,a,o,r,h,l,u,d,c,p,f=s.options,m=f.snapTolerance,g=i.offset.left,v=g+s.helperProportions.width,y=i.offset.top,b=y+s.helperProportions.height;for(c=s.snapElements.length-1;c>=0;c--)h=s.snapElements[c].left-s.margins.left,l=h+s.snapElements[c].width,u=s.snapElements[c].top-s.margins.top,d=u+s.snapElements[c].height,h-m>v||g>l+m||u-m>b||y>d+m||!e.contains(s.snapElements[c].item.ownerDocument,s.snapElements[c].item)?(s.snapElements[c].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=!1):("inner"!==f.snapMode&&(n=m>=Math.abs(u-b),a=m>=Math.abs(d-y),o=m>=Math.abs(h-v),r=m>=Math.abs(l-g),n&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||a||o||r,"outer"!==f.snapMode&&(n=m>=Math.abs(u-y),a=m>=Math.abs(d-b),o=m>=Math.abs(h-g),r=m>=Math.abs(l-v),n&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.top=s._convertPositionTo("relative",{top:d-s.helperProportions.height,left:0}).top),o&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[c].snapping&&(n||a||o||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,t,e.extend(s._uiHash(),{snapItem:s.snapElements[c].item})),s.snapElements[c].snapping=n||a||o||r||p)}}),e.ui.plugin.add("draggable","stack",{start:function(t,i,s){var n,a=s.options,o=e.makeArray(e(a.stack)).sort(function(t,i){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(i).css("zIndex"),10)||0)});o.length&&(n=parseInt(e(o[0]).css("zIndex"),10)||0,e(o).each(function(t){e(this).css("zIndex",n+t)}),this.css("zIndex",n+o.length))}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,i,s){var n=e(i.helper),a=s.options;n.css("zIndex")&&(a._zIndex=n.css("zIndex")),n.css("zIndex",a.zIndex)},stop:function(t,i,s){var n=s.options;n._zIndex&&e(i.helper).css("zIndex",n._zIndex)}}),e.ui.draggable,e.widget("ui.droppable",{version:"1.11.4",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var t,i=this.options,s=i.accept;
this.isover=!1,this.isout=!0,this.accept=e.isFunction(s)?s:function(e){return e.is(s)},this.proportions=function(){return arguments.length?(t=arguments[0],void 0):t?t:t={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this.element.addClass("ui-droppable")},_addToManager:function(t){e.ui.ddmanager.droppables[t]=e.ui.ddmanager.droppables[t]||[],e.ui.ddmanager.droppables[t].push(this)},_splice:function(e){for(var t=0;e.length>t;t++)e[t]===this&&e.splice(t,1)},_destroy:function(){var t=e.ui.ddmanager.droppables[this.options.scope];this._splice(t),this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(t,i){if("accept"===t)this.accept=e.isFunction(i)?i:function(e){return e.is(i)};else if("scope"===t){var s=e.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(t,i)},_activate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),i&&this._trigger("activate",t,this.ui(i))},_deactivate:function(t){var i=e.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),i&&this._trigger("deactivate",t,this.ui(i))},_over:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",t,this.ui(i)))},_out:function(t){var i=e.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",t,this.ui(i)))},_drop:function(t,i){var s=i||e.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=e(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&e.ui.intersect(s,e.extend(i,{offset:i.element.offset()}),i.options.tolerance,t)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",t,this.ui(s)),this.element):!1):!1},ui:function(e){return{draggable:e.currentItem||e.element,helper:e.helper,position:e.position,offset:e.positionAbs}}}),e.ui.intersect=function(){function e(e,t,i){return e>=t&&t+i>e}return function(t,i,s,n){if(!i.offset)return!1;var a=(t.positionAbs||t.position.absolute).left+t.margins.left,o=(t.positionAbs||t.position.absolute).top+t.margins.top,r=a+t.helperProportions.width,h=o+t.helperProportions.height,l=i.offset.left,u=i.offset.top,d=l+i.proportions().width,c=u+i.proportions().height;switch(s){case"fit":return a>=l&&d>=r&&o>=u&&c>=h;case"intersect":return a+t.helperProportions.width/2>l&&d>r-t.helperProportions.width/2&&o+t.helperProportions.height/2>u&&c>h-t.helperProportions.height/2;case"pointer":return e(n.pageY,u,i.proportions().height)&&e(n.pageX,l,i.proportions().width);case"touch":return(o>=u&&c>=o||h>=u&&c>=h||u>o&&h>c)&&(a>=l&&d>=a||r>=l&&d>=r||l>a&&r>d);default:return!1}}}(),e.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(t,i){var s,n,a=e.ui.ddmanager.droppables[t.options.scope]||[],o=i?i.type:null,r=(t.currentItem||t.element).find(":data(ui-droppable)").addBack();e:for(s=0;a.length>s;s++)if(!(a[s].options.disabled||t&&!a[s].accept.call(a[s].element[0],t.currentItem||t.element))){for(n=0;r.length>n;n++)if(r[n]===a[s].element[0]){a[s].proportions().height=0;continue e}a[s].visible="none"!==a[s].element.css("display"),a[s].visible&&("mousedown"===o&&a[s]._activate.call(a[s],i),a[s].offset=a[s].element.offset(),a[s].proportions({width:a[s].element[0].offsetWidth,height:a[s].element[0].offsetHeight}))}},drop:function(t,i){var s=!1;return e.each((e.ui.ddmanager.droppables[t.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&e.ui.intersect(t,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(t,i){t.element.parentsUntil("body").bind("scroll.droppable",function(){t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)})},drag:function(t,i){t.options.refreshPositions&&e.ui.ddmanager.prepareOffsets(t,i),e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,a,o=e.ui.intersect(t,this,this.options.tolerance,i),r=!o&&this.isover?"isout":o&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,a=this.element.parents(":data(ui-droppable)").filter(function(){return e(this).droppable("instance").options.scope===n}),a.length&&(s=e(a[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(t,i){t.element.parentsUntil("body").unbind("scroll.droppable"),t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,i)}},e.ui.droppable,e.widget("ui.resizable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(e){return parseInt(e,10)||0},_isNumber:function(e){return!isNaN(parseInt(e,10))},_hasScroll:function(t,i){if("hidden"===e(t).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return t[s]>0?!0:(t[s]=1,n=t[s]>0,t[s]=0,n)},_create:function(){var t,i,s,n,a,o=this,r=this.options;if(this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!r.aspectRatio,aspectRatio:r.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:r.helper||r.ghost||r.animate?r.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(e("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=r.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=e(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),t=this.handles.split(","),this.handles={},i=0;t.length>i;i++)s=e.trim(t[i]),a="ui-resizable-"+s,n=e("<div class='ui-resizable-handle "+a+"'></div>"),n.css({zIndex:r.zIndex}),"se"===s&&n.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(n);this._renderAxis=function(t){var i,s,n,a;t=t||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=e(this.handles[i]),this._on(this.handles[i],{mousedown:o._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=e(this.handles[i],this.element),a=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),t.css(n,a),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.mouseover(function(){o.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),o.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){r.disabled||(e(this).removeClass("ui-resizable-autohide"),o._handles.show())}).mouseleave(function(){r.disabled||o.resizing||(e(this).addClass("ui-resizable-autohide"),o._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t,i=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),t=this.element,this.originalElement.css({position:t.css("position"),width:t.outerWidth(),height:t.outerHeight(),top:t.css("top"),left:t.css("left")}).insertAfter(t),t.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_mouseCapture:function(t){var i,s,n=!1;for(i in this.handles)s=e(this.handles[i])[0],(s===t.target||e.contains(s,t.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(t){var i,s,n,a=this.options,o=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),a.containment&&(i+=e(a.containment).scrollLeft()||0,s+=e(a.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:o.width(),height:o.height()},this.originalSize=this._helper?{width:o.outerWidth(),height:o.outerHeight()}:{width:o.width(),height:o.height()},this.sizeDiff={width:o.outerWidth()-o.width(),height:o.outerHeight()-o.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio="number"==typeof a.aspectRatio?a.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=e(".ui-resizable-"+this.axis).css("cursor"),e("body").css("cursor","auto"===n?this.axis+"-resize":n),o.addClass("ui-resizable-resizing"),this._propagate("start",t),!0},_mouseDrag:function(t){var i,s,n=this.originalMousePosition,a=this.axis,o=t.pageX-n.left||0,r=t.pageY-n.top||0,h=this._change[a];return this._updatePrevProperties(),h?(i=h.apply(this,[t,o,r]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(i=this._updateRatio(i,t)),i=this._respectSize(i,t),this._updateCache(i),this._propagate("resize",t),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),e.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",t,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(t){this.resizing=!1;var i,s,n,a,o,r,h,l=this.options,u=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:u.sizeDiff.height,a=s?0:u.sizeDiff.width,o={width:u.helper.width()-a,height:u.helper.height()-n},r=parseInt(u.element.css("left"),10)+(u.position.left-u.originalPosition.left)||null,h=parseInt(u.element.css("top"),10)+(u.position.top-u.originalPosition.top)||null,l.animate||this.element.css(e.extend(o,{top:h,left:r})),u.helper.height(u.size.height),u.helper.width(u.size.width),this._helper&&!l.animate&&this._proportionallyResize()),e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var e={};return this.position.top!==this.prevPosition.top&&(e.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(e.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(e.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(e.height=this.size.height+"px"),this.helper.css(e),e},_updateVirtualBoundaries:function(e){var t,i,s,n,a,o=this.options;a={minWidth:this._isNumber(o.minWidth)?o.minWidth:0,maxWidth:this._isNumber(o.maxWidth)?o.maxWidth:1/0,minHeight:this._isNumber(o.minHeight)?o.minHeight:0,maxHeight:this._isNumber(o.maxHeight)?o.maxHeight:1/0},(this._aspectRatio||e)&&(t=a.minHeight*this.aspectRatio,s=a.minWidth/this.aspectRatio,i=a.maxHeight*this.aspectRatio,n=a.maxWidth/this.aspectRatio,t>a.minWidth&&(a.minWidth=t),s>a.minHeight&&(a.minHeight=s),a.maxWidth>i&&(a.maxWidth=i),a.maxHeight>n&&(a.maxHeight=n)),this._vBoundaries=a},_updateCache:function(e){this.offset=this.helper.offset(),this._isNumber(e.left)&&(this.position.left=e.left),this._isNumber(e.top)&&(this.position.top=e.top),this._isNumber(e.height)&&(this.size.height=e.height),this._isNumber(e.width)&&(this.size.width=e.width)},_updateRatio:function(e){var t=this.position,i=this.size,s=this.axis;return this._isNumber(e.height)?e.width=e.height*this.aspectRatio:this._isNumber(e.width)&&(e.height=e.width/this.aspectRatio),"sw"===s&&(e.left=t.left+(i.width-e.width),e.top=null),"nw"===s&&(e.top=t.top+(i.height-e.height),e.left=t.left+(i.width-e.width)),e},_respectSize:function(e){var t=this._vBoundaries,i=this.axis,s=this._isNumber(e.width)&&t.maxWidth&&t.maxWidth<e.width,n=this._isNumber(e.height)&&t.maxHeight&&t.maxHeight<e.height,a=this._isNumber(e.width)&&t.minWidth&&t.minWidth>e.width,o=this._isNumber(e.height)&&t.minHeight&&t.minHeight>e.height,r=this.originalPosition.left+this.originalSize.width,h=this.position.top+this.size.height,l=/sw|nw|w/.test(i),u=/nw|ne|n/.test(i);return a&&(e.width=t.minWidth),o&&(e.height=t.minHeight),s&&(e.width=t.maxWidth),n&&(e.height=t.maxHeight),a&&l&&(e.left=r-t.minWidth),s&&l&&(e.left=r-t.maxWidth),o&&u&&(e.top=h-t.minHeight),n&&u&&(e.top=h-t.maxHeight),e.width||e.height||e.left||!e.top?e.width||e.height||e.top||!e.left||(e.left=null):e.top=null,e},_getPaddingPlusBorderDimensions:function(e){for(var t=0,i=[],s=[e.css("borderTopWidth"),e.css("borderRightWidth"),e.css("borderBottomWidth"),e.css("borderLeftWidth")],n=[e.css("paddingTop"),e.css("paddingRight"),e.css("paddingBottom"),e.css("paddingLeft")];4>t;t++)i[t]=parseInt(s[t],10)||0,i[t]+=parseInt(n[t],10)||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var e,t=0,i=this.helper||this.element;this._proportionallyResizeElements.length>t;t++)e=this._proportionallyResizeElements[t],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(e)),e.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var t=this.element,i=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||e("<div style='overflow:hidden;'></div>"),this.helper.addClass(this._helper).css({width:this.element.outerWidth()-1,height:this.element.outerHeight()-1,position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(e,t){return{width:this.originalSize.width+t}},w:function(e,t){var i=this.originalSize,s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(e,t,i){return{height:this.originalSize.height+i}},se:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},sw:function(t,i,s){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,i,s]))},ne:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,i,s]))},nw:function(t,i,s){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,i,s]))}},_propagate:function(t,i){e.ui.plugin.call(this,t,[i,this.ui()]),"resize"!==t&&this._trigger(t,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),e.ui.plugin.add("resizable","animate",{stop:function(t){var i=e(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,a=n.length&&/textarea/i.test(n[0].nodeName),o=a&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=a?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-o},l=parseInt(i.element.css("left"),10)+(i.position.left-i.originalPosition.left)||null,u=parseInt(i.element.css("top"),10)+(i.position.top-i.originalPosition.top)||null;i.element.animate(e.extend(h,u&&l?{top:u,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseInt(i.element.css("width"),10),height:parseInt(i.element.css("height"),10),top:parseInt(i.element.css("top"),10),left:parseInt(i.element.css("left"),10)};n&&n.length&&e(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(){var t,i,s,n,a,o,r,h=e(this).resizable("instance"),l=h.options,u=h.element,d=l.containment,c=d instanceof e?d.get(0):/parent/.test(d)?u.parent().get(0):d;c&&(h.containerElement=e(c),/document/.test(d)||d===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight}):(t=e(c),i=[],e(["Top","Right","Left","Bottom"]).each(function(e,s){i[e]=h._num(t.css("padding"+s))}),h.containerOffset=t.offset(),h.containerPosition=t.position(),h.containerSize={height:t.innerHeight()-i[3],width:t.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,a=h.containerSize.width,o=h._hasScroll(c,"left")?c.scrollWidth:a,r=h._hasScroll(c)?c.scrollHeight:n,h.parentData={element:c,left:s.left,top:s.top,width:o,height:r}))},resize:function(t){var i,s,n,a,o=e(this).resizable("instance"),r=o.options,h=o.containerOffset,l=o.position,u=o._aspectRatio||t.shiftKey,d={top:0,left:0},c=o.containerElement,p=!0;c[0]!==document&&/static/.test(c.css("position"))&&(d=h),l.left<(o._helper?h.left:0)&&(o.size.width=o.size.width+(o._helper?o.position.left-h.left:o.position.left-d.left),u&&(o.size.height=o.size.width/o.aspectRatio,p=!1),o.position.left=r.helper?h.left:0),l.top<(o._helper?h.top:0)&&(o.size.height=o.size.height+(o._helper?o.position.top-h.top:o.position.top),u&&(o.size.width=o.size.height*o.aspectRatio,p=!1),o.position.top=o._helper?h.top:0),n=o.containerElement.get(0)===o.element.parent().get(0),a=/relative|absolute/.test(o.containerElement.css("position")),n&&a?(o.offset.left=o.parentData.left+o.position.left,o.offset.top=o.parentData.top+o.position.top):(o.offset.left=o.element.offset().left,o.offset.top=o.element.offset().top),i=Math.abs(o.sizeDiff.width+(o._helper?o.offset.left-d.left:o.offset.left-h.left)),s=Math.abs(o.sizeDiff.height+(o._helper?o.offset.top-d.top:o.offset.top-h.top)),i+o.size.width>=o.parentData.width&&(o.size.width=o.parentData.width-i,u&&(o.size.height=o.size.width/o.aspectRatio,p=!1)),s+o.size.height>=o.parentData.height&&(o.size.height=o.parentData.height-s,u&&(o.size.width=o.size.height*o.aspectRatio,p=!1)),p||(o.position.left=o.prevPosition.left,o.position.top=o.prevPosition.top,o.size.width=o.prevSize.width,o.size.height=o.prevSize.height)},stop:function(){var t=e(this).resizable("instance"),i=t.options,s=t.containerOffset,n=t.containerPosition,a=t.containerElement,o=e(t.helper),r=o.offset(),h=o.outerWidth()-t.sizeDiff.width,l=o.outerHeight()-t.sizeDiff.height;t._helper&&!i.animate&&/relative/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l}),t._helper&&!i.animate&&/static/.test(a.css("position"))&&e(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),e.ui.plugin.add("resizable","alsoResize",{start:function(){var t=e(this).resizable("instance"),i=t.options;e(i.alsoResize).each(function(){var t=e(this);t.data("ui-resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})},resize:function(t,i){var s=e(this).resizable("instance"),n=s.options,a=s.originalSize,o=s.originalPosition,r={height:s.size.height-a.height||0,width:s.size.width-a.width||0,top:s.position.top-o.top||0,left:s.position.left-o.left||0};e(n.alsoResize).each(function(){var t=e(this),s=e(this).data("ui-resizable-alsoresize"),n={},a=t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(a,function(e,t){var i=(s[t]||0)+(r[t]||0);i&&i>=0&&(n[t]=i||null)}),t.css(n)})},stop:function(){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","ghost",{start:function(){var t=e(this).resizable("instance"),i=t.options,s=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass("string"==typeof i.ghost?i.ghost:""),t.ghost.appendTo(t.helper)},resize:function(){var t=e(this).resizable("instance");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=e(this).resizable("instance");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(){var t,i=e(this).resizable("instance"),s=i.options,n=i.size,a=i.originalSize,o=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,u=h[1]||1,d=Math.round((n.width-a.width)/l)*l,c=Math.round((n.height-a.height)/u)*u,p=a.width+d,f=a.height+c,m=s.maxWidth&&p>s.maxWidth,g=s.maxHeight&&f>s.maxHeight,v=s.minWidth&&s.minWidth>p,y=s.minHeight&&s.minHeight>f;s.grid=h,v&&(p+=l),y&&(f+=u),m&&(p-=l),g&&(f-=u),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=o.top-c):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=o.left-d):((0>=f-u||0>=p-l)&&(t=i._getPaddingPlusBorderDimensions(this)),f-u>0?(i.size.height=f,i.position.top=o.top-c):(f=u-t.height,i.size.height=f,i.position.top=o.top+a.height-f),p-l>0?(i.size.width=p,i.position.left=o.left-d):(p=l-t.width,i.size.width=p,i.position.left=o.left+a.width-p))}}),e.ui.resizable,e.widget("ui.selectable",e.ui.mouse,{version:"1.11.4",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var t,i=this;this.element.addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){t=e(i.options.filter,i.element[0]),t.addClass("ui-selectee"),t.each(function(){var t=e(this),i=t.offset();e.data(this,"selectable-item",{element:this,$element:t,left:i.left,top:i.top,right:i.left+t.outerWidth(),bottom:i.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=t.addClass("ui-selectee"),this._mouseInit(),this.helper=e("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(t){var i=this,s=this.options;this.opos=[t.pageX,t.pageY],this.options.disabled||(this.selectees=e(s.filter,this.element[0]),this._trigger("start",t),e(s.appendTo).append(this.helper),this.helper.css({left:t.pageX,top:t.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=e.data(this,"selectable-item");s.startselected=!0,t.metaKey||t.ctrlKey||(s.$element.removeClass("ui-selected"),s.selected=!1,s.$element.addClass("ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",t,{unselecting:s.element}))}),e(t.target).parents().addBack().each(function(){var s,n=e.data(this,"selectable-item");return n?(s=!t.metaKey&&!t.ctrlKey||!n.$element.hasClass("ui-selected"),n.$element.removeClass(s?"ui-unselecting":"ui-selected").addClass(s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",t,{selecting:n.element}):i._trigger("unselecting",t,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(t){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,a=this.opos[0],o=this.opos[1],r=t.pageX,h=t.pageY;return a>r&&(i=r,r=a,a=i),o>h&&(i=h,h=o,o=i),this.helper.css({left:a,top:o,width:r-a,height:h-o}),this.selectees.each(function(){var i=e.data(this,"selectable-item"),l=!1;i&&i.element!==s.element[0]&&("touch"===n.tolerance?l=!(i.left>r||a>i.right||i.top>h||o>i.bottom):"fit"===n.tolerance&&(l=i.left>a&&r>i.right&&i.top>o&&h>i.bottom),l?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,s._trigger("selecting",t,{selecting:i.element}))):(i.selecting&&((t.metaKey||t.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",t,{unselecting:i.element}))),i.selected&&(t.metaKey||t.ctrlKey||i.startselected||(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",t,{unselecting:i.element})))))}),!1}},_mouseStop:function(t){var i=this;return this.dragged=!1,e(".ui-unselecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",t,{unselected:s.element})}),e(".ui-selecting",this.element[0]).each(function(){var s=e.data(this,"selectable-item");s.$element.removeClass("ui-selecting").addClass("ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",t,{selected:s.element})}),this._trigger("stop",t),this.helper.remove(),!1}}),e.widget("ui.sortable",e.ui.mouse,{version:"1.11.4",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(e,t,i){return e>=t&&t+i>e},_isFloating:function(e){return/left|right/.test(e.css("float"))||/inline|table-cell/.test(e.css("display"))},_create:function(){this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(e,t){this._super(e,t),"handle"===e&&this._setHandleClassName()},_setHandleClassName:function(){this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle"),e.each(this.items,function(){(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item).addClass("ui-sortable-handle")})},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,i){var s=null,n=!1,a=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(t),e(t.target).parents().each(function(){return e.data(this,a.widgetName+"-item")===a?(s=e(this),!1):void 0}),e.data(t.target,a.widgetName+"-item")===a&&(s=e(t.target)),s?!this.options.handle||i||(e(this.options.handle,s).find("*").addBack().each(function(){this===t.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(t,i,s){var n,a,o=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,o.cursorAt&&this._adjustOffsetFromHelper(o.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),o.containment&&this._setContainment(),o.cursor&&"auto"!==o.cursor&&(a=this.document.find("body"),this.storedCursor=a.css("cursor"),a.css("cursor",o.cursor),this.storedStylesheet=e("<style>*{ cursor: "+o.cursor+" !important; }</style>").appendTo(a)),o.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",o.opacity)),o.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",o.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){var i,s,n,a,o=this.options,r=!1;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<o.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+o.scrollSpeed:t.pageY-this.overflowOffset.top<o.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-o.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<o.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+o.scrollSpeed:t.pageX-this.overflowOffset.left<o.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-o.scrollSpeed)):(t.pageY-this.document.scrollTop()<o.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-o.scrollSpeed):this.window.height()-(t.pageY-this.document.scrollTop())<o.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+o.scrollSpeed)),t.pageX-this.document.scrollLeft()<o.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-o.scrollSpeed):this.window.width()-(t.pageX-this.document.scrollLeft())<o.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+o.scrollSpeed))),r!==!1&&e.ui.ddmanager&&!o.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],a=this._intersectsWithPointer(s),a&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===a?"next":"prev"]()[0]!==n&&!e.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!e.contains(this.element[0],n):!0)){if(this.direction=1===a?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;
this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,i){if(t){if(e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t),this.options.revert){var s=this,n=this.placeholder.offset(),a=this.options.axis,o={};a&&"x"!==a||(o.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),a&&"y"!==a||(o.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,e(this.helper).animate(o,parseInt(this.options.revert,10)||500,function(){s._clear(t)})}else this._clear(t,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},e(i).each(function(){var i=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[\-=_](.+)/);i&&s.push((t.key||i[1]+"[]")+"="+(t.key&&t.expression?i[1]:i[2]))}),!s.length&&t.key&&s.push(t.key+"="),s.join("&")},toArray:function(t){var i=this._getItemsAsjQuery(t&&t.connected),s=[];return t=t||{},i.each(function(){s.push(e(t.item||this).attr(t.attribute||"id")||"")}),s},_intersectsWith:function(e){var t=this.positionAbs.left,i=t+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,a=e.left,o=a+e.width,r=e.top,h=r+e.height,l=this.offset.click.top,u=this.offset.click.left,d="x"===this.options.axis||s+l>r&&h>s+l,c="y"===this.options.axis||t+u>a&&o>t+u,p=d&&c;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?p:t+this.helperProportions.width/2>a&&o>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(e){var t="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top,e.height),i="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left,e.width),s=t&&i,n=this._getDragVerticalDirection(),a=this._getDragHorizontalDirection();return s?this.floating?a&&"right"===a||"down"===n?2:1:n&&("down"===n?2:1):!1},_intersectsWithSides:function(e){var t=this._isOverAxis(this.positionAbs.top+this.offset.click.top,e.top+e.height/2,e.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,e.left+e.width/2,e.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&t||"up"===s&&!t)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return 0!==e&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return 0!==e&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor===String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){function i(){r.push(this)}var s,n,a,o,r=[],h=[],l=this._connectWith();if(l&&t)for(s=l.length-1;s>=0;s--)for(a=e(l[s],this.document[0]),n=a.length-1;n>=0;n--)o=e.data(a[n],this.widgetFullName),o&&o!==this&&!o.options.disabled&&h.push([e.isFunction(o.options.items)?o.options.items.call(o.element):e(o.options.items,o.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),o]);for(h.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return e(r)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var i=0;t.length>i;i++)if(t[i]===e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var i,s,n,a,o,r,h,l,u=this.items,d=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],c=this._connectWith();if(c&&this.ready)for(i=c.length-1;i>=0;i--)for(n=e(c[i],this.document[0]),s=n.length-1;s>=0;s--)a=e.data(n[s],this.widgetFullName),a&&a!==this&&!a.options.disabled&&(d.push([e.isFunction(a.options.items)?a.options.items.call(a.element[0],t,{item:this.currentItem}):e(a.options.items,a.element),a]),this.containers.push(a));for(i=d.length-1;i>=0;i--)for(o=d[i][1],r=d[i][0],s=0,l=r.length;l>s;s++)h=e(r[s]),h.data(this.widgetName+"-item",o),u.push({item:h,instance:o,width:0,height:0,left:0,top:0})},refreshPositions:function(t){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,a;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?e(this.options.toleranceElement,s.item):s.item,t||(s.width=n.outerWidth(),s.height=n.outerHeight()),a=n.offset(),s.left=a.left,s.top=a.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)a=this.containers[i].element.offset(),this.containers[i].containerCache.left=a.left,this.containers[i].containerCache.top=a.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(t){t=t||this;var i,s=t.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=t.currentItem[0].nodeName.toLowerCase(),n=e("<"+s+">",t.document[0]).addClass(i||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper");return"tbody"===s?t._createTrPlaceholder(t.currentItem.find("tr").eq(0),e("<tr>",t.document[0]).appendTo(n)):"tr"===s?t._createTrPlaceholder(t.currentItem,n):"img"===s&&n.attr("src",t.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(e,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10)))}}),t.placeholder=e(s.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),s.placeholder.update(t,t.placeholder)},_createTrPlaceholder:function(t,i){var s=this;t.children().each(function(){e("<td>&#160;</td>",s.document[0]).attr("colspan",e(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(t){var i,s,n,a,o,r,h,l,u,d,c=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!e.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(c&&e.contains(this.containers[i].element[0],c.element[0]))continue;c=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",t,this._uiHash(this)),this.containers[i].containerCache.over=0);if(c)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,a=null,u=c.floating||this._isFloating(this.currentItem),o=u?"left":"top",r=u?"width":"height",d=u?"clientX":"clientY",s=this.items.length-1;s>=0;s--)e.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[o],l=!1,t[d]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(t[d]-h)&&(n=Math.abs(t[d]-h),a=this.items[s],this.direction=l?"up":"down"));if(!a&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",t,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;a?this._rearrange(t,a,null,!0):this._rearrange(t,null,this.containers[p].element,!0),this._trigger("change",t,this._uiHash()),this.containers[p]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",t,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(t){var i=this.options,s=e.isFunction(i.helper)?e(i.helper.apply(this.element[0],[t,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||e("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&e.ui.ie)&&(t={top:0,left:0}),{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.width():this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(t=e(n.containment)[0],i=e(n.containment).offset(),s="hidden"!==e(t).css("overflow"),this.containment=[i.left+(parseInt(e(t).css("borderLeftWidth"),10)||0)+(parseInt(e(t).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(e(t).css("borderTopWidth"),10)||0)+(parseInt(e(t).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(e(t).css("borderLeftWidth"),10)||0)-(parseInt(e(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(e(t).css("borderTopWidth"),10)||0)-(parseInt(e(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,i){i||(i=this.position);var s="absolute"===t?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:n.scrollLeft())*s}},_generatePosition:function(t){var i,s,n=this.options,a=t.pageX,o=t.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(a=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(o=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(a=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(o=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((o-this.originalPageY)/n.grid[1])*n.grid[1],o=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((a-this.originalPageX)/n.grid[0])*n.grid[0],a=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(e,t,i,s){i?i[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(e,t){function i(e,t,i){return function(s){i._trigger(e,s,t._uiHash(t))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!t&&n.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||t||n.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(t||(n.push(function(e){this._trigger("remove",e,this._uiHash())}),n.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)t||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,t||this._trigger("beforeStop",e,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!t){for(s=0;n.length>s;s++)n[s].call(this,e);this._trigger("stop",e,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var i=t||this;return{helper:i.helper,placeholder:i.placeholder||e([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:t?t.element:null}}}),e.widget("ui.tabs",{version:"1.11.4",delay:300,options:{active:null,collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var e=/#.*$/;return function(t){var i,s;t=t.cloneNode(!1),i=t.href.replace(e,""),s=location.href.replace(e,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return t.hash.length>1&&i===s}}(),_create:function(){var t=this,i=this.options;this.running=!1,this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible",i.collapsible),this._processTabs(),i.active=this._initialActive(),e.isArray(i.disabled)&&(i.disabled=e.unique(i.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"),function(e){return t.tabs.index(e)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):e(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var t=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===t&&(s&&this.tabs.each(function(i,n){return e(n).attr("aria-controls")===s?(t=i,!1):void 0}),null===t&&(t=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===t||-1===t)&&(t=this.tabs.length?0:!1)),t!==!1&&(t=this.tabs.index(this.tabs.eq(t)),-1===t&&(t=i?!1:0)),!i&&t===!1&&this.anchors.length&&(t=0),t},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):e()}},_tabKeydown:function(t){var i=e(this.document[0].activeElement).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(t)){switch(t.keyCode){case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:s++;break;case e.ui.keyCode.UP:case e.ui.keyCode.LEFT:n=!1,s--;break;case e.ui.keyCode.END:s=this.anchors.length-1;break;case e.ui.keyCode.HOME:s=0;break;case e.ui.keyCode.SPACE:return t.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case e.ui.keyCode.ENTER:return t.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}t.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),t.ctrlKey||t.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(t){this._handlePageNav(t)||t.ctrlKey&&t.keyCode===e.ui.keyCode.UP&&(t.preventDefault(),this.active.focus())},_handlePageNav:function(t){return t.altKey&&t.keyCode===e.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):t.altKey&&t.keyCode===e.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(t,i){function s(){return t>n&&(t=0),0>t&&(t=n),t}for(var n=this.tabs.length-1;-1!==e.inArray(s(),this.options.disabled);)t=i?t+1:t-1;return t},_focusNextTab:function(e,t){return e=this._findNextTab(e,t),this.tabs.eq(e).focus(),e},_setOption:function(e,t){return"active"===e?(this._activate(t),void 0):"disabled"===e?(this._setupDisabled(t),void 0):(this._super(e,t),"collapsible"===e&&(this.element.toggleClass("ui-tabs-collapsible",t),t||this.options.active!==!1||this._activate(0)),"event"===e&&this._setupEvents(t),"heightStyle"===e&&this._setupHeightStyle(t),void 0)},_sanitizeSelector:function(e){return e?e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,i=this.tablist.children(":has(a[href])");t.disabled=e.map(i.filter(".ui-state-disabled"),function(e){return i.index(e)}),this._processTabs(),t.active!==!1&&this.anchors.length?this.active.length&&!e.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!1,this.active=e()):this._activate(this._findNextTab(Math.max(0,t.active-1),!1)):t.active=this.tabs.index(this.active):(t.active=!1,this.active=e()),this._refresh()},_refresh:function(){this._setupDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.addClass("ui-tabs-active ui-state-active").attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var t=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role","tablist").delegate("> li","mousedown"+this.eventNamespace,function(t){e(this).is(".ui-state-disabled")&&t.preventDefault()}).delegate(".ui-tabs-anchor","focus"+this.eventNamespace,function(){e(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({role:"tab",tabIndex:-1}),this.anchors=this.tabs.map(function(){return e("a",this)[0]}).addClass("ui-tabs-anchor").attr({role:"presentation",tabIndex:-1}),this.panels=e(),this.anchors.each(function(i,s){var n,a,o,r=e(s).uniqueId().attr("id"),h=e(s).closest("li"),l=h.attr("aria-controls");t._isLocal(s)?(n=s.hash,o=n.substring(1),a=t.element.find(t._sanitizeSelector(n))):(o=h.attr("aria-controls")||e({}).uniqueId()[0].id,n="#"+o,a=t.element.find(n),a.length||(a=t._createPanel(o),a.insertAfter(t.panels[i-1]||t.tablist)),a.attr("aria-live","polite")),a.length&&(t.panels=t.panels.add(a)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":o,"aria-labelledby":r}),a.attr("aria-labelledby",r)}),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role","tabpanel"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol,ul").eq(0)},_createPanel:function(t){return e("<div>").attr("id",t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy",!0)},_setupDisabled:function(t){e.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!0):t=!1);for(var i,s=0;i=this.tabs[s];s++)t===!0||-1!==e.inArray(s,t)?e(i).addClass("ui-state-disabled").attr("aria-disabled","true"):e(i).removeClass("ui-state-disabled").removeAttr("aria-disabled");this.options.disabled=t},_setupEvents:function(t){var i={};t&&e.each(t.split(" "),function(e,t){i[t]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(e){e.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var i,s=this.element.parent();"fill"===t?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var t=e(this),s=t.css("position");"absolute"!==s&&"fixed"!==s&&(i-=t.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=e(this).outerHeight(!0)}),this.panels.each(function(){e(this).height(Math.max(0,i-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):"auto"===t&&(i=0,this.panels.each(function(){i=Math.max(i,e(this).height("").height())}).height(i))},_eventHandler:function(t){var i=this.options,s=this.active,n=e(t.currentTarget),a=n.closest("li"),o=a[0]===s[0],r=o&&i.collapsible,h=r?e():this._getPanelForTab(a),l=s.length?this._getPanelForTab(s):e(),u={oldTab:s,oldPanel:l,newTab:r?e():a,newPanel:h};t.preventDefault(),a.hasClass("ui-state-disabled")||a.hasClass("ui-tabs-loading")||this.running||o&&!i.collapsible||this._trigger("beforeActivate",t,u)===!1||(i.active=r?!1:this.tabs.index(a),this.active=o?e():a,this.xhr&&this.xhr.abort(),l.length||h.length||e.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(a),t),this._toggle(t,u))},_toggle:function(t,i){function s(){a.running=!1,a._trigger("activate",t,i)}function n(){i.newTab.closest("li").addClass("ui-tabs-active ui-state-active"),o.length&&a.options.show?a._show(o,a.options.show,s):(o.show(),s())}var a=this,o=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),n()}):(i.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),o.length&&r.length?i.oldTab.attr("tabIndex",-1):o.length&&this.tabs.filter(function(){return 0===e(this).attr("tabIndex")}).attr("tabIndex",-1),o.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(t){var i,s=this._findActive(t);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:e.noop}))},_findActive:function(t){return t===!1?e():this.tabs.eq(t)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+e+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"),this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"),this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(),this.tablist.unbind(this.eventNamespace),this.tabs.add(this.panels).each(function(){e.data(this,"ui-tabs-destroy")?e(this).remove():e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")}),this.tabs.each(function(){var t=e(this),i=t.data("ui-tabs-aria-controls");i?t.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):t.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(t){var i=this.options.disabled;i!==!1&&(void 0===t?i=!1:(t=this._getIndex(t),i=e.isArray(i)?e.map(i,function(e){return e!==t?e:null}):e.map(this.tabs,function(e,i){return i!==t?i:null})),this._setupDisabled(i))},disable:function(t){var i=this.options.disabled;if(i!==!0){if(void 0===t)i=!0;else{if(t=this._getIndex(t),-1!==e.inArray(t,i))return;i=e.isArray(i)?e.merge([t],i).sort():[t]}this._setupDisabled(i)}},load:function(t,i){t=this._getIndex(t);var s=this,n=this.tabs.eq(t),a=n.find(".ui-tabs-anchor"),o=this._getPanelForTab(n),r={tab:n,panel:o},h=function(e,t){"abort"===t&&s.panels.stop(!1,!0),n.removeClass("ui-tabs-loading"),o.removeAttr("aria-busy"),e===s.xhr&&delete s.xhr};this._isLocal(a[0])||(this.xhr=e.ajax(this._ajaxSettings(a,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(n.addClass("ui-tabs-loading"),o.attr("aria-busy","true"),this.xhr.done(function(e,t,n){setTimeout(function(){o.html(e),s._trigger("load",i,r),h(n,t)},1)}).fail(function(e,t){setTimeout(function(){h(e,t)},1)})))},_ajaxSettings:function(t,i,s){var n=this;return{url:t.attr("href"),beforeSend:function(t,a){return n._trigger("beforeLoad",i,e.extend({jqXHR:t,ajaxSettings:a},s))}}},_getPanelForTab:function(t){var i=e(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}})});

;/* 
  @package NOTY - Dependency-free notification library 
  @version version: 3.2.0-beta 
  @contributors https://github.com/needim/noty/graphs/contributors 
  @documentation Examples and Documentation - https://ned.im/noty 
  @license Licensed under the MIT licenses: http://www.opensource.org/licenses/mit-license.php 
*/

!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Noty",[],e):"object"==typeof exports?exports.Noty=e():t.Noty=e()}(this,function(){return function(t){function e(o){if(n[o])return n[o].exports;var i=n[o]={i:o,l:!1,exports:{}};return t[o].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,o){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:o})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=6)}([function(t,e,n){"use strict";function o(t,e,n){var o=void 0;if(!n){for(o in e)if(e.hasOwnProperty(o)&&e[o]===t)return!0}else for(o in e)if(e.hasOwnProperty(o)&&e[o]===t)return!0;return!1}function i(t){t=t||window.event,void 0!==t.stopPropagation?t.stopPropagation():t.cancelBubble=!0}function r(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e="noty_"+t+"_";return e+="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){var e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)})}function s(t){var e=t.offsetHeight,n=window.getComputedStyle(t);return e+=parseInt(n.marginTop)+parseInt(n.marginBottom)}function u(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];e=e.split(" ");for(var i=0;i<e.length;i++)document.addEventListener?t.addEventListener(e[i],n,o):document.attachEvent&&t.attachEvent("on"+e[i],n)}function a(t,e){return("string"==typeof t?t:f(t)).indexOf(" "+e+" ")>=0}function c(t,e){var n=f(t),o=n+e;a(n,e)||(t.className=o.substring(1))}function l(t,e){var n=f(t),o=void 0;a(t,e)&&(o=n.replace(" "+e+" "," "),t.className=o.substring(1,o.length-1))}function d(t){t.parentNode&&t.parentNode.removeChild(t)}function f(t){return(" "+(t&&t.className||"")+" ").replace(/\s+/gi," ")}function h(){function t(){b.PageHidden=document[s],o()}function e(){b.PageHidden=!0,o()}function n(){b.PageHidden=!1,o()}function o(){b.PageHidden?i():r()}function i(){setTimeout(function(){Object.keys(b.Store).forEach(function(t){b.Store.hasOwnProperty(t)&&b.Store[t].options.visibilityControl&&b.Store[t].stop()})},100)}function r(){setTimeout(function(){Object.keys(b.Store).forEach(function(t){b.Store.hasOwnProperty(t)&&b.Store[t].options.visibilityControl&&b.Store[t].resume()}),b.queueRenderAll()},100)}var s=void 0,a=void 0;void 0!==document.hidden?(s="hidden",a="visibilitychange"):void 0!==document.msHidden?(s="msHidden",a="msvisibilitychange"):void 0!==document.webkitHidden&&(s="webkitHidden",a="webkitvisibilitychange"),a&&u(document,a,t),u(window,"blur",e),u(window,"focus",n)}function p(t){if(t.hasSound){var e=document.createElement("audio");t.options.sounds.sources.forEach(function(t){var n=document.createElement("source");n.src=t,n.type="audio/"+m(t),e.appendChild(n)}),t.barDom?t.barDom.appendChild(e):document.querySelector("body").appendChild(e),e.volume=t.options.sounds.volume,t.soundPlayed||(e.play(),t.soundPlayed=!0),e.onended=function(){d(e)}}}function m(t){return t.match(/\.([^.]+)$/)[1]}Object.defineProperty(e,"__esModule",{value:!0}),e.css=e.deepExtend=e.animationEndEvents=void 0;var v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};e.inArray=o,e.stopPropagation=i,e.generateID=r,e.outerHeight=s,e.addListener=u,e.hasClass=a,e.addClass=c,e.removeClass=l,e.remove=d,e.classList=f,e.visibilityChangeFlow=h,e.createAudioElements=p;var y=n(1),b=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}(y);e.animationEndEvents="webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend",e.deepExtend=function t(e){e=e||{};for(var n=1;n<arguments.length;n++){var o=arguments[n];if(o)for(var i in o)o.hasOwnProperty(i)&&(Array.isArray(o[i])?e[i]=o[i]:"object"===v(o[i])&&null!==o[i]?e[i]=t(e[i],o[i]):e[i]=o[i])}return e},e.css=function(){function t(t){return t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(t,e){return e.toUpperCase()})}function e(t){var e=document.body.style;if(t in e)return t;for(var n=i.length,o=t.charAt(0).toUpperCase()+t.slice(1),r=void 0;n--;)if((r=i[n]+o)in e)return r;return t}function n(n){return n=t(n),r[n]||(r[n]=e(n))}function o(t,e,o){e=n(e),t.style[e]=o}var i=["Webkit","O","Moz","ms"],r={};return function(t,e){var n=arguments,i=void 0,r=void 0;if(2===n.length)for(i in e)e.hasOwnProperty(i)&&void 0!==(r=e[i])&&e.hasOwnProperty(i)&&o(t,i,r);else o(t,n[1],n[2])}}()},function(t,e,n){"use strict";function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"global",e=0,n=x;return E.hasOwnProperty(t)&&(n=E[t].maxVisible,Object.keys(P).forEach(function(n){P[n].options.queue!==t||P[n].closed||e++})),{current:e,maxVisible:n}}function i(t){E.hasOwnProperty(t.options.queue)||(E[t.options.queue]={maxVisible:x,queue:[]}),E[t.options.queue].queue.push(t)}function r(t){if(E.hasOwnProperty(t.options.queue)){var e=[];Object.keys(E[t.options.queue].queue).forEach(function(n){E[t.options.queue].queue[n].id!==t.id&&e.push(E[t.options.queue].queue[n])}),E[t.options.queue].queue=e}}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"global";if(E.hasOwnProperty(t)){var e=E[t].queue.shift();e&&e.show()}}function u(){Object.keys(E).forEach(function(t){s(t)})}function a(t){var e=k.generateID("ghost"),n=document.createElement("div");n.setAttribute("id",e),k.css(n,{height:k.outerHeight(t.barDom)+"px"}),t.barDom.insertAdjacentHTML("afterend",n.outerHTML),k.remove(t.barDom),n=document.getElementById(e),k.addClass(n,"noty_fix_effects_height"),k.addListener(n,k.animationEndEvents,function(){k.remove(n)})}function c(t){m(t);var e='<div class="noty_body">'+t.options.text+"</div>"+d(t)+'<div class="noty_progressbar"></div>';t.barDom=document.createElement("div"),t.barDom.setAttribute("id",t.id),k.addClass(t.barDom,"noty_bar noty_type__"+t.options.type+" noty_theme__"+t.options.theme),t.barDom.innerHTML=e,b(t,"onTemplate")}function l(t){return!(!t.options.buttons||!Object.keys(t.options.buttons).length)}function d(t){if(l(t)){var e=document.createElement("div");return k.addClass(e,"noty_buttons"),Object.keys(t.options.buttons).forEach(function(n){e.appendChild(t.options.buttons[n].dom)}),t.options.buttons.forEach(function(t){e.appendChild(t.dom)}),e.outerHTML}return""}function f(t){t.options.modal&&(0===C&&p(),e.DocModalCount=C+=1)}function h(t){if(t.options.modal&&C>0&&(e.DocModalCount=C-=1,C<=0)){var n=document.querySelector(".noty_modal");n&&(k.removeClass(n,"noty_modal_open"),k.addClass(n,"noty_modal_close"),k.addListener(n,k.animationEndEvents,function(){k.remove(n)}))}}function p(){var t=document.querySelector("body"),e=document.createElement("div");k.addClass(e,"noty_modal"),t.insertBefore(e,t.firstChild),k.addClass(e,"noty_modal_open"),k.addListener(e,k.animationEndEvents,function(){k.removeClass(e,"noty_modal_open")})}function m(t){if(t.options.container)return void(t.layoutDom=document.querySelector(t.options.container));var e="noty_layout__"+t.options.layout;t.layoutDom=document.querySelector("div#"+e),t.layoutDom||(t.layoutDom=document.createElement("div"),t.layoutDom.setAttribute("id",e),t.layoutDom.setAttribute("role","alert"),t.layoutDom.setAttribute("aria-live","polite"),k.addClass(t.layoutDom,"noty_layout"),document.querySelector("body").appendChild(t.layoutDom))}function v(t){t.options.timeout&&(t.options.progressBar&&t.progressDom&&k.css(t.progressDom,{transition:"width "+t.options.timeout+"ms linear",width:"0%"}),clearTimeout(t.closeTimer),t.closeTimer=setTimeout(function(){t.close()},t.options.timeout))}function y(t){t.options.timeout&&t.closeTimer&&(clearTimeout(t.closeTimer),t.closeTimer=-1,t.options.progressBar&&t.progressDom&&k.css(t.progressDom,{transition:"width 0ms linear",width:"100%"}))}function b(t,e){t.listeners.hasOwnProperty(e)&&t.listeners[e].forEach(function(e){"function"==typeof e&&e.apply(t)})}function w(t){b(t,"afterShow"),v(t),k.addListener(t.barDom,"mouseenter",function(){y(t)}),k.addListener(t.barDom,"mouseleave",function(){v(t)})}function g(t){delete P[t.id],t.closing=!1,b(t,"afterClose"),k.remove(t.barDom),0!==t.layoutDom.querySelectorAll(".noty_bar").length||t.options.container||k.remove(t.layoutDom),(k.inArray("docVisible",t.options.titleCount.conditions)||k.inArray("docHidden",t.options.titleCount.conditions))&&D.decrement(),s(t.options.queue)}Object.defineProperty(e,"__esModule",{value:!0}),e.Defaults=e.Store=e.Queues=e.DefaultMaxVisible=e.docTitle=e.DocModalCount=e.PageHidden=void 0,e.getQueueCounts=o,e.addToQueue=i,e.removeFromQueue=r,e.queueRender=s,e.queueRenderAll=u,e.ghostFix=a,e.build=c,e.hasButtons=l,e.handleModal=f,e.handleModalClose=h,e.queueClose=v,e.dequeueClose=y,e.fire=b,e.openFlow=w,e.closeFlow=g;var _=n(0),k=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}(_),C=(e.PageHidden=!1,e.DocModalCount=0),S={originalTitle:null,count:0,changed:!1,timer:-1},D=e.docTitle={increment:function(){S.count++,D._update()},decrement:function(){if(--S.count<=0)return void D._clear();D._update()},_update:function(){var t=document.title;S.changed?document.title="("+S.count+") "+S.originalTitle:(S.originalTitle=t,document.title="("+S.count+") "+t,S.changed=!0)},_clear:function(){S.changed&&(S.count=0,document.title=S.originalTitle,S.changed=!1)}},x=e.DefaultMaxVisible=5,E=e.Queues={global:{maxVisible:x,queue:[]}},P=e.Store={};e.Defaults={type:"alert",layout:"topRight",theme:"mint",text:"",timeout:!1,progressBar:!0,closeWith:["click"],animation:{open:"noty_effects_open",close:"noty_effects_close"},id:!1,force:!1,killer:!1,queue:"global",container:!1,buttons:[],callbacks:{beforeShow:null,onShow:null,afterShow:null,onClose:null,afterClose:null,onClick:null,onHover:null,onTemplate:null},sounds:{sources:[],volume:1,conditions:[]},titleCount:{conditions:[]},modal:!1,visibilityControl:!1}},function(t,e,n){"use strict";function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0}),e.NotyButton=void 0;var i=n(0),r=function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}(i);e.NotyButton=function t(e,n,i){var s=this,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return o(this,t),this.dom=document.createElement("button"),this.dom.innerHTML=e,this.id=u.id=u.id||r.generateID("button"),this.cb=i,Object.keys(u).forEach(function(t){s.dom.setAttribute(t,u[t])}),r.addClass(this.dom,n||"noty_btn"),this}},function(t,e,n){"use strict";function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var i=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}return function(e,n,o){return n&&t(e.prototype,n),o&&t(e,o),e}}();e.Push=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"/service-worker.js";return o(this,t),this.subData={},this.workerPath=e,this.listeners={onPermissionGranted:[],onPermissionDenied:[],onSubscriptionSuccess:[],onSubscriptionCancel:[],onWorkerError:[],onWorkerSuccess:[],onWorkerNotSupported:[]},this}return i(t,[{key:"on",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){};return"function"==typeof e&&this.listeners.hasOwnProperty(t)&&this.listeners[t].push(e),this}},{key:"fire",value:function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];this.listeners.hasOwnProperty(t)&&this.listeners[t].forEach(function(t){"function"==typeof t&&t.apply(e,n)})}},{key:"create",value:function(){console.log("NOT IMPLEMENTED YET")}},{key:"isSupported",value:function(){var t=!1;try{t=window.Notification||window.webkitNotifications||navigator.mozNotification||window.external&&void 0!==window.external.msIsSiteMode()}catch(t){}return t}},{key:"getPermissionStatus",value:function(){var t="default";if(window.Notification&&window.Notification.permissionLevel)t=window.Notification.permissionLevel;else if(window.webkitNotifications&&window.webkitNotifications.checkPermission)switch(window.webkitNotifications.checkPermission()){case 1:t="default";break;case 0:t="granted";break;default:t="denied"}else window.Notification&&window.Notification.permission?t=window.Notification.permission:navigator.mozNotification?t="granted":window.external&&void 0!==window.external.msIsSiteMode()&&(t=window.external.msIsSiteMode()?"granted":"default");return t.toString().toLowerCase()}},{key:"getEndpoint",value:function(t){var e=t.endpoint,n=t.subscriptionId;return n&&-1===e.indexOf(n)&&(e+="/"+n),e}},{key:"isSWRegistered",value:function(){try{return"activated"===navigator.serviceWorker.controller.state}catch(t){return!1}}},{key:"unregisterWorker",value:function(){var t=this;"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(function(e){var n=!0,o=!1,i=void 0;try{for(var r,s=e[Symbol.iterator]();!(n=(r=s.next()).done);n=!0){r.value.unregister(),t.fire("onSubscriptionCancel")}}catch(t){o=!0,i=t}finally{try{!n&&s.return&&s.return()}finally{if(o)throw i}}})}},{key:"requestSubscription",value:function(){var t=this,e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],n=this,o=this.getPermissionStatus(),i=function(o){"granted"===o?(t.fire("onPermissionGranted"),"serviceWorker"in navigator?navigator.serviceWorker.register(t.workerPath).then(function(){navigator.serviceWorker.ready.then(function(t){n.fire("onWorkerSuccess"),t.pushManager.subscribe({userVisibleOnly:e}).then(function(t){var e=t.getKey("p256dh"),o=t.getKey("auth");n.subData={endpoint:n.getEndpoint(t),p256dh:e?window.btoa(String.fromCharCode.apply(null,new Uint8Array(e))):null,auth:o?window.btoa(String.fromCharCode.apply(null,new Uint8Array(o))):null},n.fire("onSubscriptionSuccess",[n.subData])}).catch(function(t){n.fire("onWorkerError",[t])})})}):n.fire("onWorkerNotSupported")):"denied"===o&&(t.fire("onPermissionDenied"),t.unregisterWorker())};"default"===o?window.Notification&&window.Notification.requestPermission?window.Notification.requestPermission(i):window.webkitNotifications&&window.webkitNotifications.checkPermission&&window.webkitNotifications.requestPermission(i):i(o)}}]),t}()},function(t,e,n){(function(e,o){/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.1.1
 */
!function(e,n){t.exports=n()}(0,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function i(t){return"function"==typeof t}function r(t){z=t}function s(t){U=t}function u(){return void 0!==R?function(){R(c)}:a()}function a(){var t=setTimeout;return function(){return t(c,1)}}function c(){for(var t=0;t<I;t+=2){(0,X[t])(X[t+1]),X[t]=void 0,X[t+1]=void 0}I=0}function l(t,e){var n=arguments,o=this,i=new this.constructor(f);void 0===i[tt]&&A(i);var r=o._state;return r?function(){var t=n[r-1];U(function(){return P(r,i,t,o._result)})}():S(o,i,t,e),i}function d(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(f);return g(n,t),n}function f(){}function h(){return new TypeError("You cannot resolve a promise with itself")}function p(){return new TypeError("A promises callback cannot return that same promise.")}function m(t){try{return t.then}catch(t){return it.error=t,it}}function v(t,e,n,o){try{t.call(e,n,o)}catch(t){return t}}function y(t,e,n){U(function(t){var o=!1,i=v(n,e,function(n){o||(o=!0,e!==n?g(t,n):k(t,n))},function(e){o||(o=!0,C(t,e))},"Settle: "+(t._label||" unknown promise"));!o&&i&&(o=!0,C(t,i))},t)}function b(t,e){e._state===nt?k(t,e._result):e._state===ot?C(t,e._result):S(e,void 0,function(e){return g(t,e)},function(e){return C(t,e)})}function w(t,e,n){e.constructor===t.constructor&&n===l&&e.constructor.resolve===d?b(t,e):n===it?(C(t,it.error),it.error=null):void 0===n?k(t,e):i(n)?y(t,e,n):k(t,e)}function g(e,n){e===n?C(e,h()):t(n)?w(e,n,m(n)):k(e,n)}function _(t){t._onerror&&t._onerror(t._result),D(t)}function k(t,e){t._state===et&&(t._result=e,t._state=nt,0!==t._subscribers.length&&U(D,t))}function C(t,e){t._state===et&&(t._state=ot,t._result=e,U(_,t))}function S(t,e,n,o){var i=t._subscribers,r=i.length;t._onerror=null,i[r]=e,i[r+nt]=n,i[r+ot]=o,0===r&&t._state&&U(D,t)}function D(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var o=void 0,i=void 0,r=t._result,s=0;s<e.length;s+=3)o=e[s],i=e[s+n],o?P(n,o,i,r):i(r);t._subscribers.length=0}}function x(){this.error=null}function E(t,e){try{return t(e)}catch(t){return rt.error=t,rt}}function P(t,e,n,o){var r=i(n),s=void 0,u=void 0,a=void 0,c=void 0;if(r){if(s=E(n,o),s===rt?(c=!0,u=s.error,s.error=null):a=!0,e===s)return void C(e,p())}else s=o,a=!0;e._state!==et||(r&&a?g(e,s):c?C(e,u):t===nt?k(e,s):t===ot&&C(e,s))}function T(t,e){try{e(function(e){g(t,e)},function(e){C(t,e)})}catch(e){C(t,e)}}function O(){return st++}function A(t){t[tt]=st++,t._state=void 0,t._result=void 0,t._subscribers=[]}function M(t,e){this._instanceConstructor=t,this.promise=new t(f),this.promise[tt]||A(this.promise),F(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?k(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&k(this.promise,this._result))):C(this.promise,q())}function q(){return new Error("Array Methods must be provided an Array")}function j(t){return new M(this,t).promise}function N(t){var e=this;return new e(F(t)?function(n,o){for(var i=t.length,r=0;r<i;r++)e.resolve(t[r]).then(n,o)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function L(t){var e=this,n=new e(f);return C(n,t),n}function H(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function W(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function Q(t){this[tt]=O(),this._result=this._state=void 0,this._subscribers=[],f!==t&&("function"!=typeof t&&H(),this instanceof Q?T(this,t):W())}function V(){var t=void 0;if(void 0!==o)t=o;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(t){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;if(e){var n=null;try{n=Object.prototype.toString.call(e.resolve())}catch(t){}if("[object Promise]"===n&&!e.cast)return}t.Promise=Q}var B=void 0;B=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var F=B,I=0,R=void 0,z=void 0,U=function(t,e){X[I]=t,X[I+1]=e,2===(I+=2)&&(z?z(c):Z())},Y="undefined"!=typeof window?window:void 0,K=Y||{},G=K.MutationObserver||K.WebKitMutationObserver,$="undefined"==typeof self&&void 0!==e&&"[object process]"==={}.toString.call(e),J="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,X=new Array(1e3),Z=void 0;Z=$?function(){return function(){return e.nextTick(c)}}():G?function(){var t=0,e=new G(c),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}():J?function(){var t=new MessageChannel;return t.port1.onmessage=c,function(){return t.port2.postMessage(0)}}():void 0===Y?function(){try{var t=n(9);return R=t.runOnLoop||t.runOnContext,u()}catch(t){return a()}}():a();var tt=Math.random().toString(36).substring(16),et=void 0,nt=1,ot=2,it=new x,rt=new x,st=0;return M.prototype._enumerate=function(t){for(var e=0;this._state===et&&e<t.length;e++)this._eachEntry(t[e],e)},M.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,o=n.resolve;if(o===d){var i=m(t);if(i===l&&t._state!==et)this._settledAt(t._state,e,t._result);else if("function"!=typeof i)this._remaining--,this._result[e]=t;else if(n===Q){var r=new n(f);w(r,t,i),this._willSettleAt(r,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(o(t),e)},M.prototype._settledAt=function(t,e,n){var o=this.promise;o._state===et&&(this._remaining--,t===ot?C(o,n):this._result[e]=n),0===this._remaining&&k(o,this._result)},M.prototype._willSettleAt=function(t,e){var n=this;S(t,void 0,function(t){return n._settledAt(nt,e,t)},function(t){return n._settledAt(ot,e,t)})},Q.all=j,Q.race=N,Q.resolve=d,Q.reject=L,Q._setScheduler=r,Q._setAsap=s,Q._asap=U,Q.prototype={constructor:Q,then:l,catch:function(t){return this.then(null,t)}},Q.polyfill=V,Q.Promise=Q,Q})}).call(e,n(7),n(8))},function(t,e){},function(t,e,n){"use strict";function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}return function(e,n,o){return n&&t(e.prototype,n),o&&t(e,o),e}}();n(5);var s=n(4),u=function(t){return t&&t.__esModule?t:{default:t}}(s),a=n(0),c=o(a),l=n(1),d=o(l),f=n(2),h=n(3),p=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i(this,t),this.options=c.deepExtend({},d.Defaults,e),d.Store[this.options.id]?d.Store[this.options.id]:(this.id=this.options.id||c.generateID("bar"),this.closeTimer=-1,this.barDom=null,this.layoutDom=null,this.progressDom=null,this.showing=!1,this.shown=!1,this.closed=!1,this.closing=!1,this.killable=this.options.timeout||this.options.closeWith.length>0,this.hasSound=this.options.sounds.sources.length>0,this.soundPlayed=!1,this.listeners={beforeShow:[],onShow:[],afterShow:[],onClose:[],afterClose:[],onClick:[],onHover:[],onTemplate:[]},this.promises={show:null,close:null},this.on("beforeShow",this.options.callbacks.beforeShow),this.on("onShow",this.options.callbacks.onShow),this.on("afterShow",this.options.callbacks.afterShow),this.on("onClose",this.options.callbacks.onClose),this.on("afterClose",this.options.callbacks.afterClose),this.on("onClick",this.options.callbacks.onClick),this.on("onHover",this.options.callbacks.onHover),this.on("onTemplate",this.options.callbacks.onTemplate),this)}return r(t,[{key:"on",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:function(){};return"function"==typeof e&&this.listeners.hasOwnProperty(t)&&this.listeners[t].push(e),this}},{key:"show",value:function(){var e=this;if(this.showing||this.shown)return this;!0===this.options.killer?t.closeAll():"string"==typeof this.options.killer&&t.closeAll(this.options.killer);var n=d.getQueueCounts(this.options.queue);if(n.current>=n.maxVisible||d.PageHidden&&this.options.visibilityControl)return d.addToQueue(this),d.PageHidden&&this.hasSound&&c.inArray("docHidden",this.options.sounds.conditions)&&c.createAudioElements(this),d.PageHidden&&c.inArray("docHidden",this.options.titleCount.conditions)&&d.docTitle.increment(),this;if(d.Store[this.id]=this,d.fire(this,"beforeShow"),this.showing=!0,this.closing)return this.showing=!1,this;if(d.build(this),d.handleModal(this),this.options.force?this.layoutDom.insertBefore(this.barDom,this.layoutDom.firstChild):this.layoutDom.appendChild(this.barDom),this.hasSound&&!this.soundPlayed&&c.inArray("docVisible",this.options.sounds.conditions)&&c.createAudioElements(this),c.inArray("docVisible",this.options.titleCount.conditions)&&d.docTitle.increment(),this.shown=!0,this.closed=!1,d.hasButtons(this)&&Object.keys(this.options.buttons).forEach(function(t){var n=e.barDom.querySelector("#"+e.options.buttons[t].id);c.addListener(n,"click",function(n){c.stopPropagation(n),e.options.buttons[t].cb(e)})}),this.progressDom=this.barDom.querySelector(".noty_progressbar"),c.inArray("click",this.options.closeWith)&&(c.addClass(this.barDom,"noty_close_with_click"),c.addListener(this.barDom,"click",function(t){c.stopPropagation(t),d.fire(e,"onClick"),e.close()},!1)),c.addListener(this.barDom,"mouseenter",function(){d.fire(e,"onHover")},!1),this.options.timeout&&c.addClass(this.barDom,"noty_has_timeout"),this.options.progressBar&&c.addClass(this.barDom,"noty_has_progressbar"),c.inArray("button",this.options.closeWith)){c.addClass(this.barDom,"noty_close_with_button");var o=document.createElement("div");c.addClass(o,"noty_close_button"),o.innerHTML="×",this.barDom.appendChild(o),c.addListener(o,"click",function(t){c.stopPropagation(t),e.close()},!1)}return d.fire(this,"onShow"),null===this.options.animation.open?this.promises.show=new u.default(function(t){t()}):"function"==typeof this.options.animation.open?this.promises.show=new u.default(this.options.animation.open.bind(this)):(c.addClass(this.barDom,this.options.animation.open),this.promises.show=new u.default(function(t){c.addListener(e.barDom,c.animationEndEvents,function(){c.removeClass(e.barDom,e.options.animation.open),t()})})),this.promises.show.then(function(){var t=e;setTimeout(function(){d.openFlow(t)},100)}),this}},{key:"stop",value:function(){return d.dequeueClose(this),this}},{key:"resume",value:function(){return d.queueClose(this),this}},{key:"setTimeout",value:function(t){function e(e){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}(function(t){if(this.stop(),this.options.timeout=t,this.barDom){this.options.timeout?c.addClass(this.barDom,"noty_has_timeout"):c.removeClass(this.barDom,"noty_has_timeout");var e=this;setTimeout(function(){e.resume()},100)}return this})},{key:"setText",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.barDom&&(this.barDom.querySelector(".noty_body").innerHTML=t),e&&(this.options.text=t),this}},{key:"setType",value:function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.barDom){c.classList(this.barDom).split(" ").forEach(function(t){"noty_type__"===t.substring(0,11)&&c.removeClass(e.barDom,t)}),c.addClass(this.barDom,"noty_type__"+t)}return n&&(this.options.type=t),this}},{key:"setTheme",value:function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.barDom){c.classList(this.barDom).split(" ").forEach(function(t){"noty_theme__"===t.substring(0,12)&&c.removeClass(e.barDom,t)}),c.addClass(this.barDom,"noty_theme__"+t)}return n&&(this.options.theme=t),this}},{key:"close",value:function(){var t=this;return this.closed?this:this.shown?(d.fire(this,"onClose"),this.closing=!0,null===this.options.animation.close||!1===this.options.animation.close?this.promises.close=new u.default(function(t){t()}):"function"==typeof this.options.animation.close?this.promises.close=new u.default(this.options.animation.close.bind(this)):(c.addClass(this.barDom,this.options.animation.close),this.promises.close=new u.default(function(e){c.addListener(t.barDom,c.animationEndEvents,function(){t.options.force?c.remove(t.barDom):d.ghostFix(t),e()})})),this.promises.close.then(function(){d.closeFlow(t),d.handleModalClose(t)}),this.closed=!0,this):(d.removeFromQueue(this),this)}}],[{key:"closeAll",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Object.keys(d.Store).forEach(function(e){t?d.Store[e].options.queue===t&&d.Store[e].killable&&d.Store[e].close():d.Store[e].killable&&d.Store[e].close()}),this}},{key:"clearQueue",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"global";return d.Queues.hasOwnProperty(t)&&(d.Queues[t].queue=[]),this}},{key:"overrideDefaults",value:function(t){return d.Defaults=c.deepExtend({},d.Defaults,t),this}},{key:"setMaxVisible",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d.DefaultMaxVisible,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"global";return d.Queues.hasOwnProperty(e)||(d.Queues[e]={maxVisible:t,queue:[]}),d.Queues[e].maxVisible=t,this}},{key:"button",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new f.NotyButton(t,e,n,o)}},{key:"version",value:function(){return"3.2.0-beta"}},{key:"Push",value:function(t){return new h.Push(t)}},{key:"Queues",get:function(){return d.Queues}},{key:"PageHidden",get:function(){return d.PageHidden}}]),t}();e.default=p,"undefined"!=typeof window&&c.visibilityChangeFlow(),t.exports=e.default},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(t){if(l===setTimeout)return setTimeout(t,0);if((l===n||!l)&&setTimeout)return l=setTimeout,setTimeout(t,0);try{return l(t,0)}catch(e){try{return l.call(null,t,0)}catch(e){return l.call(this,t,0)}}}function r(t){if(d===clearTimeout)return clearTimeout(t);if((d===o||!d)&&clearTimeout)return d=clearTimeout,clearTimeout(t);try{return d(t)}catch(e){try{return d.call(null,t)}catch(e){return d.call(this,t)}}}function s(){m&&h&&(m=!1,h.length?p=h.concat(p):v=-1,p.length&&u())}function u(){if(!m){var t=i(s);m=!0;for(var e=p.length;e;){for(h=p,p=[];++v<e;)h&&h[v].run();v=-1,e=p.length}h=null,m=!1,r(t)}}function a(t,e){this.fun=t,this.array=e}function c(){}var l,d,f=t.exports={};!function(){try{l="function"==typeof setTimeout?setTimeout:n}catch(t){l=n}try{d="function"==typeof clearTimeout?clearTimeout:o}catch(t){d=o}}();var h,p=[],m=!1,v=-1;f.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];p.push(new a(t,e)),1!==p.length||m||i(u)},a.prototype.run=function(){this.fun.apply(null,this.array)},f.title="browser",f.browser=!0,f.env={},f.argv=[],f.version="",f.versions={},f.on=c,f.addListener=c,f.once=c,f.off=c,f.removeListener=c,f.removeAllListeners=c,f.emit=c,f.prependListener=c,f.prependOnceListener=c,f.listeners=function(t){return[]},f.binding=function(t){throw new Error("process.binding is not supported")},f.cwd=function(){return"/"},f.chdir=function(t){throw new Error("process.chdir is not supported")},f.umask=function(){return 0}},function(t,e){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this")}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e){}])});
//# sourceMappingURL=noty.min.js.map

;/**
 * bootbox.js v4.2.0
 *
 * http://bootboxjs.com/license.txt
 */
!function(a,b){"use strict";"function"==typeof define&&define.amd?define(["jquery"],b):"object"==typeof exports?module.exports=b(require("jquery")):a.bootbox=b(a.jQuery)}(this,function a(b,c){"use strict";function d(a){var b=q[o.locale];return b?b[a]:q.en[a]}function e(a,c,d){a.stopPropagation(),a.preventDefault();var e=b.isFunction(d)&&d(a)===!1;e||c.modal("hide")}function f(a){var b,c=0;for(b in a)c++;return c}function g(a,c){var d=0;b.each(a,function(a,b){c(a,b,d++)})}function h(a){var c,d;if("object"!=typeof a)throw new Error("Please supply an object of options");if(!a.message)throw new Error("Please specify a message");return a=b.extend({},o,a),a.buttons||(a.buttons={}),a.backdrop=a.backdrop?"static":!1,c=a.buttons,d=f(c),g(c,function(a,e,f){if(b.isFunction(e)&&(e=c[a]={callback:e}),"object"!==b.type(e))throw new Error("button with key "+a+" must be an object");e.label||(e.label=a),e.className||(e.className=2>=d&&f===d-1?"btn-primary":"btn-default")}),a}function i(a,b){var c=a.length,d={};if(1>c||c>2)throw new Error("Invalid argument length");return 2===c||"string"==typeof a[0]?(d[b[0]]=a[0],d[b[1]]=a[1]):d=a[0],d}function j(a,c,d){return b.extend(!0,{},a,i(c,d))}function k(a,b,c,d){var e={className:"bootbox-"+a,buttons:l.apply(null,b)};return m(j(e,d,c),b)}function l(){for(var a={},b=0,c=arguments.length;c>b;b++){var e=arguments[b],f=e.toLowerCase(),g=e.toUpperCase();a[f]={label:d(g)}}return a}function m(a,b){var d={};return g(b,function(a,b){d[b]=!0}),g(a.buttons,function(a){if(d[a]===c)throw new Error("button key "+a+" is not allowed (options are "+b.join("\n")+")")}),a}var n={dialog:"<div class='bootbox modal' tabindex='-1' role='dialog'><div class='modal-dialog'><div class='modal-content'><div class='modal-body'><div class='bootbox-body'></div></div></div></div></div>",header:"<div class='modal-header'><h4 class='modal-title'></h4></div>",footer:"<div class='modal-footer'></div>",closeButton:"<button type='button' class='bootbox-close-button close' data-dismiss='modal' aria-hidden='true'>&times;</button>",form:"<form class='bootbox-form'></form>",inputs:{text:"<input class='bootbox-input bootbox-input-text form-control' autocomplete=off type=text />",textarea:"<textarea class='bootbox-input bootbox-input-textarea form-control'></textarea>",email:"<input class='bootbox-input bootbox-input-email form-control' autocomplete='off' type='email' />",select:"<select class='bootbox-input bootbox-input-select form-control'></select>",checkbox:"<div class='checkbox'><label><input class='bootbox-input bootbox-input-checkbox' type='checkbox' /></label></div>",date:"<input class='bootbox-input bootbox-input-date form-control' autocomplete=off type='date' />",time:"<input class='bootbox-input bootbox-input-time form-control' autocomplete=off type='time' />",number:"<input class='bootbox-input bootbox-input-number form-control' autocomplete=off type='number' />",password:"<input class='bootbox-input bootbox-input-password form-control' autocomplete='off' type='password' />"}},o={locale:"en",backdrop:!0,animate:!0,className:null,closeButton:!0,show:!0,container:"body"},p={};p.alert=function(){var a;if(a=k("alert",["ok"],["message","callback"],arguments),a.callback&&!b.isFunction(a.callback))throw new Error("alert requires callback property to be a function when provided");return a.buttons.ok.callback=a.onEscape=function(){return b.isFunction(a.callback)?a.callback():!0},p.dialog(a)},p.confirm=function(){var a;if(a=k("confirm",["cancel","confirm"],["message","callback"],arguments),a.buttons.cancel.callback=a.onEscape=function(){return a.callback(!1)},a.buttons.confirm.callback=function(){return a.callback(!0)},!b.isFunction(a.callback))throw new Error("confirm requires a callback");return p.dialog(a)},p.prompt=function(){var a,d,e,f,h,i,k;f=b(n.form),d={className:"bootbox-prompt",buttons:l("cancel","confirm"),value:"",inputType:"text"},a=m(j(d,arguments,["title","callback"]),["cancel","confirm"]),i=a.show===c?!0:a.show;var o=["date","time","number"],q=document.createElement("input");if(q.setAttribute("type",a.inputType),o[a.inputType]&&(a.inputType=q.type),a.message=f,a.buttons.cancel.callback=a.onEscape=function(){return a.callback(null)},a.buttons.confirm.callback=function(){var c;switch(a.inputType){case"text":case"textarea":case"email":case"select":case"date":case"time":case"number":case"password":c=h.val();break;case"checkbox":var d=h.find("input:checked");c=[],g(d,function(a,d){c.push(b(d).val())})}return a.callback(c)},a.show=!1,!a.title)throw new Error("prompt requires a title");if(!b.isFunction(a.callback))throw new Error("prompt requires a callback");if(!n.inputs[a.inputType])throw new Error("invalid prompt type");switch(h=b(n.inputs[a.inputType]),a.inputType){case"text":case"textarea":case"email":case"date":case"time":case"number":case"password":h.val(a.value);break;case"select":var r={};if(k=a.inputOptions||[],!k.length)throw new Error("prompt with select requires options");g(k,function(a,d){var e=h;if(d.value===c||d.text===c)throw new Error("given options in wrong format");d.group&&(r[d.group]||(r[d.group]=b("<optgroup/>").attr("label",d.group)),e=r[d.group]),e.append("<option value='"+d.value+"'>"+d.text+"</option>")}),g(r,function(a,b){h.append(b)}),h.val(a.value);break;case"checkbox":var s=b.isArray(a.value)?a.value:[a.value];if(k=a.inputOptions||[],!k.length)throw new Error("prompt with checkbox requires options");if(!k[0].value||!k[0].text)throw new Error("given options in wrong format");h=b("<div/>"),g(k,function(c,d){var e=b(n.inputs[a.inputType]);e.find("input").attr("value",d.value),e.find("label").append(d.text),g(s,function(a,b){b===d.value&&e.find("input").prop("checked",!0)}),h.append(e)})}return a.placeholder&&h.attr("placeholder",a.placeholder),a.pattern&&h.attr("pattern",a.pattern),f.append(h),f.on("submit",function(a){a.preventDefault(),e.find(".btn-primary").click()}),e=p.dialog(a),e.off("shown.bs.modal"),e.on("shown.bs.modal",function(){h.focus()}),i===!0&&e.modal("show"),e},p.dialog=function(a){a=h(a);var c=b(n.dialog),d=c.find(".modal-body"),f=a.buttons,i="",j={onEscape:a.onEscape};if(g(f,function(a,b){i+="<button data-bb-handler='"+a+"' type='button' class='btn "+b.className+"'>"+b.label+"</button>",j[a]=b.callback}),d.find(".bootbox-body").html(a.message),a.animate===!0&&c.addClass("fade"),a.className&&c.addClass(a.className),a.title&&d.before(n.header),a.closeButton){var k=b(n.closeButton);a.title?c.find(".modal-header").prepend(k):k.css("margin-top","-10px").prependTo(d)}return a.title&&c.find(".modal-title").html(a.title),i.length&&(d.after(n.footer),c.find(".modal-footer").html(i)),c.on("hidden.bs.modal",function(a){a.target===this&&c.remove()}),c.on("shown.bs.modal",function(){c.find(".btn-primary:first").focus()}),c.on("escape.close.bb",function(a){j.onEscape&&e(a,c,j.onEscape)}),c.on("click",".modal-footer button",function(a){var d=b(this).data("bb-handler");e(a,c,j[d])}),c.on("click",".bootbox-close-button",function(a){e(a,c,j.onEscape)}),c.on("keyup",function(a){27===a.which&&c.trigger("escape.close.bb")}),b(a.container).append(c),c.modal({backdrop:a.backdrop,keyboard:!1,show:!1}),a.show&&c.modal("show"),c},p.setDefaults=function(){var a={};2===arguments.length?a[arguments[0]]=arguments[1]:a=arguments[0],b.extend(o,a)},p.hideAll=function(){b(".bootbox").modal("hide")};var q={br:{OK:"OK",CANCEL:"Cancelar",CONFIRM:"Sim"},da:{OK:"OK",CANCEL:"Annuller",CONFIRM:"Accepter"},de:{OK:"OK",CANCEL:"Abbrechen",CONFIRM:"Akzeptieren"},en:{OK:"OK",CANCEL:"Cancel",CONFIRM:"OK"},es:{OK:"OK",CANCEL:"Cancelar",CONFIRM:"Aceptar"},fi:{OK:"OK",CANCEL:"Peruuta",CONFIRM:"OK"},fr:{OK:"OK",CANCEL:"Annuler",CONFIRM:"D'accord"},he:{OK:"אישור",CANCEL:"ביטול",CONFIRM:"אישור"},it:{OK:"OK",CANCEL:"Annulla",CONFIRM:"Conferma"},lt:{OK:"Gerai",CANCEL:"Atšaukti",CONFIRM:"Patvirtinti"},lv:{OK:"Labi",CANCEL:"Atcelt",CONFIRM:"Apstiprināt"},nl:{OK:"OK",CANCEL:"Annuleren",CONFIRM:"Accepteren"},no:{OK:"OK",CANCEL:"Avbryt",CONFIRM:"OK"},pl:{OK:"OK",CANCEL:"Anuluj",CONFIRM:"Potwierdź"},ru:{OK:"OK",CANCEL:"Отмена",CONFIRM:"Применить"},sv:{OK:"OK",CANCEL:"Avbryt",CONFIRM:"OK"},tr:{OK:"Tamam",CANCEL:"İptal",CONFIRM:"Onayla"},zh_CN:{OK:"OK",CANCEL:"取消",CONFIRM:"确认"},zh_TW:{OK:"OK",CANCEL:"取消",CONFIRM:"確認"}};return p.init=function(c){return a(c||b)},p});

;/*!
 * Bootstrap v3.1.1 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one(a.support.transition.end,function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b()})}(jQuery),+function(a){"use strict";var b='[data-dismiss="alert"]',c=function(c){a(c).on("click",b,this.close)};c.prototype.close=function(b){function c(){f.trigger("closed.bs.alert").remove()}var d=a(this),e=d.attr("data-target");e||(e=d.attr("href"),e=e&&e.replace(/.*(?=#[^\s]*$)/,""));var f=a(e);b&&b.preventDefault(),f.length||(f=d.hasClass("alert")?d:d.parent()),f.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one(a.support.transition.end,c).emulateTransitionEnd(150):c())};var d=a.fn.alert;a.fn.alert=function(b){return this.each(function(){var d=a(this),e=d.data("bs.alert");e||d.data("bs.alert",e=new c(this)),"string"==typeof b&&e[b].call(d)})},a.fn.alert.Constructor=c,a.fn.alert.noConflict=function(){return a.fn.alert=d,this},a(document).on("click.bs.alert.data-api",b,c.prototype.close)}(jQuery),+function(a){"use strict";var b=function(c,d){this.$element=a(c),this.options=a.extend({},b.DEFAULTS,d),this.isLoading=!1};b.DEFAULTS={loadingText:"loading..."},b.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",f.resetText||d.data("resetText",d[e]()),d[e](f[b]||this.options[b]),setTimeout(a.proxy(function(){"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},b.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")&&(c.prop("checked")&&this.$element.hasClass("active")?a=!1:b.find(".active").removeClass("active")),a&&c.prop("checked",!this.$element.hasClass("active")).trigger("change")}a&&this.$element.toggleClass("active")};var c=a.fn.button;a.fn.button=function(c){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof c&&c;e||d.data("bs.button",e=new b(this,f)),"toggle"==c?e.toggle():c&&e.setState(c)})},a.fn.button.Constructor=b,a.fn.button.noConflict=function(){return a.fn.button=c,this},a(document).on("click.bs.button.data-api","[data-toggle^=button]",function(b){var c=a(b.target);c.hasClass("btn")||(c=c.closest(".btn")),c.button("toggle"),b.preventDefault()})}(jQuery),+function(a){"use strict";var b=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=this.sliding=this.interval=this.$active=this.$items=null,"hover"==this.options.pause&&this.$element.on("mouseenter",a.proxy(this.pause,this)).on("mouseleave",a.proxy(this.cycle,this))};b.DEFAULTS={interval:5e3,pause:"hover",wrap:!0},b.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},b.prototype.getActiveIndex=function(){return this.$active=this.$element.find(".item.active"),this.$items=this.$active.parent().children(),this.$items.index(this.$active)},b.prototype.to=function(b){var c=this,d=this.getActiveIndex();return b>this.$items.length-1||0>b?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){c.to(b)}):d==b?this.pause().cycle():this.slide(b>d?"next":"prev",a(this.$items[b]))},b.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},b.prototype.next=function(){return this.sliding?void 0:this.slide("next")},b.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},b.prototype.slide=function(b,c){var d=this.$element.find(".item.active"),e=c||d[b](),f=this.interval,g="next"==b?"left":"right",h="next"==b?"first":"last",i=this;if(!e.length){if(!this.options.wrap)return;e=this.$element.find(".item")[h]()}if(e.hasClass("active"))return this.sliding=!1;var j=a.Event("slide.bs.carousel",{relatedTarget:e[0],direction:g});return this.$element.trigger(j),j.isDefaultPrevented()?void 0:(this.sliding=!0,f&&this.pause(),this.$indicators.length&&(this.$indicators.find(".active").removeClass("active"),this.$element.one("slid.bs.carousel",function(){var b=a(i.$indicators.children()[i.getActiveIndex()]);b&&b.addClass("active")})),a.support.transition&&this.$element.hasClass("slide")?(e.addClass(b),e[0].offsetWidth,d.addClass(g),e.addClass(g),d.one(a.support.transition.end,function(){e.removeClass([b,g].join(" ")).addClass("active"),d.removeClass(["active",g].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger("slid.bs.carousel")},0)}).emulateTransitionEnd(1e3*d.css("transition-duration").slice(0,-1))):(d.removeClass("active"),e.addClass("active"),this.sliding=!1,this.$element.trigger("slid.bs.carousel")),f&&this.cycle(),this)};var c=a.fn.carousel;a.fn.carousel=function(c){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},b.DEFAULTS,d.data(),"object"==typeof c&&c),g="string"==typeof c?c:f.slide;e||d.data("bs.carousel",e=new b(this,f)),"number"==typeof c?e.to(c):g?e[g]():f.interval&&e.pause().cycle()})},a.fn.carousel.Constructor=b,a.fn.carousel.noConflict=function(){return a.fn.carousel=c,this},a(document).on("click.bs.carousel.data-api","[data-slide], [data-slide-to]",function(b){var c,d=a(this),e=a(d.attr("data-target")||(c=d.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"")),f=a.extend({},e.data(),d.data()),g=d.attr("data-slide-to");g&&(f.interval=!1),e.carousel(f),(g=d.attr("data-slide-to"))&&e.data("bs.carousel").to(g),b.preventDefault()}),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var b=a(this);b.carousel(b.data())})})}(jQuery),+function(a){"use strict";var b=function(c,d){this.$element=a(c),this.options=a.extend({},b.DEFAULTS,d),this.transitioning=null,this.options.parent&&(this.$parent=a(this.options.parent)),this.options.toggle&&this.toggle()};b.DEFAULTS={toggle:!0},b.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},b.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b=a.Event("show.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.$parent&&this.$parent.find("> .panel > .in");if(c&&c.length){var d=c.data("bs.collapse");if(d&&d.transitioning)return;c.collapse("hide"),d||c.data("bs.collapse",null)}var e=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[e](0),this.transitioning=1;var f=function(){this.$element.removeClass("collapsing").addClass("collapse in")[e]("auto"),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return f.call(this);var g=a.camelCase(["scroll",e].join("-"));this.$element.one(a.support.transition.end,a.proxy(f,this)).emulateTransitionEnd(350)[e](this.$element[0][g])}}},b.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse").removeClass("in"),this.transitioning=1;var d=function(){this.transitioning=0,this.$element.trigger("hidden.bs.collapse").removeClass("collapsing").addClass("collapse")};return a.support.transition?void this.$element[c](0).one(a.support.transition.end,a.proxy(d,this)).emulateTransitionEnd(350):d.call(this)}}},b.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()};var c=a.fn.collapse;a.fn.collapse=function(c){return this.each(function(){var d=a(this),e=d.data("bs.collapse"),f=a.extend({},b.DEFAULTS,d.data(),"object"==typeof c&&c);!e&&f.toggle&&"show"==c&&(c=!c),e||d.data("bs.collapse",e=new b(this,f)),"string"==typeof c&&e[c]()})},a.fn.collapse.Constructor=b,a.fn.collapse.noConflict=function(){return a.fn.collapse=c,this},a(document).on("click.bs.collapse.data-api","[data-toggle=collapse]",function(b){var c,d=a(this),e=d.attr("data-target")||b.preventDefault()||(c=d.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,""),f=a(e),g=f.data("bs.collapse"),h=g?"toggle":d.data(),i=d.attr("data-parent"),j=i&&a(i);g&&g.transitioning||(j&&j.find('[data-toggle=collapse][data-parent="'+i+'"]').not(d).addClass("collapsed"),d[f.hasClass("in")?"addClass":"removeClass"]("collapsed")),f.collapse(h)})}(jQuery),+function(a){"use strict";function b(b){a(d).remove(),a(e).each(function(){var d=c(a(this)),e={relatedTarget:this};d.hasClass("open")&&(d.trigger(b=a.Event("hide.bs.dropdown",e)),b.isDefaultPrevented()||d.removeClass("open").trigger("hidden.bs.dropdown",e))})}function c(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}var d=".dropdown-backdrop",e="[data-toggle=dropdown]",f=function(b){a(b).on("click.bs.dropdown",this.toggle)};f.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=c(e),g=f.hasClass("open");if(b(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click",b);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;f.toggleClass("open").trigger("shown.bs.dropdown",h),e.focus()}return!1}},f.prototype.keydown=function(b){if(/(38|40|27)/.test(b.keyCode)){var d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(".disabled, :disabled")){var f=c(d),g=f.hasClass("open");if(!g||g&&27==b.keyCode)return 27==b.which&&f.find(e).focus(),d.click();var h=" li:not(.divider):visible a",i=f.find("[role=menu]"+h+", [role=listbox]"+h);if(i.length){var j=i.index(i.filter(":focus"));38==b.keyCode&&j>0&&j--,40==b.keyCode&&j<i.length-1&&j++,~j||(j=0),i.eq(j).focus()}}}};var g=a.fn.dropdown;a.fn.dropdown=function(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new f(this)),"string"==typeof b&&d[b].call(c)})},a.fn.dropdown.Constructor=f,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=g,this},a(document).on("click.bs.dropdown.data-api",b).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",e,f.prototype.toggle).on("keydown.bs.dropdown.data-api",e+", [role=menu], [role=listbox]",f.prototype.keydown)}(jQuery),+function(a){"use strict";var b=function(b,c){this.options=c,this.$element=a(b),this.$backdrop=this.isShown=null,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};b.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},b.prototype.toggle=function(a){return this[this.isShown?"hide":"show"](a)},b.prototype.show=function(b){var c=this,d=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(d),this.isShown||d.isDefaultPrevented()||(this.isShown=!0,this.escape(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.backdrop(function(){var d=a.support.transition&&c.$element.hasClass("fade");c.$element.parent().length||c.$element.appendTo(document.body),c.$element.show().scrollTop(0),d&&c.$element[0].offsetWidth,c.$element.addClass("in").attr("aria-hidden",!1),c.enforceFocus();var e=a.Event("shown.bs.modal",{relatedTarget:b});d?c.$element.find(".modal-dialog").one(a.support.transition.end,function(){c.$element.focus().trigger(e)}).emulateTransitionEnd(300):c.$element.focus().trigger(e)}))},b.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one(a.support.transition.end,a.proxy(this.hideModal,this)).emulateTransitionEnd(300):this.hideModal())},b.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.focus()},this))},b.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keyup.dismiss.bs.modal")},b.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.removeBackdrop(),a.$element.trigger("hidden.bs.modal")})},b.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},b.prototype.backdrop=function(b){var c=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var d=a.support.transition&&c;if(this.$backdrop=a('<div class="modal-backdrop '+c+'" />').appendTo(document.body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus.call(this.$element[0]):this.hide.call(this))},this)),d&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;d?this.$backdrop.one(a.support.transition.end,b).emulateTransitionEnd(150):b()}else!this.isShown&&this.$backdrop?(this.$backdrop.removeClass("in"),a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one(a.support.transition.end,b).emulateTransitionEnd(150):b()):b&&b()};var c=a.fn.modal;a.fn.modal=function(c,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},b.DEFAULTS,e.data(),"object"==typeof c&&c);f||e.data("bs.modal",f=new b(this,g)),"string"==typeof c?f[c](d):g.show&&f.show(d)})},a.fn.modal.Constructor=b,a.fn.modal.noConflict=function(){return a.fn.modal=c,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(b){var c=a(this),d=c.attr("href"),e=a(c.attr("data-target")||d&&d.replace(/.*(?=#[^\s]+$)/,"")),f=e.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(d)&&d},e.data(),c.data());c.is("a")&&b.preventDefault(),e.modal(f,this).one("hide",function(){c.is(":visible")&&c.focus()})}),a(document).on("show.bs.modal",".modal",function(){a(document.body).addClass("modal-open")}).on("hidden.bs.modal",".modal",function(){a(document.body).removeClass("modal-open")})}(jQuery),+function(a){"use strict";var b=function(a,b){this.type=this.options=this.enabled=this.timeout=this.hoverState=this.$element=null,this.init("tooltip",a,b)};b.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1},b.prototype.init=function(b,c,d){this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d);for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},b.prototype.getDefaults=function(){return b.DEFAULTS},b.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},b.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},b.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs."+this.type);return clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show()},b.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs."+this.type);return clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},b.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){if(this.$element.trigger(b),b.isDefaultPrevented())return;var c=this,d=this.tip();this.setContent(),this.options.animation&&d.addClass("fade");var e="function"==typeof this.options.placement?this.options.placement.call(this,d[0],this.$element[0]):this.options.placement,f=/\s?auto?\s?/i,g=f.test(e);g&&(e=e.replace(f,"")||"top"),d.detach().css({top:0,left:0,display:"block"}).addClass(e),this.options.container?d.appendTo(this.options.container):d.insertAfter(this.$element);var h=this.getPosition(),i=d[0].offsetWidth,j=d[0].offsetHeight;if(g){var k=this.$element.parent(),l=e,m=document.documentElement.scrollTop||document.body.scrollTop,n="body"==this.options.container?window.innerWidth:k.outerWidth(),o="body"==this.options.container?window.innerHeight:k.outerHeight(),p="body"==this.options.container?0:k.offset().left;e="bottom"==e&&h.top+h.height+j-m>o?"top":"top"==e&&h.top-m-j<0?"bottom":"right"==e&&h.right+i>n?"left":"left"==e&&h.left-i<p?"right":e,d.removeClass(l).addClass(e)}var q=this.getCalculatedOffset(e,h,i,j);this.applyPlacement(q,e),this.hoverState=null;var r=function(){c.$element.trigger("shown.bs."+c.type)};a.support.transition&&this.$tip.hasClass("fade")?d.one(a.support.transition.end,r).emulateTransitionEnd(150):r()}},b.prototype.applyPlacement=function(b,c){var d,e=this.tip(),f=e[0].offsetWidth,g=e[0].offsetHeight,h=parseInt(e.css("margin-top"),10),i=parseInt(e.css("margin-left"),10);isNaN(h)&&(h=0),isNaN(i)&&(i=0),b.top=b.top+h,b.left=b.left+i,a.offset.setOffset(e[0],a.extend({using:function(a){e.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),e.addClass("in");var j=e[0].offsetWidth,k=e[0].offsetHeight;if("top"==c&&k!=g&&(d=!0,b.top=b.top+g-k),/bottom|top/.test(c)){var l=0;b.left<0&&(l=-2*b.left,b.left=0,e.offset(b),j=e[0].offsetWidth,k=e[0].offsetHeight),this.replaceArrow(l-f+j,j,"left")}else this.replaceArrow(k-g,k,"top");d&&e.offset(b)},b.prototype.replaceArrow=function(a,b,c){this.arrow().css(c,a?50*(1-a/b)+"%":"")},b.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},b.prototype.hide=function(){function b(){"in"!=c.hoverState&&d.detach(),c.$element.trigger("hidden.bs."+c.type)}var c=this,d=this.tip(),e=a.Event("hide.bs."+this.type);return this.$element.trigger(e),e.isDefaultPrevented()?void 0:(d.removeClass("in"),a.support.transition&&this.$tip.hasClass("fade")?d.one(a.support.transition.end,b).emulateTransitionEnd(150):b(),this.hoverState=null,this)},b.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},b.prototype.hasContent=function(){return this.getTitle()},b.prototype.getPosition=function(){var b=this.$element[0];return a.extend({},"function"==typeof b.getBoundingClientRect?b.getBoundingClientRect():{width:b.offsetWidth,height:b.offsetHeight},this.$element.offset())},b.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},b.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},b.prototype.tip=function(){return this.$tip=this.$tip||a(this.options.template)},b.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},b.prototype.validate=function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},b.prototype.enable=function(){this.enabled=!0},b.prototype.disable=function(){this.enabled=!1},b.prototype.toggleEnabled=function(){this.enabled=!this.enabled},b.prototype.toggle=function(b){var c=b?a(b.currentTarget)[this.type](this.getDelegateOptions()).data("bs."+this.type):this;c.tip().hasClass("in")?c.leave(c):c.enter(c)},b.prototype.destroy=function(){clearTimeout(this.timeout),this.hide().$element.off("."+this.type).removeData("bs."+this.type)};var c=a.fn.tooltip;a.fn.tooltip=function(c){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof c&&c;(e||"destroy"!=c)&&(e||d.data("bs.tooltip",e=new b(this,f)),"string"==typeof c&&e[c]())})},a.fn.tooltip.Constructor=b,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=c,this}}(jQuery),+function(a){"use strict";var b=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");b.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),b.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),b.prototype.constructor=b,b.prototype.getDefaults=function(){return b.DEFAULTS},b.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content")[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},b.prototype.hasContent=function(){return this.getTitle()||this.getContent()},b.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},b.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")},b.prototype.tip=function(){return this.$tip||(this.$tip=a(this.options.template)),this.$tip};var c=a.fn.popover;a.fn.popover=function(c){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof c&&c;(e||"destroy"!=c)&&(e||d.data("bs.popover",e=new b(this,f)),"string"==typeof c&&e[c]())})},a.fn.popover.Constructor=b,a.fn.popover.noConflict=function(){return a.fn.popover=c,this}}(jQuery),+function(a){"use strict";function b(c,d){var e,f=a.proxy(this.process,this);this.$element=a(a(c).is("body")?window:c),this.$body=a("body"),this.$scrollElement=this.$element.on("scroll.bs.scroll-spy.data-api",f),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||(e=a(c).attr("href"))&&e.replace(/.*(?=#[^\s]+$)/,"")||"")+" .nav li > a",this.offsets=a([]),this.targets=a([]),this.activeTarget=null,this.refresh(),this.process()}b.DEFAULTS={offset:10},b.prototype.refresh=function(){var b=this.$element[0]==window?"offset":"position";this.offsets=a([]),this.targets=a([]);{var c=this;this.$body.find(this.selector).map(function(){var d=a(this),e=d.data("target")||d.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[b]().top+(!a.isWindow(c.$scrollElement.get(0))&&c.$scrollElement.scrollTop()),e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){c.offsets.push(this[0]),c.targets.push(this[1])})}},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.$scrollElement[0].scrollHeight||this.$body[0].scrollHeight,d=c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(b>=d)return g!=(a=f.last()[0])&&this.activate(a);if(g&&b<=e[0])return g!=(a=f[0])&&this.activate(a);for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(!e[a+1]||b<=e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,a(this.selector).parentsUntil(this.options.target,".active").removeClass("active");var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")};var c=a.fn.scrollspy;a.fn.scrollspy=function(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})},a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=c,this},a(window).on("load",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);b.scrollspy(b.data())})})}(jQuery),+function(a){"use strict";var b=function(b){this.element=a(b)};b.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a")[0],f=a.Event("show.bs.tab",{relatedTarget:e});if(b.trigger(f),!f.isDefaultPrevented()){var g=a(d);this.activate(b.parent("li"),c),this.activate(g,g.parent(),function(){b.trigger({type:"shown.bs.tab",relatedTarget:e})})}}},b.prototype.activate=function(b,c,d){function e(){f.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),b.addClass("active"),g?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu")&&b.closest("li.dropdown").addClass("active"),d&&d()}var f=c.find("> .active"),g=d&&a.support.transition&&f.hasClass("fade");g?f.one(a.support.transition.end,e).emulateTransitionEnd(150):e(),f.removeClass("in")};var c=a.fn.tab;a.fn.tab=function(c){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new b(this)),"string"==typeof c&&e[c]()})},a.fn.tab.Constructor=b,a.fn.tab.noConflict=function(){return a.fn.tab=c,this},a(document).on("click.bs.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(b){b.preventDefault(),a(this).tab("show")})}(jQuery),+function(a){"use strict";var b=function(c,d){this.options=a.extend({},b.DEFAULTS,d),this.$window=a(window).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(c),this.affixed=this.unpin=this.pinnedOffset=null,this.checkPosition()};b.RESET="affix affix-top affix-bottom",b.DEFAULTS={offset:0},b.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(b.RESET).addClass("affix");var a=this.$window.scrollTop(),c=this.$element.offset();return this.pinnedOffset=c.top-a},b.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},b.prototype.checkPosition=function(){if(this.$element.is(":visible")){var c=a(document).height(),d=this.$window.scrollTop(),e=this.$element.offset(),f=this.options.offset,g=f.top,h=f.bottom;"top"==this.affixed&&(e.top+=d),"object"!=typeof f&&(h=g=f),"function"==typeof g&&(g=f.top(this.$element)),"function"==typeof h&&(h=f.bottom(this.$element));var i=null!=this.unpin&&d+this.unpin<=e.top?!1:null!=h&&e.top+this.$element.height()>=c-h?"bottom":null!=g&&g>=d?"top":!1;if(this.affixed!==i){this.unpin&&this.$element.css("top","");var j="affix"+(i?"-"+i:""),k=a.Event(j+".bs.affix");this.$element.trigger(k),k.isDefaultPrevented()||(this.affixed=i,this.unpin="bottom"==i?this.getPinnedOffset():null,this.$element.removeClass(b.RESET).addClass(j).trigger(a.Event(j.replace("affix","affixed"))),"bottom"==i&&this.$element.offset({top:c-h-this.$element.height()}))}}};var c=a.fn.affix;a.fn.affix=function(c){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof c&&c;e||d.data("bs.affix",e=new b(this,f)),"string"==typeof c&&e[c]()})},a.fn.affix.Constructor=b,a.fn.affix.noConflict=function(){return a.fn.affix=c,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var b=a(this),c=b.data();c.offset=c.offset||{},c.offsetBottom&&(c.offset.bottom=c.offsetBottom),c.offsetTop&&(c.offset.top=c.offsetTop),b.affix(c)})})}(jQuery);

;/*!
 * Bootstrap Context Menu
 * Version: 0.2.0
 * Author: @sydcanem
 * https://github.com/sydcanem/bootstrap-contextmenu
 *
 * Inspired by Twitter Bootstrap's dropdown plugin.
 * Twitter Bootstrap (http://twitter.github.com/bootstrap).
 *
 * Licensed under MIT
 * ========================================================= */

;(function($) {

	'use strict';

	/* CONTEXTMENU CLASS DEFINITION
	 * ============================ */
	var toggle = '[data-toggle="context"]';

	var ContextMenu = function (element, options) {
		this.$element = $(element);

		this.before = options.before || this.before;
		this.onItem = options.onItem || this.onItem;
		this.scopes = options.scopes || null;

		if (options.target) {
			this.$element.data('target', options.target);
		}

		this.listen();
	};

	ContextMenu.prototype = {

		constructor: ContextMenu
		,show: function(e) {

			var $menu
				, evt
				, tp
				, items
				, relatedTarget = { relatedTarget: this };

			if (this.isDisabled()) return;

			this.closemenu();

			if (!this.before.call(this,e,$(e.currentTarget))) return;

			$menu = this.getMenu();
			$menu.trigger(evt = $.Event('show.bs.context', relatedTarget));

			tp = this.getPosition(e, $menu);
			items = 'li:not(.divider)';
			$menu.attr('style', '')
				.css(tp)
				.addClass('open')
				.on('click.context.data-api', items, $.proxy(this.onItem, this, $(e.currentTarget)))
				.trigger('shown.bs.context', relatedTarget);

			// Delegating the `closemenu` only on the currently opened menu.
			// This prevents other opened menus from closing.
			$('html')
				.on('click.context.data-api', $menu.selector, $.proxy(this.closemenu, this));

			return false;
		}

		,closemenu: function(e) {
			var $menu
				, evt
				, items
				, relatedTarget;

			$menu = this.getMenu();

			if(!$menu.hasClass('open')) return;

			relatedTarget = { relatedTarget: this };
			$menu.trigger(evt = $.Event('hide.bs.context', relatedTarget));

			items = 'li:not(.divider)';
			$menu.removeClass('open')
				.off('click.context.data-api', items)
				.trigger('hidden.bs.context', relatedTarget);

			$('html')
				.off('click.context.data-api', $menu.selector);
			// Don't propagate click event so other currently
			// opened menus won't close.
			return false;
		}

		,before: function(e) {
			return true;
		}

		,onItem: function(e) {
			return true;
		}

		,listen: function () {
			this.$element.on('contextmenu.context.data-api', this.scopes, $.proxy(this.show, this));
			$('html').on('click.context.data-api', $.proxy(this.closemenu, this));
		}

		,destroy: function() {
			this.$element.off('.context.data-api').removeData('context');
			$('html').off('.context.data-api');
		}

		,isDisabled: function() {
			return this.$element.hasClass('.disabled') || 
					this.$element.attr('disabled');
		}

		,getMenu: function () {
			var selector = this.$element.data('target')
				, $menu;

			if (!selector) {
				selector = this.$element.attr('href');
				selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); //strip for ie7
			}

			$menu = $(selector);

			return $menu && $menu.length ? $menu : this.$element.find(selector);
		}

		,getPosition: function(e, $menu) {
			var mouseX = e.clientX
				, mouseY = e.clientY
				, boundsX = $(window).width()
				, boundsY = $(window).height()
				, menuWidth = $menu.find('.dropdown-menu').outerWidth()
				, menuHeight = $menu.find('.dropdown-menu').outerHeight()
				, tp = {"position":"absolute","z-index":9999}
				, Y, X, parentOffset;

			if (mouseY + menuHeight > boundsY) {
				Y = {"top": mouseY - menuHeight + $(window).scrollTop()};
			} else {
				Y = {"top": mouseY + $(window).scrollTop()};
			}

			if ((mouseX + menuWidth > boundsX) && ((mouseX - menuWidth) > 0)) {
				X = {"left": mouseX - menuWidth + $(window).scrollLeft()};
			} else {
				X = {"left": mouseX + $(window).scrollLeft()};
			}

			// If context-menu's parent is positioned using absolute or relative positioning,
			// the calculated mouse position will be incorrect.
			// Adjust the position of the menu by its offset parent position.
			parentOffset = $menu.offsetParent().offset();
			X.left = X.left - parentOffset.left;
			Y.top = Y.top - parentOffset.top;
 
			return $.extend(tp, Y, X);
		}

	};

	/* CONTEXT MENU PLUGIN DEFINITION
	 * ========================== */

	$.fn.contextmenu = function (option,e) {
		return this.each(function () {
			var $this = $(this)
				, data = $this.data('context')
				, options = (typeof option == 'object') && option;

			if (!data) $this.data('context', (data = new ContextMenu($this, options)));
			if (typeof option == 'string') data[option].call(data, e);
		});
	};

	$.fn.contextmenu.Constructor = ContextMenu;

	/* APPLY TO STANDARD CONTEXT MENU ELEMENTS
	 * =================================== */

	$(document)
		.on('contextmenu.context.data-api', toggle, function(e) {
			$(this).contextmenu('show', e);
			e.preventDefault();
		});

}(jQuery));


;/*
The MIT License (MIT)

Copyright (c) 2010-2020 Robert Kieffer and other contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).uuidv4=e()}(this,(function(){"use strict";var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto),e=new Uint8Array(16);function n(){if(!t)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}for(var o=[],r=0;r<256;++r)o.push((r+256).toString(16).substr(1));return function(t,e,r){"string"==typeof t&&(e="binary"===t?new Uint8Array(16):null,t=null);var u=(t=t||{}).random||(t.rng||n)();if(u[6]=15&u[6]|64,u[8]=63&u[8]|128,e){for(var i=r||0,d=0;d<16;++d)e[i+d]=u[d];return e}return function(t,e){var n=e||0,r=o;return(r[t[n+0]]+r[t[n+1]]+r[t[n+2]]+r[t[n+3]]+"-"+r[t[n+4]]+r[t[n+5]]+"-"+r[t[n+6]]+r[t[n+7]]+"-"+r[t[n+8]]+r[t[n+9]]+"-"+r[t[n+10]]+r[t[n+11]]+r[t[n+12]]+r[t[n+13]]+r[t[n+14]]+r[t[n+15]]).toLowerCase()}(u)}}));

;!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Dropbox={})}(this,(function(e){"use strict";function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){for(var r=0;t.length>r;r++){var s=t[r];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}function s(e,t,s){return t&&r(e.prototype,t),s&&r(e,s),e}function i(e){return(i=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function n(e,t){return(n=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function u(e,t,r){return(u=a()?Reflect.construct:function(e,t,r){var s=[null];s.push.apply(s,t);var i=new(Function.bind.apply(e,s));return r&&n(i,r.prototype),i}).apply(null,arguments)}function o(e){var t="function"==typeof Map?new Map:void 0;return(o=function(e){if(null===e||-1===Function.toString.call(e).indexOf("[native code]"))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return u(e,arguments,i(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),n(r,e)})(e)}function c(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}var p="app",l="user",m="team",f="dropboxapi.com",h="dropbox.com",d={api:"api",notify:"bolt",content:"api-content"},_={};function g(e){var t="000".concat(e.charCodeAt(0).toString(16)).slice(-4);return"\\u".concat(t)}_.accountSetProfilePhoto=function(e){return this.request("account/set_profile_photo",e,"user","api","rpc","account_info.write")},_.authTokenFromOauth1=function(e){return this.request("auth/token/from_oauth1",e,"app","api","rpc",null)},_.authTokenRevoke=function(){return this.request("auth/token/revoke",null,"user","api","rpc",null)},_.checkApp=function(e){return this.request("check/app",e,"app","api","rpc",null)},_.checkUser=function(e){return this.request("check/user",e,"user","api","rpc","account_info.read")},_.contactsDeleteManualContacts=function(){return this.request("contacts/delete_manual_contacts",null,"user","api","rpc","contacts.write")},_.contactsDeleteManualContactsBatch=function(e){return this.request("contacts/delete_manual_contacts_batch",e,"user","api","rpc","contacts.write")},_.filePropertiesPropertiesAdd=function(e){return this.request("file_properties/properties/add",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesOverwrite=function(e){return this.request("file_properties/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesRemove=function(e){return this.request("file_properties/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filePropertiesPropertiesSearch=function(e){return this.request("file_properties/properties/search",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesSearchContinue=function(e){return this.request("file_properties/properties/search/continue",e,"user","api","rpc","files.metadata.read")},_.filePropertiesPropertiesUpdate=function(e){return this.request("file_properties/properties/update",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesAddForTeam=function(e){return this.request("file_properties/templates/add_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesAddForUser=function(e){return this.request("file_properties/templates/add_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesGetForTeam=function(e){return this.request("file_properties/templates/get_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesGetForUser=function(e){return this.request("file_properties/templates/get_for_user",e,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesListForTeam=function(){return this.request("file_properties/templates/list_for_team",null,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesListForUser=function(){return this.request("file_properties/templates/list_for_user",null,"user","api","rpc","files.metadata.read")},_.filePropertiesTemplatesRemoveForTeam=function(e){return this.request("file_properties/templates/remove_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesRemoveForUser=function(e){return this.request("file_properties/templates/remove_for_user",e,"user","api","rpc","files.metadata.write")},_.filePropertiesTemplatesUpdateForTeam=function(e){return this.request("file_properties/templates/update_for_team",e,"team","api","rpc","files.team_metadata.write")},_.filePropertiesTemplatesUpdateForUser=function(e){return this.request("file_properties/templates/update_for_user",e,"user","api","rpc","files.metadata.write")},_.fileRequestsCount=function(){return this.request("file_requests/count",null,"user","api","rpc","file_requests.read")},_.fileRequestsCreate=function(e){return this.request("file_requests/create",e,"user","api","rpc","file_requests.write")},_.fileRequestsDelete=function(e){return this.request("file_requests/delete",e,"user","api","rpc","file_requests.write")},_.fileRequestsDeleteAllClosed=function(){return this.request("file_requests/delete_all_closed",null,"user","api","rpc","file_requests.write")},_.fileRequestsGet=function(e){return this.request("file_requests/get",e,"user","api","rpc","file_requests.read")},_.fileRequestsListV2=function(e){return this.request("file_requests/list_v2",e,"user","api","rpc","file_requests.read")},_.fileRequestsList=function(){return this.request("file_requests/list",null,"user","api","rpc","file_requests.read")},_.fileRequestsListContinue=function(e){return this.request("file_requests/list/continue",e,"user","api","rpc","file_requests.read")},_.fileRequestsUpdate=function(e){return this.request("file_requests/update",e,"user","api","rpc","file_requests.write")},_.filesAlphaGetMetadata=function(e){return this.request("files/alpha/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesAlphaUpload=function(e){return this.request("files/alpha/upload",e,"user","content","upload","files.content.write")},_.filesCopyV2=function(e){return this.request("files/copy_v2",e,"user","api","rpc","files.content.write")},_.filesCopy=function(e){return this.request("files/copy",e,"user","api","rpc","files.content.write")},_.filesCopyBatchV2=function(e){return this.request("files/copy_batch_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatch=function(e){return this.request("files/copy_batch",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheckV2=function(e){return this.request("files/copy_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesCopyBatchCheck=function(e){return this.request("files/copy_batch/check",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceGet=function(e){return this.request("files/copy_reference/get",e,"user","api","rpc","files.content.write")},_.filesCopyReferenceSave=function(e){return this.request("files/copy_reference/save",e,"user","api","rpc","files.content.write")},_.filesCreateFolderV2=function(e){return this.request("files/create_folder_v2",e,"user","api","rpc","files.content.write")},_.filesCreateFolder=function(e){return this.request("files/create_folder",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatch=function(e){return this.request("files/create_folder_batch",e,"user","api","rpc","files.content.write")},_.filesCreateFolderBatchCheck=function(e){return this.request("files/create_folder_batch/check",e,"user","api","rpc","files.content.write")},_.filesDeleteV2=function(e){return this.request("files/delete_v2",e,"user","api","rpc","files.content.write")},_.filesDelete=function(e){return this.request("files/delete",e,"user","api","rpc","files.content.write")},_.filesDeleteBatch=function(e){return this.request("files/delete_batch",e,"user","api","rpc","files.content.write")},_.filesDeleteBatchCheck=function(e){return this.request("files/delete_batch/check",e,"user","api","rpc","files.content.write")},_.filesDownload=function(e){return this.request("files/download",e,"user","content","download","files.content.read")},_.filesDownloadZip=function(e){return this.request("files/download_zip",e,"user","content","download","files.content.read")},_.filesExport=function(e){return this.request("files/export",e,"user","content","download","files.content.read")},_.filesGetFileLockBatch=function(e){return this.request("files/get_file_lock_batch",e,"user","api","rpc","files.content.read")},_.filesGetMetadata=function(e){return this.request("files/get_metadata",e,"user","api","rpc","files.metadata.read")},_.filesGetPreview=function(e){return this.request("files/get_preview",e,"user","content","download","files.content.read")},_.filesGetTemporaryLink=function(e){return this.request("files/get_temporary_link",e,"user","api","rpc","files.content.read")},_.filesGetTemporaryUploadLink=function(e){return this.request("files/get_temporary_upload_link",e,"user","api","rpc","files.content.write")},_.filesGetThumbnail=function(e){return this.request("files/get_thumbnail",e,"user","content","download","files.content.read")},_.filesGetThumbnailV2=function(e){return this.request("files/get_thumbnail_v2",e,"app, user","content","download","files.content.read")},_.filesGetThumbnailBatch=function(e){return this.request("files/get_thumbnail_batch",e,"user","content","rpc","files.content.read")},_.filesListFolder=function(e){return this.request("files/list_folder",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderContinue=function(e){return this.request("files/list_folder/continue",e,"app, user","api","rpc","files.metadata.read")},_.filesListFolderGetLatestCursor=function(e){return this.request("files/list_folder/get_latest_cursor",e,"user","api","rpc","files.metadata.read")},_.filesListFolderLongpoll=function(e){return this.request("files/list_folder/longpoll",e,"noauth","notify","rpc","files.metadata.read")},_.filesListRevisions=function(e){return this.request("files/list_revisions",e,"user","api","rpc","files.metadata.read")},_.filesLockFileBatch=function(e){return this.request("files/lock_file_batch",e,"user","api","rpc","files.content.write")},_.filesMoveV2=function(e){return this.request("files/move_v2",e,"user","api","rpc","files.content.write")},_.filesMove=function(e){return this.request("files/move",e,"user","api","rpc","files.content.write")},_.filesMoveBatchV2=function(e){return this.request("files/move_batch_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatch=function(e){return this.request("files/move_batch",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheckV2=function(e){return this.request("files/move_batch/check_v2",e,"user","api","rpc","files.content.write")},_.filesMoveBatchCheck=function(e){return this.request("files/move_batch/check",e,"user","api","rpc","files.content.write")},_.filesPaperCreate=function(e){return this.request("files/paper/create",e,"user","api","upload","files.content.write")},_.filesPaperUpdate=function(e){return this.request("files/paper/update",e,"user","api","upload","files.content.write")},_.filesPermanentlyDelete=function(e){return this.request("files/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.filesPropertiesAdd=function(e){return this.request("files/properties/add",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesOverwrite=function(e){return this.request("files/properties/overwrite",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesRemove=function(e){return this.request("files/properties/remove",e,"user","api","rpc","files.metadata.write")},_.filesPropertiesTemplateGet=function(e){return this.request("files/properties/template/get",e,"user","api","rpc","files.metadata.read")},_.filesPropertiesTemplateList=function(){return this.request("files/properties/template/list",null,"user","api","rpc","files.metadata.read")},_.filesPropertiesUpdate=function(e){return this.request("files/properties/update",e,"user","api","rpc","files.metadata.write")},_.filesRestore=function(e){return this.request("files/restore",e,"user","api","rpc","files.content.write")},_.filesSaveUrl=function(e){return this.request("files/save_url",e,"user","api","rpc","files.content.write")},_.filesSaveUrlCheckJobStatus=function(e){return this.request("files/save_url/check_job_status",e,"user","api","rpc","files.content.write")},_.filesSearch=function(e){return this.request("files/search",e,"user","api","rpc","files.metadata.read")},_.filesSearchV2=function(e){return this.request("files/search_v2",e,"user","api","rpc","files.metadata.read")},_.filesSearchContinueV2=function(e){return this.request("files/search/continue_v2",e,"user","api","rpc","files.metadata.read")},_.filesTagsAdd=function(e){return this.request("files/tags/add",e,"user","api","rpc","files.metadata.write")},_.filesTagsGet=function(e){return this.request("files/tags/get",e,"user","api","rpc","files.metadata.read")},_.filesTagsRemove=function(e){return this.request("files/tags/remove",e,"user","api","rpc","files.metadata.write")},_.filesUnlockFileBatch=function(e){return this.request("files/unlock_file_batch",e,"user","api","rpc","files.content.write")},_.filesUpload=function(e){return this.request("files/upload",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppendV2=function(e){return this.request("files/upload_session/append_v2",e,"user","content","upload","files.content.write")},_.filesUploadSessionAppend=function(e){return this.request("files/upload_session/append",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinish=function(e){return this.request("files/upload_session/finish",e,"user","content","upload","files.content.write")},_.filesUploadSessionFinishBatch=function(e){return this.request("files/upload_session/finish_batch",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchV2=function(e){return this.request("files/upload_session/finish_batch_v2",e,"user","api","rpc","files.content.write")},_.filesUploadSessionFinishBatchCheck=function(e){return this.request("files/upload_session/finish_batch/check",e,"user","api","rpc","files.content.write")},_.filesUploadSessionStart=function(e){return this.request("files/upload_session/start",e,"user","content","upload","files.content.write")},_.paperDocsArchive=function(e){return this.request("paper/docs/archive",e,"user","api","rpc","files.content.write")},_.paperDocsCreate=function(e){return this.request("paper/docs/create",e,"user","api","upload","files.content.write")},_.paperDocsDownload=function(e){return this.request("paper/docs/download",e,"user","api","download","files.content.read")},_.paperDocsFolderUsersList=function(e){return this.request("paper/docs/folder_users/list",e,"user","api","rpc","sharing.read")},_.paperDocsFolderUsersListContinue=function(e){return this.request("paper/docs/folder_users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsGetFolderInfo=function(e){return this.request("paper/docs/get_folder_info",e,"user","api","rpc","sharing.read")},_.paperDocsList=function(e){return this.request("paper/docs/list",e,"user","api","rpc","files.metadata.read")},_.paperDocsListContinue=function(e){return this.request("paper/docs/list/continue",e,"user","api","rpc","files.metadata.read")},_.paperDocsPermanentlyDelete=function(e){return this.request("paper/docs/permanently_delete",e,"user","api","rpc","files.permanent_delete")},_.paperDocsSharingPolicyGet=function(e){return this.request("paper/docs/sharing_policy/get",e,"user","api","rpc","sharing.read")},_.paperDocsSharingPolicySet=function(e){return this.request("paper/docs/sharing_policy/set",e,"user","api","rpc","sharing.write")},_.paperDocsUpdate=function(e){return this.request("paper/docs/update",e,"user","api","upload","files.content.write")},_.paperDocsUsersAdd=function(e){return this.request("paper/docs/users/add",e,"user","api","rpc","sharing.write")},_.paperDocsUsersList=function(e){return this.request("paper/docs/users/list",e,"user","api","rpc","sharing.read")},_.paperDocsUsersListContinue=function(e){return this.request("paper/docs/users/list/continue",e,"user","api","rpc","sharing.read")},_.paperDocsUsersRemove=function(e){return this.request("paper/docs/users/remove",e,"user","api","rpc","sharing.write")},_.paperFoldersCreate=function(e){return this.request("paper/folders/create",e,"user","api","rpc","files.content.write")},_.sharingAddFileMember=function(e){return this.request("sharing/add_file_member",e,"user","api","rpc","sharing.write")},_.sharingAddFolderMember=function(e){return this.request("sharing/add_folder_member",e,"user","api","rpc","sharing.write")},_.sharingCheckJobStatus=function(e){return this.request("sharing/check_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckRemoveMemberJobStatus=function(e){return this.request("sharing/check_remove_member_job_status",e,"user","api","rpc","sharing.write")},_.sharingCheckShareJobStatus=function(e){return this.request("sharing/check_share_job_status",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLink=function(e){return this.request("sharing/create_shared_link",e,"user","api","rpc","sharing.write")},_.sharingCreateSharedLinkWithSettings=function(e){return this.request("sharing/create_shared_link_with_settings",e,"user","api","rpc","sharing.write")},_.sharingGetFileMetadata=function(e){return this.request("sharing/get_file_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetFileMetadataBatch=function(e){return this.request("sharing/get_file_metadata/batch",e,"user","api","rpc","sharing.read")},_.sharingGetFolderMetadata=function(e){return this.request("sharing/get_folder_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetSharedLinkFile=function(e){return this.request("sharing/get_shared_link_file",e,"user","content","download","sharing.read")},_.sharingGetSharedLinkMetadata=function(e){return this.request("sharing/get_shared_link_metadata",e,"user","api","rpc","sharing.read")},_.sharingGetSharedLinks=function(e){return this.request("sharing/get_shared_links",e,"user","api","rpc","sharing.read")},_.sharingListFileMembers=function(e){return this.request("sharing/list_file_members",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersBatch=function(e){return this.request("sharing/list_file_members/batch",e,"user","api","rpc","sharing.read")},_.sharingListFileMembersContinue=function(e){return this.request("sharing/list_file_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembers=function(e){return this.request("sharing/list_folder_members",e,"user","api","rpc","sharing.read")},_.sharingListFolderMembersContinue=function(e){return this.request("sharing/list_folder_members/continue",e,"user","api","rpc","sharing.read")},_.sharingListFolders=function(e){return this.request("sharing/list_folders",e,"user","api","rpc","sharing.read")},_.sharingListFoldersContinue=function(e){return this.request("sharing/list_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListMountableFolders=function(e){return this.request("sharing/list_mountable_folders",e,"user","api","rpc","sharing.read")},_.sharingListMountableFoldersContinue=function(e){return this.request("sharing/list_mountable_folders/continue",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFiles=function(e){return this.request("sharing/list_received_files",e,"user","api","rpc","sharing.read")},_.sharingListReceivedFilesContinue=function(e){return this.request("sharing/list_received_files/continue",e,"user","api","rpc","sharing.read")},_.sharingListSharedLinks=function(e){return this.request("sharing/list_shared_links",e,"user","api","rpc","sharing.read")},_.sharingModifySharedLinkSettings=function(e){return this.request("sharing/modify_shared_link_settings",e,"user","api","rpc","sharing.write")},_.sharingMountFolder=function(e){return this.request("sharing/mount_folder",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFileMembership=function(e){return this.request("sharing/relinquish_file_membership",e,"user","api","rpc","sharing.write")},_.sharingRelinquishFolderMembership=function(e){return this.request("sharing/relinquish_folder_membership",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember=function(e){return this.request("sharing/remove_file_member",e,"user","api","rpc","sharing.write")},_.sharingRemoveFileMember2=function(e){return this.request("sharing/remove_file_member_2",e,"user","api","rpc","sharing.write")},_.sharingRemoveFolderMember=function(e){return this.request("sharing/remove_folder_member",e,"user","api","rpc","sharing.write")},_.sharingRevokeSharedLink=function(e){return this.request("sharing/revoke_shared_link",e,"user","api","rpc","sharing.write")},_.sharingSetAccessInheritance=function(e){return this.request("sharing/set_access_inheritance",e,"user","api","rpc","sharing.write")},_.sharingShareFolder=function(e){return this.request("sharing/share_folder",e,"user","api","rpc","sharing.write")},_.sharingTransferFolder=function(e){return this.request("sharing/transfer_folder",e,"user","api","rpc","sharing.write")},_.sharingUnmountFolder=function(e){return this.request("sharing/unmount_folder",e,"user","api","rpc","sharing.write")},_.sharingUnshareFile=function(e){return this.request("sharing/unshare_file",e,"user","api","rpc","sharing.write")},_.sharingUnshareFolder=function(e){return this.request("sharing/unshare_folder",e,"user","api","rpc","sharing.write")},_.sharingUpdateFileMember=function(e){return this.request("sharing/update_file_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderMember=function(e){return this.request("sharing/update_folder_member",e,"user","api","rpc","sharing.write")},_.sharingUpdateFolderPolicy=function(e){return this.request("sharing/update_folder_policy",e,"user","api","rpc","sharing.write")},_.teamDevicesListMemberDevices=function(e){return this.request("team/devices/list_member_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListMembersDevices=function(e){return this.request("team/devices/list_members_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesListTeamDevices=function(e){return this.request("team/devices/list_team_devices",e,"team","api","rpc","sessions.list")},_.teamDevicesRevokeDeviceSession=function(e){return this.request("team/devices/revoke_device_session",e,"team","api","rpc","sessions.modify")},_.teamDevicesRevokeDeviceSessionBatch=function(e){return this.request("team/devices/revoke_device_session_batch",e,"team","api","rpc","sessions.modify")},_.teamFeaturesGetValues=function(e){return this.request("team/features/get_values",e,"team","api","rpc","team_info.read")},_.teamGetInfo=function(){return this.request("team/get_info",null,"team","api","rpc","team_info.read")},_.teamGroupsCreate=function(e){return this.request("team/groups/create",e,"team","api","rpc","groups.write")},_.teamGroupsDelete=function(e){return this.request("team/groups/delete",e,"team","api","rpc","groups.write")},_.teamGroupsGetInfo=function(e){return this.request("team/groups/get_info",e,"team","api","rpc","groups.read")},_.teamGroupsJobStatusGet=function(e){return this.request("team/groups/job_status/get",e,"team","api","rpc","groups.write")},_.teamGroupsList=function(e){return this.request("team/groups/list",e,"team","api","rpc","groups.read")},_.teamGroupsListContinue=function(e){return this.request("team/groups/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersAdd=function(e){return this.request("team/groups/members/add",e,"team","api","rpc","groups.write")},_.teamGroupsMembersList=function(e){return this.request("team/groups/members/list",e,"team","api","rpc","groups.read")},_.teamGroupsMembersListContinue=function(e){return this.request("team/groups/members/list/continue",e,"team","api","rpc","groups.read")},_.teamGroupsMembersRemove=function(e){return this.request("team/groups/members/remove",e,"team","api","rpc","groups.write")},_.teamGroupsMembersSetAccessType=function(e){return this.request("team/groups/members/set_access_type",e,"team","api","rpc","groups.write")},_.teamGroupsUpdate=function(e){return this.request("team/groups/update",e,"team","api","rpc","groups.write")},_.teamLegalHoldsCreatePolicy=function(e){return this.request("team/legal_holds/create_policy",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsGetPolicy=function(e){return this.request("team/legal_holds/get_policy",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsListHeldRevisions=function(e){return this.request("team/legal_holds/list_held_revisions",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsListHeldRevisionsContinue=function(e){return this.request("team/legal_holds/list_held_revisions_continue",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsListPolicies=function(e){return this.request("team/legal_holds/list_policies",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsReleasePolicy=function(e){return this.request("team/legal_holds/release_policy",e,"team","api","rpc","team_data.member")},_.teamLegalHoldsUpdatePolicy=function(e){return this.request("team/legal_holds/update_policy",e,"team","api","rpc","team_data.member")},_.teamLinkedAppsListMemberLinkedApps=function(e){return this.request("team/linked_apps/list_member_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListMembersLinkedApps=function(e){return this.request("team/linked_apps/list_members_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsListTeamLinkedApps=function(e){return this.request("team/linked_apps/list_team_linked_apps",e,"team","api","rpc","sessions.list")},_.teamLinkedAppsRevokeLinkedApp=function(e){return this.request("team/linked_apps/revoke_linked_app",e,"team","api","rpc","sessions.modify")},_.teamLinkedAppsRevokeLinkedAppBatch=function(e){return this.request("team/linked_apps/revoke_linked_app_batch",e,"team","api","rpc","sessions.modify")},_.teamMemberSpaceLimitsExcludedUsersAdd=function(e){return this.request("team/member_space_limits/excluded_users/add",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsExcludedUsersList=function(e){return this.request("team/member_space_limits/excluded_users/list",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersListContinue=function(e){return this.request("team/member_space_limits/excluded_users/list/continue",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsExcludedUsersRemove=function(e){return this.request("team/member_space_limits/excluded_users/remove",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsGetCustomQuota=function(e){return this.request("team/member_space_limits/get_custom_quota",e,"team","api","rpc","members.read")},_.teamMemberSpaceLimitsRemoveCustomQuota=function(e){return this.request("team/member_space_limits/remove_custom_quota",e,"team","api","rpc","members.write")},_.teamMemberSpaceLimitsSetCustomQuota=function(e){return this.request("team/member_space_limits/set_custom_quota",e,"team","api","rpc","members.read")},_.teamMembersAddV2=function(e){return this.request("team/members/add_v2",e,"team","api","rpc","members.write")},_.teamMembersAdd=function(e){return this.request("team/members/add",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGetV2=function(e){return this.request("team/members/add/job_status/get_v2",e,"team","api","rpc","members.write")},_.teamMembersAddJobStatusGet=function(e){return this.request("team/members/add/job_status/get",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhotoV2=function(e){return this.request("team/members/delete_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersDeleteProfilePhoto=function(e){return this.request("team/members/delete_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersGetAvailableTeamMemberRoles=function(){return this.request("team/members/get_available_team_member_roles",null,"team","api","rpc","members.read")},_.teamMembersGetInfoV2=function(e){return this.request("team/members/get_info_v2",e,"team","api","rpc","members.read")},_.teamMembersGetInfo=function(e){return this.request("team/members/get_info",e,"team","api","rpc","members.read")},_.teamMembersListV2=function(e){return this.request("team/members/list_v2",e,"team","api","rpc","members.read")},_.teamMembersList=function(e){return this.request("team/members/list",e,"team","api","rpc","members.read")},_.teamMembersListContinueV2=function(e){return this.request("team/members/list/continue_v2",e,"team","api","rpc","members.read")},_.teamMembersListContinue=function(e){return this.request("team/members/list/continue",e,"team","api","rpc","members.read")},_.teamMembersMoveFormerMemberFiles=function(e){return this.request("team/members/move_former_member_files",e,"team","api","rpc","members.write")},_.teamMembersMoveFormerMemberFilesJobStatusCheck=function(e){return this.request("team/members/move_former_member_files/job_status/check",e,"team","api","rpc","members.write")},_.teamMembersRecover=function(e){return this.request("team/members/recover",e,"team","api","rpc","members.delete")},_.teamMembersRemove=function(e){return this.request("team/members/remove",e,"team","api","rpc","members.delete")},_.teamMembersRemoveJobStatusGet=function(e){return this.request("team/members/remove/job_status/get",e,"team","api","rpc","members.delete")},_.teamMembersSecondaryEmailsAdd=function(e){return this.request("team/members/secondary_emails/add",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsDelete=function(e){return this.request("team/members/secondary_emails/delete",e,"team","api","rpc","members.write")},_.teamMembersSecondaryEmailsResendVerificationEmails=function(e){return this.request("team/members/secondary_emails/resend_verification_emails",e,"team","api","rpc","members.write")},_.teamMembersSendWelcomeEmail=function(e){return this.request("team/members/send_welcome_email",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissionsV2=function(e){return this.request("team/members/set_admin_permissions_v2",e,"team","api","rpc","members.write")},_.teamMembersSetAdminPermissions=function(e){return this.request("team/members/set_admin_permissions",e,"team","api","rpc","members.write")},_.teamMembersSetProfileV2=function(e){return this.request("team/members/set_profile_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfile=function(e){return this.request("team/members/set_profile",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhotoV2=function(e){return this.request("team/members/set_profile_photo_v2",e,"team","api","rpc","members.write")},_.teamMembersSetProfilePhoto=function(e){return this.request("team/members/set_profile_photo",e,"team","api","rpc","members.write")},_.teamMembersSuspend=function(e){return this.request("team/members/suspend",e,"team","api","rpc","members.write")},_.teamMembersUnsuspend=function(e){return this.request("team/members/unsuspend",e,"team","api","rpc","members.write")},_.teamNamespacesList=function(e){return this.request("team/namespaces/list",e,"team","api","rpc","team_data.member")},_.teamNamespacesListContinue=function(e){return this.request("team/namespaces/list/continue",e,"team","api","rpc","team_data.member")},_.teamPropertiesTemplateAdd=function(e){return this.request("team/properties/template/add",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateGet=function(e){return this.request("team/properties/template/get",e,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateList=function(){return this.request("team/properties/template/list",null,"team","api","rpc","files.team_metadata.write")},_.teamPropertiesTemplateUpdate=function(e){return this.request("team/properties/template/update",e,"team","api","rpc","files.team_metadata.write")},_.teamReportsGetActivity=function(e){return this.request("team/reports/get_activity",e,"team","api","rpc","team_info.read")},_.teamReportsGetDevices=function(e){return this.request("team/reports/get_devices",e,"team","api","rpc","team_info.read")},_.teamReportsGetMembership=function(e){return this.request("team/reports/get_membership",e,"team","api","rpc","team_info.read")},_.teamReportsGetStorage=function(e){return this.request("team/reports/get_storage",e,"team","api","rpc","team_info.read")},_.teamTeamFolderActivate=function(e){return this.request("team/team_folder/activate",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderArchive=function(e){return this.request("team/team_folder/archive",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderArchiveCheck=function(e){return this.request("team/team_folder/archive/check",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderCreate=function(e){return this.request("team/team_folder/create",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderGetInfo=function(e){return this.request("team/team_folder/get_info",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderList=function(e){return this.request("team/team_folder/list",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderListContinue=function(e){return this.request("team/team_folder/list/continue",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderPermanentlyDelete=function(e){return this.request("team/team_folder/permanently_delete",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderRename=function(e){return this.request("team/team_folder/rename",e,"team","api","rpc","team_data.team_space")},_.teamTeamFolderUpdateSyncSettings=function(e){return this.request("team/team_folder/update_sync_settings",e,"team","api","rpc","team_data.team_space")},_.teamTokenGetAuthenticatedAdmin=function(){return this.request("team/token/get_authenticated_admin",null,"team","api","rpc","team_info.read")},_.teamLogGetEvents=function(e){return this.request("team_log/get_events",e,"team","api","rpc","events.read")},_.teamLogGetEventsContinue=function(e){return this.request("team_log/get_events/continue",e,"team","api","rpc","events.read")},_.usersFeaturesGetValues=function(e){return this.request("users/features/get_values",e,"user","api","rpc","account_info.read")},_.usersGetAccount=function(e){return this.request("users/get_account",e,"user","api","rpc","sharing.read")},_.usersGetAccountBatch=function(e){return this.request("users/get_account_batch",e,"user","api","rpc","sharing.read")},_.usersGetCurrentAccount=function(){return this.request("users/get_current_account",null,"user","api","rpc","account_info.read")},_.usersGetSpaceUsage=function(){return this.request("users/get_space_usage",null,"user","api","rpc","account_info.read")};var q=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";return r?(t!==f&&void 0!==d[e]&&(e=d[e],r="-"),"https://".concat(e).concat(r).concat(t,"/2/")):"https://".concat(t,"/2/")},b=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:h;return e!==h&&(e="meta-".concat(e)),"https://".concat(e,"/oauth2/authorize")},v=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:f,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".",r="api";return e!==f&&(r=d[r],t="-"),"https://".concat(r).concat(t).concat(e,"/oauth2/token")};function w(e){return JSON.stringify(e).replace(/[\u007f-\uffff]/g,g)}function k(e){return new Date(Date.now()+1e3*e)}function y(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope||"undefined"==typeof module||"undefined"!=typeof window}function A(){return"undefined"!=typeof window}function C(e){return e.toString("base64").replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}var S,T,L,M=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&n(e,t)}(o,e);var r,s,u=(r=o,s=a(),function(){var e,t=i(r);if(s){var n=i(this).constructor;e=Reflect.construct(t,arguments,n)}else e=t.apply(this,arguments);return c(this,e)});function o(e,r,s){var i;return t(this,o),(i=u.call(this,"Response failed with a ".concat(e," code"))).name="DropboxResponseError",i.status=e,i.headers=r,i.error=s,i}return o}(o(Error)),P=function e(r,s,i){t(this,e),this.status=r,this.headers=s,this.result=i};function R(e){return e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}throw new M(e.status,e.headers,r)}))}function F(e){return e.ok?e.text().then((function(t){var r;try{r=JSON.parse(t)}catch(e){r=t}return new P(e.status,e.headers,r)})):R(e)}S=A()?window.fetch.bind(window):require("node-fetch"),T=A()?window.crypto||window.msCrypto:require("crypto"),L="undefined"==typeof TextEncoder?require("util").TextEncoder:TextEncoder;var D,G=["legacy","offline","online"],U=["code","token"],x=["none","user","team"],E=function(){function e(r){t(this,e),this.fetch=(r=r||{}).fetch||S,this.accessToken=r.accessToken,this.accessTokenExpiresAt=r.accessTokenExpiresAt,this.refreshToken=r.refreshToken,this.clientId=r.clientId,this.clientSecret=r.clientSecret,this.domain=r.domain,this.domainDelimiter=r.domainDelimiter,this.customHeaders=r.customHeaders,this.dataOnBody=r.dataOnBody}return s(e,[{key:"setAccessToken",value:function(e){this.accessToken=e}},{key:"getAccessToken",value:function(){return this.accessToken}},{key:"setClientId",value:function(e){this.clientId=e}},{key:"getClientId",value:function(){return this.clientId}},{key:"setClientSecret",value:function(e){this.clientSecret=e}},{key:"getClientSecret",value:function(){return this.clientSecret}},{key:"getRefreshToken",value:function(){return this.refreshToken}},{key:"setRefreshToken",value:function(e){this.refreshToken=e}},{key:"getAccessTokenExpiresAt",value:function(){return this.accessTokenExpiresAt}},{key:"setAccessTokenExpiresAt",value:function(e){this.accessTokenExpiresAt=e}},{key:"setCodeVerifier",value:function(e){this.codeVerifier=e}},{key:"getCodeVerifier",value:function(){return this.codeVerifier}},{key:"generateCodeChallenge",value:function(){var e,t=this,r=(new L).encode(this.codeVerifier);if(A())return T.subtle.digest("SHA-256",r).then((function(r){var s=btoa(String.fromCharCode.apply(null,new Uint8Array(r)));e=C(s).substr(0,128),t.codeChallenge=e}));var s=T.createHash("sha256").update(r).digest();return e=C(s),this.codeChallenge=e,Promise.resolve()}},{key:"generatePKCECodes",value:function(){var e;if(A()){var t=new Uint8Array(128),r=T.getRandomValues(t);e=C(btoa(r)).substr(0,128)}else{e=C(T.randomBytes(128)).substr(0,128)}return this.codeVerifier=e,this.generateCodeChallenge()}},{key:"getAuthenticationUrl",value:function(e,t){var r,s=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"token",n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"none",o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=this.getClientId(),p=b(this.domain);if(!c)throw Error("A client id is required. You can set the client id using .setClientId().");if("code"!==i&&!e)throw Error("A redirect uri is required.");if(!U.includes(i))throw Error("Authorization type must be code or token");if(n&&!G.includes(n))throw Error("Token Access Type must be legacy, offline, or online");if(a&&!(a instanceof Array))throw Error("Scope must be an array of strings");if(!x.includes(u))throw Error("includeGrantedScopes must be none, user, or team");return r="code"===i?"".concat(p,"?response_type=code&client_id=").concat(c):"".concat(p,"?response_type=token&client_id=").concat(c),e&&(r+="&redirect_uri=".concat(e)),t&&(r+="&state=".concat(t)),n&&(r+="&token_access_type=".concat(n)),a&&(r+="&scope=".concat(a.join(" "))),"none"!==u&&(r+="&include_granted_scopes=".concat(u)),o?this.generatePKCECodes().then((function(){return r+="&code_challenge_method=S256",r+="&code_challenge=".concat(s.codeChallenge)})):Promise.resolve(r)}},{key:"getAccessTokenFromCode",value:function(e,t){var r=this.getClientId(),s=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");var i=v(this.domain,this.domainDelimiter);if(i+="?grant_type=authorization_code",i+="&code=".concat(t),i+="&client_id=".concat(r),s)i+="&client_secret=".concat(s);else{if(!this.codeVerifier)throw Error("You must use PKCE when generating the authorization URL to not include a client secret");i+="&code_verifier=".concat(this.codeVerifier)}e&&(i+="&redirect_uri=".concat(e));return this.fetch(i,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"}}).then((function(e){return F(e)}))}},{key:"checkAndRefreshAccessToken",value:function(){var e=this.getRefreshToken()&&this.getClientId(),t=!this.getAccessTokenExpiresAt()||new Date(Date.now()+3e5)>=this.getAccessTokenExpiresAt(),r=!this.getAccessToken();return(t||r)&&e?this.refreshAccessToken():Promise.resolve()}},{key:"refreshAccessToken",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=this.getClientId(),s=this.getClientSecret();if(!r)throw Error("A client id is required. You can set the client id using .setClientId().");if(t&&!(t instanceof Array))throw Error("Scope must be an array of strings");var i=v(this.domain,this.domainDelimiter),n={headers:{"Content-Type":"application/json"},method:"POST"};if(this.dataOnBody){var a={grant_type:"refresh_token",client_id:r,refresh_token:this.getRefreshToken()};s&&(a.client_secret=s),t&&(a.scope=t.join(" ")),n.body=a}else i+="?grant_type=refresh_token&refresh_token=".concat(this.getRefreshToken()),i+="&client_id=".concat(r),s&&(i+="&client_secret=".concat(s)),t&&(i+="&scope=".concat(t.join(" ")));return this.fetch(i,n).then((function(e){return F(e)})).then((function(t){e.setAccessToken(t.result.access_token),e.setAccessTokenExpiresAt(k(t.result.expires_in))}))}}]),e}();D="undefined"!=typeof window?window.fetch.bind(window):require("node-fetch");var V="undefined"==typeof btoa?function(e){return Buffer.from(e).toString("base64")}:btoa;e.Dropbox=function(){function e(r){t(this,e),this.auth=(r=r||{}).auth?r.auth:new E(r),this.fetch=r.fetch||D,this.selectUser=r.selectUser,this.selectAdmin=r.selectAdmin,this.pathRoot=r.pathRoot,this.domain=r.domain||this.auth.domain,this.domainDelimiter=r.domainDelimiter||this.auth.domainDelimiter,this.customHeaders=r.customHeaders||this.auth.customHeaders,Object.assign(this,_)}return s(e,[{key:"request",value:function(e,t,r,s,i){switch(i){case"rpc":return this.rpcRequest(e,t,r,s);case"download":return this.downloadRequest(e,t,r,s);case"upload":return this.uploadRequest(e,t,r,s);default:throw Error("Invalid request style: ".concat(i))}}},{key:"rpcRequest",value:function(e,t,r,s){var i=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",body:t?JSON.stringify(t):null,headers:{}};return t&&(e.headers["Content-Type"]="application/json"),i.setAuthHeaders(r,e),i.setCommonHeaders(e),e})).then((function(t){return i.fetch(q(s,i.domain,i.domainDelimiter)+e,t)})).then((function(e){return F(e)}))}},{key:"downloadRequest",value:function(e,t,r,s){var i=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e={method:"POST",headers:{"Dropbox-API-Arg":w(t)}};return i.setAuthHeaders(r,e),i.setCommonHeaders(e),e})).then((function(t){return i.fetch(q(s,i.domain,i.domainDelimiter)+e,t)})).then((function(e){return function(e){return e.ok?new Promise((function(t){y()?e.blob().then((function(e){return t(e)})):e.buffer().then((function(e){return t(e)}))})).then((function(t){var r=JSON.parse(e.headers.get("dropbox-api-result"));return y()?r.fileBlob=t:r.fileBinary=t,new P(e.status,e.headers,r)})):R(e)}(e)}))}},{key:"uploadRequest",value:function(e,t,r,s){var i=this;return this.auth.checkAndRefreshAccessToken().then((function(){var e=t.contents;delete t.contents;var s={body:e,method:"POST",headers:{"Content-Type":"application/octet-stream","Dropbox-API-Arg":w(t)}};return i.setAuthHeaders(r,s),i.setCommonHeaders(s),s})).then((function(t){return i.fetch(q(s,i.domain,i.domainDelimiter)+e,t)})).then((function(e){return F(e)}))}},{key:"setAuthHeaders",value:function(e,t){if(e.split(",").length>1){var r=e.replace(" ","").split(",");r.includes(l)&&this.auth.getAccessToken()?e=l:r.includes(m)&&this.auth.getAccessToken()?e=m:r.includes(p)&&(e=p)}switch(e){case p:if(this.auth.clientId&&this.auth.clientSecret){var s=V("".concat(this.auth.clientId,":").concat(this.auth.clientSecret));t.headers.Authorization="Basic ".concat(s)}break;case m:case l:this.auth.getAccessToken()&&(t.headers.Authorization="Bearer ".concat(this.auth.getAccessToken()));break;case"noauth":case"cookie":break;default:throw Error("Unhandled auth type: ".concat(e))}}},{key:"setCommonHeaders",value:function(e){var t=this;(this.selectUser&&(e.headers["Dropbox-API-Select-User"]=this.selectUser),this.selectAdmin&&(e.headers["Dropbox-API-Select-Admin"]=this.selectAdmin),this.pathRoot&&(e.headers["Dropbox-API-Path-Root"]=this.pathRoot),this.customHeaders)&&Object.keys(this.customHeaders).forEach((function(r){e.headers[r]=t.customHeaders[r]}))}}]),e}(),e.DropboxAuth=E,e.DropboxResponse=P,e.DropboxResponseError=M,Object.defineProperty(e,"__esModule",{value:!0})}));


;/* mousetrap v1.6.5 craig.is/killing/mice */
(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent("on"+b,g)}function z(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function w(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function A(a,b){var g,d=[];var e=a;"+"===e?e=["+"]:(e=e.replace(/\+{2}/g,"+plus"),e=e.split("+"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&"keypress"!=b&&C[m]&&(m=C[m],d.push("shift"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?"keydown":"keypress"}"keypress"==g&&d.length&&(g="keydown");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=
a||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];"keyup"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e="keypress"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(",")===e.sort().join(","));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,
b.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&("keyup"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);"keyup"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||
A(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var e=a.split(" ");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,
d,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f="keypress"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&"keydown"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,"keypress",e);v(a,"keydown",e);v(a,"keyup",e)}if(q){var n={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},r={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},C={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},B={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},p;for(c=1;20>c;++c)n[111+c]="f"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};
this._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(" "+b.className+" ").indexOf(" mousetrap ")||D(b,this.target))return!1;if("composedPath"in a&&"function"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};
d.init=function(){var a=d(u),b;for(b in a)"_"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();q.Mousetrap=d;"undefined"!==typeof module&&module.exports&&(module.exports=d);"function"===typeof define&&define.amd&&define(function(){return d})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);


;/*!
 * Knockout JavaScript library v3.2.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var v=this||(0,eval)("this"),y=v.document,L=v.navigator,r=v.jQuery,D=v.JSON;(function(n){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?n(module.exports||exports,require):"function"===typeof define&&define.amd?define(["exports","require"],n):n(v.ko={})})(function(M,N){function H(a,d){return null===a||typeof a in Q?a===d:!1}function R(a,d){var c;return function(){c||(c=setTimeout(function(){c=n;a()},d))}}function S(a,d){var c;return function(){clearTimeout(c);
c=setTimeout(a,d)}}function I(b,d,c,e){a.d[b]={init:function(b,h,k,g,m){var l,s;a.s(function(){var g=a.a.c(h()),k=!c!==!g,z=!s;if(z||d||k!==l)z&&a.Y.la()&&(s=a.a.ia(a.f.childNodes(b),!0)),k?(z||a.f.T(b,a.a.ia(s)),a.Ca(e?e(m,g):m,b)):a.f.ja(b),l=k},null,{o:b});return{controlsDescendantBindings:!0}}};a.h.ha[b]=!1;a.f.Q[b]=!0}var a="undefined"!==typeof M?M:{};a.b=function(b,d){for(var c=b.split("."),e=a,f=0;f<c.length-1;f++)e=e[c[f]];e[c[c.length-1]]=d};a.A=function(a,d,c){a[d]=c};a.version="3.2.0";
a.b("version",a.version);a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function d(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function c(a,b){a.__proto__=b;return a}var e={__proto__:[]}instanceof Array,f={},h={};f[L&&/Firefox\/2/i.test(L.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];f.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(f,function(a,b){if(b.length)for(var c=
0,d=b.length;c<d;c++)h[b[c]]=a});var k={propertychange:!0},g=y&&function(){for(var a=3,b=y.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}();return{vb:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],u:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},m:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===
b)return c;return-1},qb:function(a,b,c){for(var d=0,g=a.length;d<g;d++)if(b.call(c,a[d],d))return a[d];return null},ua:function(m,b){var c=a.a.m(m,b);0<c?m.splice(c,1):0===c&&m.shift()},rb:function(m){m=m||[];for(var b=[],c=0,d=m.length;c<d;c++)0>a.a.m(b,m[c])&&b.push(m[c]);return b},Da:function(a,b){a=a||[];for(var c=[],d=0,g=a.length;d<g;d++)c.push(b(a[d],d));return c},ta:function(a,b){a=a||[];for(var c=[],d=0,g=a.length;d<g;d++)b(a[d],d)&&c.push(a[d]);return c},ga:function(a,b){if(b instanceof
Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},ea:function(b,c,d){var g=a.a.m(a.a.Xa(b),c);0>g?d&&b.push(c):d||b.splice(g,1)},xa:e,extend:d,za:c,Aa:e?c:d,G:b,na:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},Ka:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},oc:function(b){b=a.a.S(b);for(var c=y.createElement("div"),d=0,g=b.length;d<g;d++)c.appendChild(a.R(b[d]));return c},ia:function(b,c){for(var d=
0,g=b.length,e=[];d<g;d++){var f=b[d].cloneNode(!0);e.push(c?a.R(f):f)}return e},T:function(b,c){a.a.Ka(b);if(c)for(var d=0,g=c.length;d<g;d++)b.appendChild(c[d])},Lb:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var g=d[0],e=g.parentNode,f=0,h=c.length;f<h;f++)e.insertBefore(c[f],g);f=0;for(h=d.length;f<h;f++)a.removeNode(d[f])}},ka:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.shift();if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=
0;c!==d;)if(a.push(c),c=c.nextSibling,!c)return;a.push(d)}}return a},Nb:function(a,b){7>g?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===n?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},uc:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},cc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&
16);for(;a&&a!=b;)a=a.parentNode;return!!a},Ja:function(b){return a.a.cc(b,b.ownerDocument.documentElement)},ob:function(b){return!!a.a.qb(b,a.a.Ja)},t:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},n:function(b,c,d){var e=g&&k[c];if(!e&&r)r(b).bind(c,d);else if(e||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var f=function(a){d.call(b,a)},h="on"+c;b.attachEvent(h,f);a.a.w.da(b,function(){b.detachEvent(h,f)})}else throw Error("Browser doesn't support addEventListener or attachEvent");
else b.addEventListener(c,d,!1)},oa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.t(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(r&&!d)r(b).trigger(c);else if("function"==typeof y.createEvent)if("function"==typeof b.dispatchEvent)d=y.createEvent(h[c]||"HTMLEvents"),d.initEvent(c,!0,!0,v,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");
else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");},c:function(b){return a.C(b)?b():b},Xa:function(b){return a.C(b)?b.v():b},Ba:function(b,c,d){if(c){var g=/\S+/g,e=b.className.match(g)||[];a.a.u(c.match(g),function(b){a.a.ea(e,b,d)});b.className=e.join(" ")}},bb:function(b,c){var d=a.a.c(c);if(null===d||d===n)d="";var g=a.f.firstChild(b);!g||3!=g.nodeType||a.f.nextSibling(g)?a.f.T(b,[b.ownerDocument.createTextNode(d)]):
g.data=d;a.a.fc(b)},Mb:function(a,b){a.name=b;if(7>=g)try{a.mergeAttributes(y.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},fc:function(a){9<=g&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},dc:function(a){if(g){var b=a.style.width;a.style.width=0;a.style.width=b}},sc:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],g=b;g<=c;g++)d.push(g);return d},S:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},xc:6===g,yc:7===g,L:g,xb:function(b,c){for(var d=
a.a.S(b.getElementsByTagName("input")).concat(a.a.S(b.getElementsByTagName("textarea"))),g="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},e=[],f=d.length-1;0<=f;f--)g(d[f])&&e.push(d[f]);return e},pc:function(b){return"string"==typeof b&&(b=a.a.cb(b))?D&&D.parse?D.parse(b):(new Function("return "+b))():null},eb:function(b,c,d){if(!D||!D.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return D.stringify(a.a.c(b),c,d)},qc:function(c,d,g){g=g||{};var e=g.params||{},f=g.includeFields||this.vb,h=c;if("object"==typeof c&&"form"===a.a.t(c))for(var h=c.action,k=f.length-1;0<=k;k--)for(var t=a.a.xb(c,f[k]),E=t.length-1;0<=E;E--)e[t[E].name]=t[E].value;d=a.a.c(d);var x=y.createElement("form");x.style.display="none";x.action=h;x.method="post";for(var n in d)c=y.createElement("input"),c.type="hidden",c.name=n,c.value=a.a.eb(a.a.c(d[n])),x.appendChild(c);b(e,function(a,b){var c=y.createElement("input");
c.type="hidden";c.name=a;c.value=b;x.appendChild(c)});y.body.appendChild(x);g.submitter?g.submitter(x):x.submit();setTimeout(function(){x.parentNode.removeChild(x)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.u);a.b("utils.arrayFirst",a.a.qb);a.b("utils.arrayFilter",a.a.ta);a.b("utils.arrayGetDistinctValues",a.a.rb);a.b("utils.arrayIndexOf",a.a.m);a.b("utils.arrayMap",a.a.Da);a.b("utils.arrayPushAll",a.a.ga);a.b("utils.arrayRemoveItem",a.a.ua);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.vb);a.b("utils.getFormFields",a.a.xb);a.b("utils.peekObservable",a.a.Xa);a.b("utils.postJson",a.a.qc);a.b("utils.parseJson",a.a.pc);a.b("utils.registerEventHandler",a.a.n);a.b("utils.stringifyJson",a.a.eb);a.b("utils.range",a.a.sc);a.b("utils.toggleDomNodeCssClass",a.a.Ba);a.b("utils.triggerEvent",a.a.oa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.G);a.b("utils.addOrRemoveItem",a.a.ea);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=function(a){var d=
this,c=Array.prototype.slice.call(arguments);a=c.shift();return function(){return d.apply(a,c.concat(Array.prototype.slice.call(arguments)))}});a.a.e=new function(){function a(b,h){var k=b[c];if(!k||"null"===k||!e[k]){if(!h)return n;k=b[c]="ko"+d++;e[k]={}}return e[k]}var d=0,c="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===n?n:e[d]},set:function(c,d,e){if(e!==n||a(c,!1)!==n)a(c,!0)[d]=e},clear:function(a){var b=a[c];return b?(delete e[b],a[c]=null,!0):!1},F:function(){return d++ +
c}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.w=new function(){function b(b,d){var g=a.a.e.get(b,c);g===n&&d&&(g=[],a.a.e.set(b,c,g));return g}function d(c){var e=b(c,!1);if(e)for(var e=e.slice(0),g=0;g<e.length;g++)e[g](c);a.a.e.clear(c);a.a.w.cleanExternalData(c);if(f[c.nodeType])for(e=c.firstChild;c=e;)e=c.nextSibling,8===c.nodeType&&d(c)}var c=a.a.e.F(),e={1:!0,8:!0,9:!0},f={1:!0,9:!0};return{da:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");
b(a,!0).push(c)},Kb:function(d,e){var g=b(d,!1);g&&(a.a.ua(g,e),0==g.length&&a.a.e.set(d,c,n))},R:function(b){if(e[b.nodeType]&&(d(b),f[b.nodeType])){var c=[];a.a.ga(c,b.getElementsByTagName("*"));for(var g=0,m=c.length;g<m;g++)d(c[g])}return b},removeNode:function(b){a.R(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){r&&"function"==typeof r.cleanData&&r.cleanData([a])}}};a.R=a.a.w.R;a.removeNode=a.a.w.removeNode;a.b("cleanNode",a.R);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",
a.a.w);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.w.da);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.w.Kb);(function(){a.a.ba=function(b){var d;if(r)if(r.parseHTML)d=r.parseHTML(b)||[];else{if((d=r.clean([b]))&&d[0]){for(b=d[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&b.parentNode.removeChild(b)}}else{var c=a.a.cb(b).toLowerCase();d=y.createElement("div");c=c.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!c.indexOf("<tr")&&[2,"<table><tbody>",
"</tbody></table>"]||(!c.indexOf("<td")||!c.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];b="ignored<div>"+c[1]+b+c[2]+"</div>";for("function"==typeof v.innerShiv?d.appendChild(v.innerShiv(b)):d.innerHTML=b;c[0]--;)d=d.lastChild;d=a.a.S(d.lastChild.childNodes)}return d};a.a.$a=function(b,d){a.a.Ka(b);d=a.a.c(d);if(null!==d&&d!==n)if("string"!=typeof d&&(d=d.toString()),r)r(b).html(d);else for(var c=a.a.ba(d),e=0;e<c.length;e++)b.appendChild(c[e])}})();a.b("utils.parseHtmlFragment",
a.a.ba);a.b("utils.setHtml",a.a.$a);a.D=function(){function b(c,d){if(c)if(8==c.nodeType){var f=a.D.Gb(c.nodeValue);null!=f&&d.push({bc:c,mc:f})}else if(1==c.nodeType)for(var f=0,h=c.childNodes,k=h.length;f<k;f++)b(h[f],d)}var d={};return{Ua:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);d[b]=a;return"\x3c!--[ko_memo:"+
b+"]--\x3e"},Rb:function(a,b){var f=d[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),!0}finally{delete d[a]}},Sb:function(c,d){var f=[];b(c,f);for(var h=0,k=f.length;h<k;h++){var g=f[h].bc,m=[g];d&&a.a.ga(m,d);a.D.Rb(f[h].mc,m);g.nodeValue="";g.parentNode&&g.parentNode.removeChild(g)}},Gb:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.D);a.b("memoization.memoize",a.D.Ua);
a.b("memoization.unmemoize",a.D.Rb);a.b("memoization.parseMemoText",a.D.Gb);a.b("memoization.unmemoizeDomNodeAndDescendants",a.D.Sb);a.La={throttle:function(b,d){b.throttleEvaluation=d;var c=null;return a.j({read:b,write:function(a){clearTimeout(c);c=setTimeout(function(){b(a)},d)}})},rateLimit:function(a,d){var c,e,f;"number"==typeof d?c=d:(c=d.timeout,e=d.method);f="notifyWhenChangesStop"==e?S:R;a.Ta(function(a){return f(a,c)})},notify:function(a,d){a.equalityComparer="always"==d?null:H}};var Q=
{undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.La);a.Pb=function(b,d,c){this.target=b;this.wa=d;this.ac=c;this.Cb=!1;a.A(this,"dispose",this.K)};a.Pb.prototype.K=function(){this.Cb=!0;this.ac()};a.P=function(){a.a.Aa(this,a.P.fn);this.M={}};var B={U:function(b,d,c){var e=this;c=c||"change";var f=new a.Pb(e,d?b.bind(d):b,function(){a.a.ua(e.M[c],f);e.nb&&e.nb()});e.va&&e.va(c);e.M[c]||(e.M[c]=[]);e.M[c].push(f);return f},notifySubscribers:function(b,d){d=d||"change";if(this.Ab(d))try{a.k.Ea();
for(var c=this.M[d].slice(0),e=0,f;f=c[e];++e)f.Cb||f.wa(b)}finally{a.k.end()}},Ta:function(b){var d=this,c=a.C(d),e,f,h;d.qa||(d.qa=d.notifySubscribers,d.notifySubscribers=function(a,b){b&&"change"!==b?"beforeChange"===b?d.kb(a):d.qa(a,b):d.lb(a)});var k=b(function(){c&&h===d&&(h=d());e=!1;d.Pa(f,h)&&d.qa(f=h)});d.lb=function(a){e=!0;h=a;k()};d.kb=function(a){e||(f=a,d.qa(a,"beforeChange"))}},Ab:function(a){return this.M[a]&&this.M[a].length},yb:function(){var b=0;a.a.G(this.M,function(a,c){b+=c.length});
return b},Pa:function(a,d){return!this.equalityComparer||!this.equalityComparer(a,d)},extend:function(b){var d=this;b&&a.a.G(b,function(b,e){var f=a.La[b];"function"==typeof f&&(d=f(d,e)||d)});return d}};a.A(B,"subscribe",B.U);a.A(B,"extend",B.extend);a.A(B,"getSubscriptionsCount",B.yb);a.a.xa&&a.a.za(B,Function.prototype);a.P.fn=B;a.Db=function(a){return null!=a&&"function"==typeof a.U&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.P);a.b("isSubscribable",a.Db);a.Y=a.k=function(){function b(a){c.push(e);
e=a}function d(){e=c.pop()}var c=[],e,f=0;return{Ea:b,end:d,Jb:function(b){if(e){if(!a.Db(b))throw Error("Only subscribable things can act as dependencies");e.wa(b,b.Vb||(b.Vb=++f))}},B:function(a,c,g){try{return b(),a.apply(c,g||[])}finally{d()}},la:function(){if(e)return e.s.la()},ma:function(){if(e)return e.ma}}}();a.b("computedContext",a.Y);a.b("computedContext.getDependenciesCount",a.Y.la);a.b("computedContext.isInitial",a.Y.ma);a.b("computedContext.isSleeping",a.Y.zc);a.p=function(b){function d(){if(0<
arguments.length)return d.Pa(c,arguments[0])&&(d.X(),c=arguments[0],d.W()),this;a.k.Jb(d);return c}var c=b;a.P.call(d);a.a.Aa(d,a.p.fn);d.v=function(){return c};d.W=function(){d.notifySubscribers(c)};d.X=function(){d.notifySubscribers(c,"beforeChange")};a.A(d,"peek",d.v);a.A(d,"valueHasMutated",d.W);a.A(d,"valueWillMutate",d.X);return d};a.p.fn={equalityComparer:H};var F=a.p.rc="__ko_proto__";a.p.fn[F]=a.p;a.a.xa&&a.a.za(a.p.fn,a.P.fn);a.Ma=function(b,d){return null===b||b===n||b[F]===n?!1:b[F]===
d?!0:a.Ma(b[F],d)};a.C=function(b){return a.Ma(b,a.p)};a.Ra=function(b){return"function"==typeof b&&b[F]===a.p||"function"==typeof b&&b[F]===a.j&&b.hc?!0:!1};a.b("observable",a.p);a.b("isObservable",a.C);a.b("isWriteableObservable",a.Ra);a.b("isWritableObservable",a.Ra);a.aa=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.p(b);a.a.Aa(b,a.aa.fn);return b.extend({trackArrayChanges:!0})};
a.aa.fn={remove:function(b){for(var d=this.v(),c=[],e="function"!=typeof b||a.C(b)?function(a){return a===b}:b,f=0;f<d.length;f++){var h=d[f];e(h)&&(0===c.length&&this.X(),c.push(h),d.splice(f,1),f--)}c.length&&this.W();return c},removeAll:function(b){if(b===n){var d=this.v(),c=d.slice(0);this.X();d.splice(0,d.length);this.W();return c}return b?this.remove(function(c){return 0<=a.a.m(b,c)}):[]},destroy:function(b){var d=this.v(),c="function"!=typeof b||a.C(b)?function(a){return a===b}:b;this.X();
for(var e=d.length-1;0<=e;e--)c(d[e])&&(d[e]._destroy=!0);this.W()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(d){return 0<=a.a.m(b,d)}):[]},indexOf:function(b){var d=this();return a.a.m(d,b)},replace:function(a,d){var c=this.indexOf(a);0<=c&&(this.X(),this.v()[c]=d,this.W())}};a.a.u("pop push reverse shift sort splice unshift".split(" "),function(b){a.aa.fn[b]=function(){var a=this.v();this.X();this.sb(a,b,arguments);a=a[b].apply(a,arguments);this.W();
return a}});a.a.u(["slice"],function(b){a.aa.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.a.xa&&a.a.za(a.aa.fn,a.p.fn);a.b("observableArray",a.aa);a.La.trackArrayChanges=function(b){function d(){if(!c){c=!0;var d=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&"change"!==b||++f;return d.apply(this,arguments)};var g=[].concat(b.v()||[]);e=null;b.U(function(c){c=[].concat(c||[]);if(b.Ab("arrayChange")){var d;if(!e||1<f)e=a.a.Fa(g,c,{sparse:!0});d=e;d.length&&b.notifySubscribers(d,
"arrayChange")}g=c;e=null;f=0})}}if(!b.sb){var c=!1,e=null,f=0,h=b.U;b.U=b.subscribe=function(a,b,c){"arrayChange"===c&&d();return h.apply(this,arguments)};b.sb=function(b,d,m){function l(a,b,c){return s[s.length]={status:a,value:b,index:c}}if(c&&!f){var s=[],h=b.length,p=m.length,z=0;switch(d){case "push":z=h;case "unshift":for(d=0;d<p;d++)l("added",m[d],z+d);break;case "pop":z=h-1;case "shift":h&&l("deleted",b[z],z);break;case "splice":d=Math.min(Math.max(0,0>m[0]?h+m[0]:m[0]),h);for(var h=1===
p?h:Math.min(d+(m[1]||0),h),p=d+p-2,z=Math.max(h,p),u=[],t=[],E=2;d<z;++d,++E)d<h&&t.push(l("deleted",b[d],d)),d<p&&u.push(l("added",m[E],d));a.a.wb(t,u);break;default:return}e=s}}}};a.s=a.j=function(b,d,c){function e(){a.a.G(v,function(a,b){b.K()});v={}}function f(){e();A=0;u=!0;q=!1}function h(){var a=g.throttleEvaluation;a&&0<=a?(clearTimeout(O),O=setTimeout(k,a)):g.ib?g.ib():k()}function k(b){if(p){if(E)throw Error("A 'pure' computed must not be called recursively");}else if(!u){if(J&&J()){if(!z){r();
return}}else z=!1;p=!0;if(x)try{var c={};a.k.Ea({wa:function(a,b){c[b]||(c[b]=1,++A)},s:g,ma:n});A=0;s=t.call(d)}finally{a.k.end(),p=!1}else try{var e=v,l=A;a.k.Ea({wa:function(a,b){u||(l&&e[b]?(v[b]=e[b],++A,delete e[b],--l):v[b]||(v[b]=a.U(h),++A))},s:g,ma:E?n:!A});v={};A=0;try{var m=d?t.call(d):t()}finally{a.k.end(),l&&a.a.G(e,function(a,b){b.K()}),q=!1}g.Pa(s,m)&&(g.notifySubscribers(s,"beforeChange"),s=m,!0!==b&&g.notifySubscribers(s))}finally{p=!1}A||r()}}function g(){if(0<arguments.length){if("function"===
typeof G)G.apply(d,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}a.k.Jb(g);q&&k(!0);return s}function m(){q&&!A&&k(!0);return s}function l(){return q||0<A}var s,q=!0,p=!1,z=!1,u=!1,t=b,E=!1,x=!1;t&&"object"==typeof t?(c=t,t=c.read):(c=c||{},t||(t=c.read));if("function"!=typeof t)throw Error("Pass a function that returns the value of the ko.computed");var G=c.write,
w=c.disposeWhenNodeIsRemoved||c.o||null,C=c.disposeWhen||c.Ia,J=C,r=f,v={},A=0,O=null;d||(d=c.owner);a.P.call(g);a.a.Aa(g,a.j.fn);g.v=m;g.la=function(){return A};g.hc="function"===typeof c.write;g.K=function(){r()};g.Z=l;var y=g.Ta;g.Ta=function(a){y.call(g,a);g.ib=function(){g.kb(s);q=!0;g.lb(g)}};c.pure?(x=E=!0,g.va=function(){x&&(x=!1,k(!0))},g.nb=function(){g.yb()||(e(),x=q=!0)}):c.deferEvaluation&&(g.va=function(){m();delete g.va});a.A(g,"peek",g.v);a.A(g,"dispose",g.K);a.A(g,"isActive",g.Z);
a.A(g,"getDependenciesCount",g.la);w&&(z=!0,w.nodeType&&(J=function(){return!a.a.Ja(w)||C&&C()}));x||c.deferEvaluation||k();w&&l()&&w.nodeType&&(r=function(){a.a.w.Kb(w,r);f()},a.a.w.da(w,r));return g};a.jc=function(b){return a.Ma(b,a.j)};B=a.p.rc;a.j[B]=a.p;a.j.fn={equalityComparer:H};a.j.fn[B]=a.j;a.a.xa&&a.a.za(a.j.fn,a.P.fn);a.b("dependentObservable",a.j);a.b("computed",a.j);a.b("isComputed",a.jc);a.Ib=function(b,d){if("function"===typeof b)return a.s(b,d,{pure:!0});b=a.a.extend({},b);b.pure=
!0;return a.s(b,d)};a.b("pureComputed",a.Ib);(function(){function b(a,f,h){h=h||new c;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};h.save(a,k);d(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":k[c]=d;break;case "object":case "undefined":var l=h.get(d);k[c]=l!==n?l:b(d,f,h)}});return k}function d(a,b){if(a instanceof Array){for(var c=
0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function c(){this.keys=[];this.hb=[]}a.Qb=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.C(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Qb(b);return a.a.eb(b,c,d)};c.prototype={save:function(b,c){var d=a.a.m(this.keys,b);0<=d?this.hb[d]=c:(this.keys.push(b),this.hb.push(c))},get:function(b){b=a.a.m(this.keys,
b);return 0<=b?this.hb[b]:n}}})();a.b("toJS",a.Qb);a.b("toJSON",a.toJSON);(function(){a.i={q:function(b){switch(a.a.t(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.Va):7>=a.a.L?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex]):n;default:return b.value}},ca:function(b,d,c){switch(a.a.t(b)){case "option":switch(typeof d){case "string":a.a.e.set(b,a.d.options.Va,
n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=d;break;default:a.a.e.set(b,a.d.options.Va,d),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof d?d:""}break;case "select":if(""===d||null===d)d=n;for(var e=-1,f=0,h=b.options.length,k;f<h;++f)if(k=a.i.q(b.options[f]),k==d||""==k&&d===n){e=f;break}if(c||0<=e||d===n&&1<b.size)b.selectedIndex=e;break;default:if(null===d||d===n)d="";b.value=d}}}})();a.b("selectExtensions",a.i);a.b("selectExtensions.readValue",
a.i.q);a.b("selectExtensions.writeValue",a.i.ca);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),s,k,p=0;if(d){d.push(",");for(var z=0,u;u=d[z];++z){var t=u.charCodeAt(0);if(44===t){if(0>=p){s&&c.push(k?{key:s,value:k.join("")}:{unknown:s});s=k=p=0;continue}}else if(58===t){if(!k)continue}else if(47===t&&z&&1<u.length)(t=d[z-1].match(f))&&!h[t[0]]&&(b=b.substr(b.indexOf(u)+1),d=b.match(e),d.push(","),z=-1,u="/");else if(40===t||123===t||91===
t)++p;else if(41===t||125===t||93===t)--p;else if(!s&&!k){s=34===t||39===t?u.slice(1,-1):u;continue}k?k.push(u):k=[u]}}return c}var d=["true","false","null","undefined"],c=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,h={"in":1,"return":1,"typeof":1},k={};return{ha:[],V:k,Wa:b,ya:function(g,m){function l(b,g){var m;if(!z){var u=
a.getBindingHandler(b);if(u&&u.preprocess&&!(g=u.preprocess(g,b,l)))return;if(u=k[b])m=g,0<=a.a.m(d,m)?m=!1:(u=m.match(c),m=null===u?!1:u[1]?"Object("+u[1]+")"+u[2]:m),u=m;u&&f.push("'"+b+"':function(_z){"+m+"=_z}")}h&&(g="function(){return "+g+" }");e.push("'"+b+"':"+g)}m=m||{};var e=[],f=[],h=m.valueAccessors,z=m.bindingParams,u="string"===typeof g?b(g):g;a.a.u(u,function(a){l(a.key||a.unknown,a.value)});f.length&&l("_ko_property_writers","{"+f.join(",")+" }");return e.join(",")},lc:function(a,
b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},pa:function(b,c,d,e,f){if(b&&a.C(b))!a.Ra(b)||f&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.ha);a.b("expressionRewriting.parseObjectLiteral",a.h.Wa);a.b("expressionRewriting.preProcessBindings",a.h.ya);a.b("expressionRewriting._twoWayBindings",a.h.V);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",
a.h.ya);(function(){function b(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(a){return 8==a.nodeType&&k.test(f?a.text:a.nodeValue)}function c(a,c){for(var g=a,e=1,f=[];g=g.nextSibling;){if(d(g)&&(e--,0===e))return f;f.push(g);b(g)&&e++}if(!c)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var d=c(a,b);return d?0<d.length?d[d.length-1].nextSibling:a.nextSibling:null}var f=y&&"\x3c!--test--\x3e"===y.createComment("test").text,h=f?
/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,k=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,g={ul:!0,ol:!0};a.f={Q:{},childNodes:function(a){return b(a)?c(a):a.childNodes},ja:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,g=c.length;d<g;d++)a.removeNode(c[d])}else a.a.Ka(c)},T:function(c,d){if(b(c)){a.f.ja(c);for(var g=c.nextSibling,e=0,f=d.length;e<f;e++)g.parentNode.insertBefore(d[e],g)}else a.a.T(c,d)},Hb:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):
a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},Bb:function(c,d,g){g?b(c)?c.parentNode.insertBefore(d,g.nextSibling):g.nextSibling?c.insertBefore(d,g.nextSibling):c.appendChild(d):a.f.Hb(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||d(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&d(a.nextSibling)?null:a.nextSibling},gc:b,wc:function(a){return(a=(f?a.text:a.nodeValue).match(h))?a[1]:null},Fb:function(c){if(g[a.a.t(c)]){var l=
c.firstChild;if(l){do if(1===l.nodeType){var f;f=l.firstChild;var h=null;if(f){do if(h)h.push(f);else if(b(f)){var k=e(f,!0);k?f=k:h=[f]}else d(f)&&(h=[f]);while(f=f.nextSibling)}if(f=h)for(h=l.nextSibling,k=0;k<f.length;k++)h?c.insertBefore(f[k],h):c.appendChild(f[k])}while(l=l.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.Q);a.b("virtualElements.emptyNode",a.f.ja);a.b("virtualElements.insertAfter",a.f.Bb);a.b("virtualElements.prepend",a.f.Hb);a.b("virtualElements.setDomNodeChildren",
a.f.T);(function(){a.J=function(){this.Yb={}};a.a.extend(a.J.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.gc(b);default:return!1}},getBindings:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b):null;return a.g.mb(c,b,d,!1)},getBindingAccessors:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b,{valueAccessors:!0}):null;return a.g.mb(c,
b,d,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.f.wc(b);default:return null}},parseBindingsString:function(b,d,c,e){try{var f=this.Yb,h=b+(e&&e.valueAccessors||""),k;if(!(k=f[h])){var g,m="with($context){with($data||{}){return{"+a.h.ya(b,e)+"}}}";g=new Function("$context","$element",m);k=f[h]=g}return k(d,c)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.J.instance=new a.J})();
a.b("bindingProvider",a.J);(function(){function b(a){return function(){return a}}function d(a){return a()}function c(b){return a.a.na(a.k.B(b),function(a,c){return function(){return b()[c]}})}function e(d,g,e){return"function"===typeof d?c(d.bind(null,g,e)):a.a.na(d,b)}function f(a,b){return c(this.getBindings.bind(this,a,b))}function h(b,c,d){var g,e=a.f.firstChild(c),l=a.J.instance,f=l.preprocessNode;if(f){for(;g=e;)e=a.f.nextSibling(g),f.call(l,g);e=a.f.firstChild(c)}for(;g=e;)e=a.f.nextSibling(g),
k(b,g,d)}function k(b,c,d){var g=!0,e=1===c.nodeType;e&&a.f.Fb(c);if(e&&d||a.J.instance.nodeHasBindings(c))g=m(c,null,b,d).shouldBindDescendants;g&&!s[a.a.t(c)]&&h(b,c,!e)}function g(b){var c=[],d={},g=[];a.a.G(b,function G(e){if(!d[e]){var l=a.getBindingHandler(e);l&&(l.after&&(g.push(e),a.a.u(l.after,function(c){if(b[c]){if(-1!==a.a.m(g,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+g.join(", "));G(c)}}),g.length--),c.push({key:e,zb:l}));d[e]=!0}});
return c}function m(b,c,e,l){var m=a.a.e.get(b,q);if(!c){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&l&&a.Ob(b,e);var h;if(c&&"function"!==typeof c)h=c;else{var k=a.J.instance,s=k.getBindingAccessors||f,p=a.j(function(){(h=c?c(e,b):s.call(k,b,e))&&e.I&&e.I();return h},null,{o:b});h&&p.Z()||(p=null)}var r;if(h){var v=p?function(a){return function(){return d(p()[a])}}:function(a){return h[a]},A=function(){return a.a.na(p?p():h,d)};A.get=function(a){return h[a]&&
d(v(a))};A.has=function(a){return a in h};l=g(h);a.a.u(l,function(c){var d=c.zb.init,g=c.zb.update,l=c.key;if(8===b.nodeType&&!a.f.Q[l])throw Error("The binding '"+l+"' cannot be used with virtual elements");try{"function"==typeof d&&a.k.B(function(){var a=d(b,v(l),A,e.$data,e);if(a&&a.controlsDescendantBindings){if(r!==n)throw Error("Multiple bindings ("+r+" and "+l+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");r=l}}),
"function"==typeof g&&a.j(function(){g(b,v(l),A,e.$data,e)},null,{o:b})}catch(f){throw f.message='Unable to process binding "'+l+": "+h[l]+'"\nMessage: '+f.message,f;}})}return{shouldBindDescendants:r===n}}function l(b){return b&&b instanceof a.N?b:new a.N(b)}a.d={};var s={script:!0};a.getBindingHandler=function(b){return a.d[b]};a.N=function(b,c,d,g){var e=this,l="function"==typeof b&&!a.C(b),f,m=a.j(function(){var f=l?b():b,h=a.a.c(f);c?(c.I&&c.I(),a.a.extend(e,c),m&&(e.I=m)):(e.$parents=[],e.$root=
h,e.ko=a);e.$rawData=f;e.$data=h;d&&(e[d]=h);g&&g(e,c,h);return e.$data},null,{Ia:function(){return f&&!a.a.ob(f)},o:!0});m.Z()&&(e.I=m,m.equalityComparer=null,f=[],m.Tb=function(b){f.push(b);a.a.w.da(b,function(b){a.a.ua(f,b);f.length||(m.K(),e.I=m=n)})})};a.N.prototype.createChildContext=function(b,c,d){return new a.N(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)})};a.N.prototype.extend=function(b){return new a.N(this.I||
this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};var q=a.a.e.F(),p=a.a.e.F();a.Ob=function(b,c){if(2==arguments.length)a.a.e.set(b,p,c),c.I&&c.I.Tb(b);else return a.a.e.get(b,p)};a.ra=function(b,c,d){1===b.nodeType&&a.f.Fb(b);return m(b,c,l(d),!0)};a.Wb=function(b,c,d){d=l(d);return a.ra(b,e(c,d,b),d)};a.Ca=function(a,b){1!==b.nodeType&&8!==b.nodeType||h(l(a),b,!0)};a.pb=function(a,b){!r&&v.jQuery&&(r=v.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
b=b||v.document.body;k(l(a),b,!0)};a.Ha=function(b){switch(b.nodeType){case 1:case 8:var c=a.Ob(b);if(c)return c;if(b.parentNode)return a.Ha(b.parentNode)}return n};a.$b=function(b){return(b=a.Ha(b))?b.$data:n};a.b("bindingHandlers",a.d);a.b("applyBindings",a.pb);a.b("applyBindingsToDescendants",a.Ca);a.b("applyBindingAccessorsToNode",a.ra);a.b("applyBindingsToNode",a.Wb);a.b("contextFor",a.Ha);a.b("dataFor",a.$b)})();(function(b){function d(d,g){var e=f.hasOwnProperty(d)?f[d]:b,l;e||(e=f[d]=new a.P,
c(d,function(a){h[d]=a;delete f[d];l?e.notifySubscribers(a):setTimeout(function(){e.notifySubscribers(a)},0)}),l=!0);e.U(g)}function c(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a)}):b(null)})}function e(c,d,f,l){l||(l=a.g.loaders.slice(0));var h=l.shift();if(h){var q=h[c];if(q){var p=!1;if(q.apply(h,d.concat(function(a){p?f(null):null!==a?f(a):e(c,d,f,l)}))!==b&&(p=!0,!h.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
}else e(c,d,f,l)}else f(null)}var f={},h={};a.g={get:function(a,c){var e=h.hasOwnProperty(a)?h[a]:b;e?setTimeout(function(){c(e)},0):d(a,c)},tb:function(a){delete h[a]},jb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.tb)})();(function(){function b(b,c,d,e){function h(){0===--u&&e(k)}var k={},u=2,t=d.template;d=d.viewModel;t?f(c,t,function(c){a.g.jb("loadTemplate",[b,c],function(a){k.template=a;h()})}):h();d?f(c,d,function(c){a.g.jb("loadViewModel",
[b,c],function(a){k[g]=a;h()})}):h()}function d(a,b,c){if("function"===typeof b)c(function(a){return new b(a)});else if("function"===typeof b[g])c(b[g]);else if("instance"in b){var e=b.instance;c(function(){return e})}else"viewModel"in b?d(a,b.viewModel,c):a("Unknown viewModel value: "+b)}function c(b){switch(a.a.t(b)){case "script":return a.a.ba(b.text);case "textarea":return a.a.ba(b.value);case "template":if(e(b.content))return a.a.ia(b.content.childNodes)}return a.a.ia(b.childNodes)}function e(a){return v.DocumentFragment?
a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?N||v.require?(N||v.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function h(a){return function(b){throw Error("Component '"+a+"': "+b);}}var k={};a.g.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.Qa(b))throw Error("Component "+b+" is already registered");k[b]=c};a.g.Qa=function(a){return a in k};a.g.vc=function(b){delete k[b];a.g.tb(b)};a.g.ub=
{getConfig:function(a,b){b(k.hasOwnProperty(a)?k[a]:null)},loadComponent:function(a,c,d){var e=h(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,d,g){b=h(b);if("string"===typeof d)g(a.a.ba(d));else if(d instanceof Array)g(d);else if(e(d))g(a.a.S(d.childNodes));else if(d.element)if(d=d.element,v.HTMLElement?d instanceof HTMLElement:d&&d.tagName&&1===d.nodeType)g(c(d));else if("string"===typeof d){var f=y.getElementById(d);f?g(c(f)):b("Cannot find element with ID "+d)}else b("Unknown element type: "+
d);else b("Unknown template value: "+d)},loadViewModel:function(a,b,c){d(h(a),b,c)}};var g="createViewModel";a.b("components.register",a.g.register);a.b("components.isRegistered",a.g.Qa);a.b("components.unregister",a.g.vc);a.b("components.defaultLoader",a.g.ub);a.g.loaders.push(a.g.ub);a.g.Ub=k})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=d.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.na(f,function(d){return a.s(d,null,{o:b})}),h=a.a.na(f,function(d){return d.Z()?
a.s(function(){return a.a.c(d())},null,{o:b}):d.v()});h.hasOwnProperty("$raw")||(h.$raw=f);return h}return{$raw:{}}}a.g.getComponentNameForNode=function(b){b=a.a.t(b);return a.g.Qa(b)&&b};a.g.mb=function(c,d,f,h){if(1===d.nodeType){var k=a.g.getComponentNameForNode(d);if(k){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var g={name:k,params:b(d,f)};c.component=h?function(){return g}:g}}return c};var d=new a.J;9>a.a.L&&(a.g.register=
function(a){return function(b){y.createElement(b);return a.apply(this,arguments)}}(a.g.register),y.createDocumentFragment=function(b){return function(){var d=b(),f=a.g.Ub,h;for(h in f)f.hasOwnProperty(h)&&d.createElement(h);return d}}(y.createDocumentFragment))})();(function(){var b=0;a.d.component={init:function(d,c,e,f,h){function k(){var a=g&&g.dispose;"function"===typeof a&&a.call(g);m=null}var g,m;a.a.w.da(d,k);a.s(function(){var e=a.a.c(c()),f,q;"string"===typeof e?f=e:(f=a.a.c(e.name),q=a.a.c(e.params));
if(!f)throw Error("No component name specified");var p=m=++b;a.g.get(f,function(b){if(m===p){k();if(!b)throw Error("Unknown component '"+f+"'");var c=b.template;if(!c)throw Error("Component '"+f+"' has no template");c=a.a.ia(c);a.f.T(d,c);var c=q,e=b.createViewModel;b=e?e.call(b,c,{element:d}):c;c=h.createChildContext(b);g=b;a.Ca(c,d)}})},null,{o:d});return{controlsDescendantBindings:!0}}};a.f.Q.component=!0})();var P={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,d){var c=a.a.c(d())||
{};a.a.G(c,function(c,d){d=a.a.c(d);var h=!1===d||null===d||d===n;h&&b.removeAttribute(c);8>=a.a.L&&c in P?(c=P[c],h?b.removeAttribute(c):b[c]=d):h||b.setAttribute(c,d.toString());"name"===c&&a.a.Mb(b,h?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,d,c){function e(){var e=b.checked,f=s?h():e;if(!a.Y.ma()&&(!g||e)){var k=a.k.B(d);m?l!==f?(e&&(a.a.ea(k,f,!0),a.a.ea(k,l,!1)),l=f):a.a.ea(k,f,e):a.h.pa(k,c,"checked",f,!0)}}function f(){var c=a.a.c(d());b.checked=
m?0<=a.a.m(c,h()):k?c:h()===c}var h=a.Ib(function(){return c.has("checkedValue")?a.a.c(c.get("checkedValue")):c.has("value")?a.a.c(c.get("value")):b.value}),k="checkbox"==b.type,g="radio"==b.type;if(k||g){var m=k&&a.a.c(d())instanceof Array,l=m?h():n,s=g||m;g&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.s(e,null,{o:b});a.a.n(b,"click",e);a.s(f,null,{o:b})}}};a.h.V.checked=!0;a.d.checkedValue={update:function(b,d){b.value=a.a.c(d())}}})();a.d.css={update:function(b,d){var c=a.a.c(d());"object"==
typeof c?a.a.G(c,function(c,d){d=a.a.c(d);a.a.Ba(b,c,d)}):(c=String(c||""),a.a.Ba(b,b.__ko__cssValue,!1),b.__ko__cssValue=c,a.a.Ba(b,c,!0))}};a.d.enable={update:function(b,d){var c=a.a.c(d());c&&b.disabled?b.removeAttribute("disabled"):c||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,d){a.d.enable.update(b,function(){return!a.a.c(d())})}};a.d.event={init:function(b,d,c,e,f){var h=d()||{};a.a.G(h,function(h){"string"==typeof h&&a.a.n(b,h,function(b){var m,l=d()[h];if(l){try{var s=a.a.S(arguments);
e=f.$data;s.unshift(e);m=l.apply(e,s)}finally{!0!==m&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===c.get(h+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={Eb:function(b){return function(){var d=b(),c=a.a.Xa(d);if(!c||"number"==typeof c.length)return{foreach:d,templateEngine:a.O.Oa};a.a.c(d);return{foreach:c.data,as:c.as,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,beforeMove:c.beforeMove,
afterMove:c.afterMove,templateEngine:a.O.Oa}}},init:function(b,d){return a.d.template.init(b,a.d.foreach.Eb(d))},update:function(b,d,c,e,f){return a.d.template.update(b,a.d.foreach.Eb(d),c,e,f)}};a.h.ha.foreach=!1;a.f.Q.foreach=!0;a.d.hasfocus={init:function(b,d,c){function e(e){b.__ko_hasfocusUpdating=!0;var g=b.ownerDocument;if("activeElement"in g){var f;try{f=g.activeElement}catch(h){f=g.body}e=f===b}g=d();a.h.pa(g,c,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=
e.bind(null,!0),h=e.bind(null,!1);a.a.n(b,"focus",f);a.a.n(b,"focusin",f);a.a.n(b,"blur",h);a.a.n(b,"focusout",h)},update:function(b,d){var c=!!a.a.c(d());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===c||(c?b.focus():b.blur(),a.k.B(a.a.oa,null,[b,c?"focusin":"focusout"]))}};a.h.V.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.V.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,d){a.a.$a(b,d())}};I("if");I("ifnot",!1,!0);I("with",!0,!1,function(a,d){return a.createChildContext(d)});
var K={};a.d.options={init:function(b){if("select"!==a.a.t(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,d,c){function e(){return a.a.ta(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function h(c,d){if(s.length){var e=0<=a.a.m(s,a.i.q(d[0]));a.a.Nb(d[0],e);q&&!e&&a.k.B(a.a.oa,null,[b,"change"])}}var k=0!=b.length&&b.multiple?
b.scrollTop:null,g=a.a.c(d()),m=c.get("optionsIncludeDestroyed");d={};var l,s;s=b.multiple?a.a.Da(e(),a.i.q):0<=b.selectedIndex?[a.i.q(b.options[b.selectedIndex])]:[];g&&("undefined"==typeof g.length&&(g=[g]),l=a.a.ta(g,function(b){return m||b===n||null===b||!a.a.c(b._destroy)}),c.has("optionsCaption")&&(g=a.a.c(c.get("optionsCaption")),null!==g&&g!==n&&l.unshift(K)));var q=!1;d.beforeRemove=function(a){b.removeChild(a)};g=h;c.has("optionsAfterRender")&&(g=function(b,d){h(0,d);a.k.B(c.get("optionsAfterRender"),
null,[d[0],b!==K?b:n])});a.a.Za(b,l,function(d,e,g){g.length&&(s=g[0].selected?[a.i.q(g[0])]:[],q=!0);e=b.ownerDocument.createElement("option");d===K?(a.a.bb(e,c.get("optionsCaption")),a.i.ca(e,n)):(g=f(d,c.get("optionsValue"),d),a.i.ca(e,a.a.c(g)),d=f(d,c.get("optionsText"),g),a.a.bb(e,d));return[e]},d,g);a.k.B(function(){c.get("valueAllowUnset")&&c.has("value")?a.i.ca(b,a.a.c(c.get("value")),!0):(b.multiple?s.length&&e().length<s.length:s.length&&0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex])!==
s[0]:s.length||0<=b.selectedIndex)&&a.a.oa(b,"change")});a.a.dc(b);k&&20<Math.abs(k-b.scrollTop)&&(b.scrollTop=k)}};a.d.options.Va=a.a.e.F();a.d.selectedOptions={after:["options","foreach"],init:function(b,d,c){a.a.n(b,"change",function(){var e=d(),f=[];a.a.u(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.i.q(b))});a.h.pa(e,c,"selectedOptions",f)})},update:function(b,d){if("select"!=a.a.t(b))throw Error("values binding applies only to SELECT elements");var c=a.a.c(d());c&&"number"==
typeof c.length&&a.a.u(b.getElementsByTagName("option"),function(b){var d=0<=a.a.m(c,a.i.q(b));a.a.Nb(b,d)})}};a.h.V.selectedOptions=!0;a.d.style={update:function(b,d){var c=a.a.c(d()||{});a.a.G(c,function(c,d){d=a.a.c(d);if(null===d||d===n||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,d,c,e,f){if("function"!=typeof d())throw Error("The value for a submit binding must be a function");a.a.n(b,"submit",function(a){var c,e=d();try{c=e.call(f.$data,b)}finally{!0!==c&&(a.preventDefault?a.preventDefault():
a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,d){a.a.bb(b,d())}};a.f.Q.text=!0;(function(){if(v&&v.navigator)var b=function(a){if(a)return parseFloat(a[1])},d=v.opera&&v.opera.version&&parseInt(v.opera.version()),c=v.navigator.userAgent,e=b(c.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),f=b(c.match(/Firefox\/([^ ]*)/));if(10>a.a.L)var h=a.a.e.F(),k=a.a.e.F(),g=function(b){var c=this.activeElement;(c=c&&a.a.e.get(c,k))&&c(b)},m=function(b,
c){var d=b.ownerDocument;a.a.e.get(d,h)||(a.a.e.set(d,h,!0),a.a.n(d,"selectionchange",g));a.a.e.set(b,k,c)};a.d.textInput={init:function(b,c,g){function h(c,d){a.a.n(b,c,d)}function k(){var d=a.a.c(c());if(null===d||d===n)d="";v!==n&&d===v?setTimeout(k,4):b.value!==d&&(r=d,b.value=d)}function u(){x||(v=b.value,x=setTimeout(t,4))}function t(){clearTimeout(x);v=x=n;var d=b.value;r!==d&&(r=d,a.h.pa(c(),g,"textInput",d))}var r=b.value,x,v;10>a.a.L?(h("propertychange",function(a){"value"===a.propertyName&&
t()}),8==a.a.L&&(h("keyup",t),h("keydown",t)),8<=a.a.L&&(m(b,t),h("dragend",u))):(h("input",t),5>e&&"textarea"===a.a.t(b)?(h("keydown",u),h("paste",u),h("cut",u)):11>d?h("keydown",u):4>f&&(h("DOMAutoComplete",t),h("dragdrop",t),h("drop",t)));h("change",t);a.s(k,null,{o:b})}};a.h.V.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,d){if(d()){var c="ko_unique_"+ ++a.d.uniqueName.Zb;a.a.Mb(b,c)}}};a.d.uniqueName.Zb=0;a.d.value={after:["options",
"foreach"],init:function(b,d,c){if("input"!=b.tagName.toLowerCase()||"checkbox"!=b.type&&"radio"!=b.type){var e=["change"],f=c.get("valueUpdate"),h=!1,k=null;f&&("string"==typeof f&&(f=[f]),a.a.ga(e,f),e=a.a.rb(e));var g=function(){k=null;h=!1;var e=d(),g=a.i.q(b);a.h.pa(e,c,"value",g)};!a.a.L||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.m(e,"propertychange")||(a.a.n(b,"propertychange",function(){h=!0}),a.a.n(b,"focus",function(){h=
!1}),a.a.n(b,"blur",function(){h&&g()}));a.a.u(e,function(c){var d=g;a.a.uc(c,"after")&&(d=function(){k=a.i.q(b);setTimeout(g,0)},c=c.substring(5));a.a.n(b,c,d)});var m=function(){var e=a.a.c(d()),g=a.i.q(b);if(null!==k&&e===k)setTimeout(m,0);else if(e!==g)if("select"===a.a.t(b)){var f=c.get("valueAllowUnset"),g=function(){a.i.ca(b,e,f)};g();f||e===a.i.q(b)?setTimeout(g,0):a.k.B(a.a.oa,null,[b,"change"])}else a.i.ca(b,e)};a.s(m,null,{o:b})}else a.ra(b,{checkedValue:d})},update:function(){}};a.h.V.value=
!0;a.d.visible={update:function(b,d){var c=a.a.c(d()),e="none"!=b.style.display;c&&!e?b.style.display="":!c&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(d,c,e,f,h){return a.d.event.init.call(this,d,function(){var a={};a[b]=c();return a},e,f,h)}}})("click");a.H=function(){};a.H.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.H.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};
a.H.prototype.makeTemplateSource=function(b,d){if("string"==typeof b){d=d||y;var c=d.getElementById(b);if(!c)throw Error("Cannot find template with ID "+b);return new a.r.l(c)}if(1==b.nodeType||8==b.nodeType)return new a.r.fa(b);throw Error("Unknown template type: "+b);};a.H.prototype.renderTemplate=function(a,d,c,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,d,c)};a.H.prototype.isTemplateRewritten=function(a,d){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,
d).data("isRewritten")};a.H.prototype.rewriteTemplate=function(a,d,c){a=this.makeTemplateSource(a,c);d=d(a.text());a.text(d);a.data("isRewritten",!0)};a.b("templateEngine",a.H);a.fb=function(){function b(b,c,d,k){b=a.h.Wa(b);for(var g=a.h.ha,m=0;m<b.length;m++){var l=b[m].key;if(g.hasOwnProperty(l)){var s=g[l];if("function"===typeof s){if(l=s(b[m].value))throw Error(l);}else if(!s)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+
a.h.ya(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return k.createJavaScriptEvaluatorBlock(d)+c}var d=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,c=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{ec:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.fb.nc(b,c)},d)},nc:function(a,f){return a.replace(d,function(a,c,d,e,l){return b(l,c,d,f)}).replace(c,function(a,c){return b(c,
"\x3c!-- ko --\x3e","#comment",f)})},Xb:function(b,c){return a.D.Ua(function(d,k){var g=d.nextSibling;g&&g.nodeName.toLowerCase()===c&&a.ra(g,b,k)})}}}();a.b("__tr_ambtns",a.fb.Xb);(function(){a.r={};a.r.l=function(a){this.l=a};a.r.l.prototype.text=function(){var b=a.a.t(this.l),b="script"===b?"text":"textarea"===b?"value":"innerHTML";if(0==arguments.length)return this.l[b];var d=arguments[0];"innerHTML"===b?a.a.$a(this.l,d):this.l[b]=d};var b=a.a.e.F()+"_";a.r.l.prototype.data=function(c){if(1===
arguments.length)return a.a.e.get(this.l,b+c);a.a.e.set(this.l,b+c,arguments[1])};var d=a.a.e.F();a.r.fa=function(a){this.l=a};a.r.fa.prototype=new a.r.l;a.r.fa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.l,d)||{};b.gb===n&&b.Ga&&(b.gb=b.Ga.innerHTML);return b.gb}a.a.e.set(this.l,d,{gb:arguments[0]})};a.r.l.prototype.nodes=function(){if(0==arguments.length)return(a.a.e.get(this.l,d)||{}).Ga;a.a.e.set(this.l,d,{Ga:arguments[0]})};a.b("templateSources",a.r);a.b("templateSources.domElement",
a.r.l);a.b("templateSources.anonymousTemplate",a.r.fa)})();(function(){function b(b,c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function d(c,d){if(c.length){var e=c[0],f=c[c.length-1],h=e.parentNode,k=a.J.instance,n=k.preprocessNode;if(n){b(e,f,function(a,b){var c=a.previousSibling,d=n.call(k,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):(c.push(e,f),a.a.ka(c,h))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||
a.pb(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.D.Sb(b,[d])});a.a.ka(c,h)}}function c(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,k,q){q=q||{};var p=b&&c(b),p=p&&p.ownerDocument,n=q.templateEngine||h;a.fb.ec(f,n,p);f=n.renderTemplate(f,k,q,p);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");p=!1;switch(e){case "replaceChildren":a.f.T(b,f);p=!0;break;case "replaceNode":a.a.Lb(b,
f);p=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}p&&(d(f,k),q.afterRender&&a.k.B(q.afterRender,null,[f,k.$data]));return f}function f(b,c,d){return a.C(b)?b():"function"===typeof b?b(c,d):b}var h;a.ab=function(b){if(b!=n&&!(b instanceof a.H))throw Error("templateEngine must inherit from ko.templateEngine");h=b};a.Ya=function(b,d,k,s,q){k=k||{};if((k.templateEngine||h)==n)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";
if(s){var p=c(s);return a.j(function(){var h=d&&d instanceof a.N?d:new a.N(a.a.c(d)),n=f(b,h.$data,h),h=e(s,q,n,h,k);"replaceNode"==q&&(s=h,p=c(s))},null,{Ia:function(){return!p||!a.a.Ja(p)},o:p&&"replaceNode"==q?p.parentNode:p})}return a.D.Ua(function(c){a.Ya(b,d,k,c,"replaceNode")})};a.tc=function(b,c,h,k,q){function p(a,b){d(b,u);h.afterRender&&h.afterRender(b,a)}function r(a,c){u=q.createChildContext(a,h.as,function(a){a.$index=c});var d=f(b,a,u);return e(null,"ignoreTargetNode",d,u,h)}var u;
return a.j(function(){var b=a.a.c(c)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.ta(b,function(b){return h.includeDestroyed||b===n||null===b||!a.a.c(b._destroy)});a.k.B(a.a.Za,null,[k,b,r,h,p])},null,{o:k})};var k=a.a.e.F();a.d.template={init:function(b,c){var d=a.a.c(c());"string"==typeof d||d.name?a.f.ja(b):(d=a.f.childNodes(b),d=a.a.oc(d),(new a.r.fa(b)).nodes(d));return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var h=c(),r;c=a.a.c(h);d=!0;e=null;"string"==typeof c?c={}:(h=
c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)),r=a.a.c(c.data));"foreach"in c?e=a.tc(h||b,d&&c.foreach||[],c,b,f):d?(f="data"in c?f.createChildContext(r,c.as):f,e=a.Ya(h||b,f,c,b)):a.f.ja(b);f=e;(r=a.a.e.get(b,k))&&"function"==typeof r.K&&r.K();a.a.e.set(b,k,f&&f.Z()?f:n)}};a.h.ha.template=function(b){b=a.h.Wa(b);return 1==b.length&&b[0].unknown||a.h.lc(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.Q.template=!0})();
a.b("setTemplateEngine",a.ab);a.b("renderTemplate",a.Ya);a.a.wb=function(a,d,c){if(a.length&&d.length){var e,f,h,k,g;for(e=f=0;(!c||e<c)&&(k=a[f]);++f){for(h=0;g=d[h];++h)if(k.value===g.value){k.moved=g.index;g.moved=k.index;d.splice(h,1);e=h=0;break}e+=h}}};a.a.Fa=function(){function b(b,c,e,f,h){var k=Math.min,g=Math.max,m=[],l,n=b.length,q,p=c.length,r=p-n||1,u=n+p+1,t,v,x;for(l=0;l<=n;l++)for(v=t,m.push(t=[]),x=k(p,l+r),q=g(0,l-1);q<=x;q++)t[q]=q?l?b[l-1]===c[q-1]?v[q-1]:k(v[q]||u,t[q-1]||u)+
1:q+1:l+1;k=[];g=[];r=[];l=n;for(q=p;l||q;)p=m[l][q]-1,q&&p===m[l][q-1]?g.push(k[k.length]={status:e,value:c[--q],index:q}):l&&p===m[l-1][q]?r.push(k[k.length]={status:f,value:b[--l],index:l}):(--q,--l,h.sparse||k.push({status:"retained",value:c[q]}));a.a.wb(g,r,10*n);return k.reverse()}return function(a,c,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];c=c||[];return a.length<=c.length?b(a,c,"added","deleted",e):b(c,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Fa);(function(){function b(b,
d,f,h,k){var g=[],m=a.j(function(){var l=d(f,k,a.a.ka(g,b))||[];0<g.length&&(a.a.Lb(g,l),h&&a.k.B(h,null,[f,l,k]));g.length=0;a.a.ga(g,l)},null,{o:b,Ia:function(){return!a.a.ob(g)}});return{$:g,j:m.Z()?m:n}}var d=a.a.e.F();a.a.Za=function(c,e,f,h,k){function g(b,d){w=s[d];t!==d&&(y[b]=w);w.Na(t++);a.a.ka(w.$,c);r.push(w);x.push(w)}function m(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.u(c[d].$,function(a){b(a,d,c[d].sa)})}e=e||[];h=h||{};var l=a.a.e.get(c,d)===n,s=a.a.e.get(c,d)||[],q=a.a.Da(s,
function(a){return a.sa}),p=a.a.Fa(q,e,h.dontLimitMoves),r=[],u=0,t=0,v=[],x=[];e=[];for(var y=[],q=[],w,C=0,B,D;B=p[C];C++)switch(D=B.moved,B.status){case "deleted":D===n&&(w=s[u],w.j&&w.j.K(),v.push.apply(v,a.a.ka(w.$,c)),h.beforeRemove&&(e[C]=w,x.push(w)));u++;break;case "retained":g(C,u++);break;case "added":D!==n?g(C,D):(w={sa:B.value,Na:a.p(t++)},r.push(w),x.push(w),l||(q[C]=w))}m(h.beforeMove,y);a.a.u(v,h.beforeRemove?a.R:a.removeNode);for(var C=0,l=a.f.firstChild(c),F;w=x[C];C++){w.$||a.a.extend(w,
b(c,f,w.sa,k,w.Na));for(u=0;p=w.$[u];l=p.nextSibling,F=p,u++)p!==l&&a.f.Bb(c,p,F);!w.ic&&k&&(k(w.sa,w.$,w.Na),w.ic=!0)}m(h.beforeRemove,e);m(h.afterMove,y);m(h.afterAdd,q);a.a.e.set(c,d,r)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Za);a.O=function(){this.allowTemplateRewriting=!1};a.O.prototype=new a.H;a.O.prototype.renderTemplateSource=function(b){var d=(9>a.a.L?0:b.nodes)?b.nodes():null;if(d)return a.a.S(d.cloneNode(!0).childNodes);b=b.text();return a.a.ba(b)};a.O.Oa=new a.O;a.ab(a.O.Oa);
a.b("nativeTemplateEngine",a.O);(function(){a.Sa=function(){var a=this.kc=function(){if(!r||!r.tmpl)return 0;try{if(0<=r.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,f){f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=r.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));
b=[e.$data];e=r.extend({koBindingContext:e},f.templateOptions);e=r.tmpl(h,b,e);e.appendTo(y.createElement("div"));r.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){y.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(r.tmpl.tag.ko_code={open:"__.push($1 || '');"},r.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.Sa.prototype=new a.H;var b=new a.Sa;0<b.kc&&a.ab(b);a.b("jqueryTmplTemplateEngine",
a.Sa)})()})})();})();


;!function(a,b){"use strict";"object"==typeof exports?b(exports,require("jquery"),require("knockout"),require("jquery-ui")):"function"==typeof define&&define.amd?define(["exports","jquery","knockout","jquery-ui"],b):b(a.kojqui={},a.jQuery,a.ko)}(this,function(a,b,c){"use strict";var d,e;d=function(){var a,d,e,f;return a=function(a){var b=(a||"").match(/^(\d)\.(\d+)\..*$/);return b?{major:parseInt(b[1],10),minor:parseInt(b[2],10)}:null},d=b&&b.fn?a(b.fn.jquery):null,e=b&&b.ui?a(b.ui.version):null,f=c?a(c.version):null,{jQuery:d,jQueryUI:e,knockout:f}}(),function(){if(!d.jQuery)throw new Error("jQuery must be loaded before knockout-jquery.");if(!d.jQueryUI)throw new Error("jQuery UI must be loaded before knockout-jquery.");if(!d.knockout)throw new Error("knockout must be loaded before knockout-jquery.");if(d.jQueryUI.major<1||1===d.jQueryUI.major&&d.jQueryUI.minor<8)throw new Error("This version of the jQuery UI library is not supported.");if(d.knockout.major<2||2===d.knockout.major&&d.knockout.minor<2)throw new Error("This version of the knockout library is not supported.")}(),e=function(){var a,d,e,f;return a="__kojqui_options",d=function(a,b){var d={};return c.utils.arrayForEach(b,function(b){void 0!==a[b]&&(d[b]=c.utils.unwrapObservable(a[b]))}),d},e=function(a,d,e){c.isObservable(e.refreshOn)&&c.computed({read:function(){e.refreshOn(),b(d)[a]("refresh")},disposeWhenNodeIsRemoved:d})},f=function(f){var g,h,i;g=f.name,b.fn[g]&&(h=function(h,i,j,k,l){var m,n,o,p;return m=i(),o=d(m,f.options),p=d(m,f.events),n=arguments,c.utils.arrayForEach(c.bindingHandlers[g].preInitHandlers,function(a){a.apply(this,n)}),c.applyBindingsToDescendants(l,h),c.utils.domData.set(h,a,o),b.each(p,function(a,b){p[a]=b.bind(k)}),b(h)[g](c.utils.extend(o,p)),f.hasRefresh&&e(g,h,m),c.isWriteableObservable(m.widget)&&m.widget(b(h)),c.utils.domNodeDisposal.addDisposeCallback(h,function(){b(h)[g]("destroy")}),c.utils.arrayForEach(c.bindingHandlers[g].postInitHandlers,function(a){a.apply(this,n)}),{controlsDescendantBindings:!0}},i=function(e,h){var i,j,k;i=h(),j=c.utils.domData.get(e,a),k=d(i,f.options),b.each(k,function(a,c){c!==j[a]&&b(e)[g]("option",a,k[a])}),c.utils.domData.set(e,a,k)},c.bindingHandlers[g]={init:h,update:i,config:f,preInitHandlers:[],postInitHandlers:[]},f.preInit&&c.bindingHandlers[g].preInitHandlers.push(f.preInit),f.postInit&&c.bindingHandlers[g].postInitHandlers.push(f.postInit))},{create:f}}(),function(){var a,f,g,h,i;f=function(d,e){var f=e();c.isWriteableObservable(f.active)&&b(d).on(a,function(){f.active(b(d).accordion("option","active"))}),c.utils.domNodeDisposal.addDisposeCallback(d,function(){b(d).off(".accordion")})},1===d.jQueryUI.major&&8===d.jQueryUI.minor?(g=["active","animated","autoHeight","clearStyle","collapsible","disabled","event","fillSpace","header","icons","navigation","navigationFilter"],h=["change","changestart","create"],i=!1,a="accordionchange.accordion"):(g=["active","animate","collapsible","disabled","event","header","heightStyle","icons"],h=["activate","beforeActivate","create"],i=!0,a="accordionactivate.accordion"),e.create({name:"accordion",options:g,events:h,postInit:f,hasRefresh:i})}(),function(){var a;a=1===d.jQueryUI.major&&8===d.jQueryUI.minor?["change","close","create","focus","open","search","select"]:["change","close","create","focus","open","response","search","select"],e.create({name:"autocomplete",options:["appendTo","autoFocus","delay","disabled","minLength","position","source"],events:a})}(),function(){e.create({name:"button",options:["disabled","icons","label","text"],events:["create"],hasRefresh:!0})}(),function(){e.create({name:"buttonset",options:["items","disabled"],events:["create"],hasRefresh:!0})}(),function(){var a;a=function(a,d){var e,f,g,h;e=d(),f=c.utils.unwrapObservable(e.value),f&&b(a).datepicker("setDate",f),c.isObservable(e.value)&&(g=e.value.subscribe(function(c){b(a).datepicker("setDate",c)}),c.utils.domNodeDisposal.addDisposeCallback(a,function(){g.dispose()})),c.isWriteableObservable(e.value)&&(h=b(a).datepicker("option","onSelect"),b(a).datepicker("option","onSelect",function(c){var d,f;d=b(a).datepicker("option","dateFormat"),f=b.datepicker.parseDate(d,c),e.value(f),"function"==typeof h&&h.apply(this,Array.prototype.slice.call(arguments))}))},e.create({name:"datepicker",options:["altField","altFormat","appendText","autoSize","buttonImage","buttonImageOnly","buttonText","calculateWeek","changeMonth","changeYear","closeText","constrainInput","currentText","dateFormat","dayNames","dayNamesMin","dayNamesShort","defaultDate","duration","firstDay","gotoCurrent","hideIfNoPrevNext","isRTL","maxDate","minDate","monthNames","monthNamesShort","navigationAsDateFormat","nextText","numberOfMonths","prevText","selectOtherMonths","shortYearCutoff","showAnim","showButtonPanel","showCurrentAtPos","showMonthAfterYear","showOn","showOptions","showOtherMonths","showWeek","stepMonths","weekHeader","yearRange","yearSuffix","beforeShow","beforeShowDay","onChangeMonthYear","onClose","onSelect"],events:[],postInit:a})}(),function(){var a,f,g,h;a=function(a){var b;b=document.createElement("DIV"),b.style.display="none",a.parentNode.insertBefore(b,a),c.utils.domNodeDisposal.addDisposeCallback(b,function(){c.removeNode(a)})},f=function(a,d){var e=d();e.isOpen&&c.computed({read:function(){c.utils.unwrapObservable(e.isOpen)?b(a).dialog("open"):b(a).dialog("close")},disposeWhenNodeIsRemoved:a}),c.isWriteableObservable(e.isOpen)&&(b(a).on("dialogopen.dialog",function(){e.isOpen(!0)}),b(a).on("dialogclose.dialog",function(){e.isOpen(!1)})),c.utils.domNodeDisposal.addDisposeCallback(a,function(){b(a).off(".dialog")})},1===d.jQueryUI.major&&8===d.jQueryUI.minor?(g=["autoOpen","buttons","closeOnEscape","closeText","dialogClass","disabled","draggable","height","maxHeight","maxWidth","minHeight","minWidth","modal","position","resizable","show","stack","title","width","zIndex"],h=["beforeClose","create","open","focus","dragStart","drag","dragStop","resizeStart","resize","resizeStop","close"]):1===d.jQueryUI.major&&9===d.jQueryUI.minor?(g=["autoOpen","buttons","closeOnEscape","closeText","dialogClass","draggable","height","hide","maxHeight","maxWidth","minHeight","minWidth","modal","position","resizable","show","stack","title","width","zIndex"],h=["beforeClose","create","open","focus","dragStart","drag","dragStop","resizeStart","resize","resizeStop","close"]):(g=["appendTo","autoOpen","buttons","closeOnEscape","closeText","dialogClass","draggable","height","hide","maxHeight","maxWidth","minHeight","minWidth","modal","position","resizable","show","title","width"],h=["beforeClose","create","open","focus","dragStart","drag","dragStop","resizeStart","resize","resizeStop","close"]),e.create({name:"dialog",options:g,events:h,preInit:a,postInit:f})}(),function(){e.create({name:"menu",options:["disabled","icons","menus","position","role"],events:["blur","create","focus","select"],hasRefresh:!0})}(),function(){var a;a=1===d.jQueryUI.major&&8===d.jQueryUI.minor?["disabled","value"]:["disabled","max","value"],e.create({name:"progressbar",options:a,events:["change","create","complete"]})}(),function(){var a;a=function(a,d){var e=d();c.isWriteableObservable(e.value)&&b(a).on("slidechange.slider",function(c,d){var f=b(a).find(".ui-slider-handle");f[0]===d.handle&&e.value(d.value)}),c.utils.domNodeDisposal.addDisposeCallback(a,function(){b(a).off(".slider")})},e.create({name:"slider",options:["animate","disabled","max","min","orientation","range","step","value","values"],events:["create","start","slide","change","stop"],postInit:a})}(),function(){var a;a=function(a,d,e){var f=d();f.value&&c.computed({read:function(){b(a).spinner("value",c.utils.unwrapObservable(f.value))},disposeWhenNodeIsRemoved:a}),c.isWriteableObservable(f.value)&&(e().valueUpdate?b(a).on("spin.spinner",function(a,b){f.value(b.value)}):b(a).on("spinchange.spinner",function(){f.value(b(a).spinner("value"))})),c.utils.domNodeDisposal.addDisposeCallback(a,function(){b(a).off(".spinner")})},e.create({name:"spinner",options:["culture","disabled","icons","incremental","max","min","numberFormat","page","step"],events:["create","start","spin","stop","change"],postInit:a})}(),function(){var a,f,g,h,i,j;a=function(a,d){var e=d();c.isWriteableObservable(e.selected)&&b(a).on("tabsshow.tabs",function(c,d){b(a)[0]===c.target&&e.selected(d.index)}),c.utils.domNodeDisposal.addDisposeCallback(a,function(){b(a).off(".tabs")})},f=function(a,d){var e=d();c.isWriteableObservable(e.active)&&b(a).on("tabsactivate.tabs",function(c,d){b(a)[0]===c.target&&e.active(d.newTab.index())}),c.utils.domNodeDisposal.addDisposeCallback(a,function(){b(a).off(".tabs")})},1===d.jQueryUI.major&&8===d.jQueryUI.minor?(g=["ajaxOptions","cache","collapsible","cookie","disabled","event","fx","idPrefix","panelTemplate","selected","spinner","tabTemplate"],h=["add","create","disable","enable","load","remove","select","show"],j=a,i=!1):(g=["active","collapsible","disabled","event","heightStyle","hide","show"],h=["activate","beforeActivate","beforeLoad","create","load"],j=f,i=!0),e.create({name:"tabs",options:g,events:h,postInit:j,hasRefresh:i})}(),function(){var a;a=function(a,d){var e=d();e.isOpen&&c.computed({read:function(){c.utils.unwrapObservable(e.isOpen)?b(a).tooltip("open"):b(a).tooltip("close")},disposeWhenNodeIsRemoved:a}),c.isWriteableObservable(e.isOpen)&&(b(a).on("tooltipopen.tooltip",function(){e.isOpen(!0)}),b(a).on("tooltipclose.tooltip",function(){e.isOpen(!1)})),c.utils.domNodeDisposal.addDisposeCallback(a,function(){b(a).off(".tooltip")})},e.create({name:"tooltip",options:["content","disabled","hide","items","position","show","tooltipClass","track"],events:["create","open","close"],postInit:a})}(),a.bindingFactory=e,a.version="1.0.0"});

;// knockout-sortable 1.1.0 | (c) 2017 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
!function(a){if("function"==typeof define&&define.amd)define(["knockout","jquery","jquery-ui/ui/widgets/sortable","jquery-ui/ui/widgets/draggable","jquery-ui/ui/widgets/droppable"],a);else if("function"==typeof require&&"object"==typeof exports&&"object"==typeof module){var b=require("knockout"),c=require("jquery");require("jquery-ui/ui/widgets/sortable"),require("jquery-ui/ui/widgets/draggable"),require("jquery-ui/ui/widgets/droppable"),a(b,c)}else a(window.ko,window.jQuery)}(function(a,b){var c="ko_sortItem",d="ko_sourceIndex",e="ko_sortList",f="ko_parentList",g="ko_dragItem",h=a.utils.unwrapObservable,i=a.utils.domData.get,j=a.utils.domData.set,k=b.ui&&b.ui.version,l=k&&k.indexOf("1.6.")&&k.indexOf("1.7.")&&(k.indexOf("1.8.")||"1.8.24"===k),m=function(b,d){a.utils.arrayForEach(b,function(a){1===a.nodeType&&(j(a,c,d),j(a,f,i(a.parentNode,e)))})},n=function(b,c){var d,e={},f=h(b())||{};return f.data?(e[c]=f.data,e.name=f.template):e[c]=b(),a.utils.arrayForEach(["afterAdd","afterRender","as","beforeRemove","includeDestroyed","templateEngine","templateOptions","nodes"],function(b){f.hasOwnProperty(b)?e[b]=f[b]:a.bindingHandlers.sortable.hasOwnProperty(b)&&(e[b]=a.bindingHandlers.sortable[b])}),"foreach"===c&&(e.afterRender?(d=e.afterRender,e.afterRender=function(a,b){m.call(b,a,b),d.call(b,a,b)}):e.afterRender=m),e},o=function(a,b){var c=h(b);if(c)for(var d=0;d<a;d++)c[d]&&h(c[d]._destroy)&&a++;return a},p=function(c,d){var e,f;d?(f=document.getElementById(d),f&&(e=new a.templateSources.domElement(f),e.text(b.trim(e.text())))):b(c).contents().each(function(){this&&1!==this.nodeType&&c.removeChild(this)})};a.bindingHandlers.sortable={init:function(k,m,q,r,s){var t,u,v=b(k),w=h(m())||{},x=n(m,"foreach"),y={};p(k,x.name),b.extend(!0,y,a.bindingHandlers.sortable),w.options&&y.options&&(a.utils.extend(y.options,w.options),delete w.options),a.utils.extend(y,w),y.connectClass&&(a.isObservable(y.allowDrop)||"function"==typeof y.allowDrop)?a.computed({read:function(){var b=h(y.allowDrop),c="function"==typeof b?b.call(this,x.foreach):b;a.utils.toggleDomNodeCssClass(k,y.connectClass,c)},disposeWhenNodeIsRemoved:k},this):a.utils.toggleDomNodeCssClass(k,y.connectClass,y.allowDrop),a.bindingHandlers.template.init(k,function(){return x},q,r,s),t=y.options.start,u=y.options.update,y.options.helper||(y.options.helper=function(a,c){return c.is("tr")&&c.children().each(function(){b(this).width(b(this).width())}),c});var z=setTimeout(function(){var m,n=y.options.receive;v.sortable(a.utils.extend(y.options,{start:function(b,c){var e=c.item[0];j(e,d,a.utils.arrayIndexOf(c.item.parent().children(),e)),c.item.find("input:focus").change(),t&&t.apply(this,arguments)},receive:function(a,b){"function"==typeof n&&n.call(this,a,b),m=i(b.item[0],g),m&&(m.clone&&(m=m.clone()),y.dragged&&(m=y.dragged.call(this,m,a,b)||m))},update:function(g,k){var n,p,q,r,s,t=k.item[0],v=k.item.parent()[0],w=i(t,c)||m;if(w||b(t).remove(),m=null,w&&this===v||!l&&b.contains(this,v)){if(n=i(t,f),q=i(t,d),p=i(t.parentNode,e),r=a.utils.arrayIndexOf(k.item.parent().children(),t),x.includeDestroyed||(q=o(q,n),r=o(r,p)),(y.beforeMove||y.afterMove)&&(s={item:w,sourceParent:n,sourceParentNode:n&&k.sender||t.parentNode,sourceIndex:q,targetParent:p,targetIndex:r,cancelDrop:!1},y.beforeMove&&y.beforeMove.call(this,s,g,k)),n?b(n===p?this:k.sender||this).sortable("cancel"):b(t).remove(),s&&s.cancelDrop)return;if(y.hasOwnProperty("strategyMove")&&y.strategyMove!==!1){if(r>=0)if(n)if(n!==p)n.splice(q,1),p.splice(r,0,w),j(t,c,null),k.item.remove();else{var z=h(n);n.valueWillMutate&&n.valueWillMutate(),z.splice(q,1),z.splice(r,0,w),n.valueHasMutated&&n.valueHasMutated()}else p.splice(r,0,w),j(t,c,null),k.item.remove()}else r>=0&&(n&&(n.splice(q,1),a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates(),a.options&&a.options.deferUpdates&&a.tasks.runEarly()),p.splice(r,0,w)),j(t,c,null);a.processAllDeferredBindingUpdates&&a.processAllDeferredBindingUpdates(),y.afterMove&&y.afterMove.call(this,s,g,k)}u&&u.apply(this,arguments)},connectWith:!!y.connectClass&&"."+y.connectClass})),void 0!==y.isEnabled&&a.computed({read:function(){v.sortable(h(y.isEnabled)?"enable":"disable")},disposeWhenNodeIsRemoved:k})},0);return a.utils.domNodeDisposal.addDisposeCallback(k,function(){(v.data("ui-sortable")||v.data("sortable"))&&v.sortable("destroy"),a.utils.toggleDomNodeCssClass(k,y.connectClass,!1),clearTimeout(z)}),{controlsDescendantBindings:!0}},update:function(b,c,d,f,g){var h=n(c,"foreach");j(b,e,h.foreach),a.bindingHandlers.template.update(b,function(){return h},d,f,g)},connectClass:"ko_container",allowDrop:!0,afterMove:null,beforeMove:null,options:{}},a.bindingHandlers.draggable={init:function(c,d,e,f,i){var k=h(d())||{},l=k.options||{},m=a.utils.extend({},a.bindingHandlers.draggable.options),o=n(d,"data"),p=k.connectClass||a.bindingHandlers.draggable.connectClass,q=void 0!==k.isEnabled?k.isEnabled:a.bindingHandlers.draggable.isEnabled;return k="data"in k?k.data:k,j(c,g,k),a.utils.extend(m,l),m.connectToSortable=!!p&&"."+p,b(c).draggable(m),void 0!==q&&a.computed({read:function(){b(c).draggable(h(q)?"enable":"disable")},disposeWhenNodeIsRemoved:c}),a.utils.domNodeDisposal.addDisposeCallback(c,function(){b(c).draggable("destroy")}),a.bindingHandlers.template.init(c,function(){return o},e,f,i)},update:function(b,c,d,e,f){var g=n(c,"data");return a.bindingHandlers.template.update(b,function(){return g},d,e,f)},connectClass:a.bindingHandlers.sortable.connectClass,options:{helper:"clone"}},a.bindingHandlers.droppable={init:function(d,e,f,j,k){var l=h(e())||{},m=l.options||{},n=a.utils.extend({},a.bindingHandlers.droppable.options),o=void 0!==l.isEnabled?l.isEnabled:a.bindingHandlers.droppable.isEnabled;a.utils.extend(n,m),l="data"in l?l.data:e(),n.drop=function(a,b){var d=i(b.draggable[0],g)||i(b.draggable[0],c);l(d)},b(d).droppable(n),void 0!==o&&a.computed({read:function(){b(d).droppable(h(o)?"enable":"disable")},disposeWhenNodeIsRemoved:d}),a.utils.domNodeDisposal.addDisposeCallback(d,function(){b(d).droppable("destroy")})},options:{accept:"*"}}});

;"use strict";/*!-----------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.32.0-dev.20220110(a06afb22ce06dbd4f01d3bb5bf946e08bff55180)
 * Released under the MIT license
 * https://github.com/microsoft/vscode/blob/main/LICENSE.txt
 *-----------------------------------------------------------*/var _amdLoaderGlobal=this,_commonjsGlobal=typeof global=="object"?global:{},AMDLoader;(function(l){l.global=_amdLoaderGlobal;var E=function(){function v(){this._detected=!1,this._isWindows=!1,this._isNode=!1,this._isElectronRenderer=!1,this._isWebWorker=!1,this._isElectronNodeIntegrationWebWorker=!1}return Object.defineProperty(v.prototype,"isWindows",{get:function(){return this._detect(),this._isWindows},enumerable:!1,configurable:!0}),Object.defineProperty(v.prototype,"isNode",{get:function(){return this._detect(),this._isNode},enumerable:!1,configurable:!0}),Object.defineProperty(v.prototype,"isElectronRenderer",{get:function(){return this._detect(),this._isElectronRenderer},enumerable:!1,configurable:!0}),Object.defineProperty(v.prototype,"isWebWorker",{get:function(){return this._detect(),this._isWebWorker},enumerable:!1,configurable:!0}),Object.defineProperty(v.prototype,"isElectronNodeIntegrationWebWorker",{get:function(){return this._detect(),this._isElectronNodeIntegrationWebWorker},enumerable:!1,configurable:!0}),v.prototype._detect=function(){this._detected||(this._detected=!0,this._isWindows=v._isWindows(),this._isNode=typeof module!="undefined"&&!!module.exports,this._isElectronRenderer=typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.electron!="undefined"&&process.type==="renderer",this._isWebWorker=typeof l.global.importScripts=="function",this._isElectronNodeIntegrationWebWorker=this._isWebWorker&&typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.electron!="undefined"&&process.type==="worker")},v._isWindows=function(){return typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.indexOf("Windows")>=0?!0:typeof process!="undefined"?process.platform==="win32":!1},v}();l.Environment=E})(AMDLoader||(AMDLoader={}));var AMDLoader;(function(l){var E=function(){function a(n,_,s){this.type=n,this.detail=_,this.timestamp=s}return a}();l.LoaderEvent=E;var v=function(){function a(n){this._events=[new E(1,"",n)]}return a.prototype.record=function(n,_){this._events.push(new E(n,_,l.Utilities.getHighPerformanceTimestamp()))},a.prototype.getEvents=function(){return this._events},a}();l.LoaderEventRecorder=v;var g=function(){function a(){}return a.prototype.record=function(n,_){},a.prototype.getEvents=function(){return[]},a.INSTANCE=new a,a}();l.NullLoaderEventRecorder=g})(AMDLoader||(AMDLoader={}));var AMDLoader;(function(l){var E=function(){function v(){}return v.fileUriToFilePath=function(g,a){if(a=decodeURI(a).replace(/%23/g,"#"),g){if(/^file:\/\/\//.test(a))return a.substr(8);if(/^file:\/\//.test(a))return a.substr(5)}else if(/^file:\/\//.test(a))return a.substr(7);return a},v.startsWith=function(g,a){return g.length>=a.length&&g.substr(0,a.length)===a},v.endsWith=function(g,a){return g.length>=a.length&&g.substr(g.length-a.length)===a},v.containsQueryString=function(g){return/^[^\#]*\?/gi.test(g)},v.isAbsolutePath=function(g){return/^((http:\/\/)|(https:\/\/)|(file:\/\/)|(\/))/.test(g)},v.forEachProperty=function(g,a){if(g){var n=void 0;for(n in g)g.hasOwnProperty(n)&&a(n,g[n])}},v.isEmpty=function(g){var a=!0;return v.forEachProperty(g,function(){a=!1}),a},v.recursiveClone=function(g){if(!g||typeof g!="object"||g instanceof RegExp||!Array.isArray(g)&&Object.getPrototypeOf(g)!==Object.prototype)return g;var a=Array.isArray(g)?[]:{};return v.forEachProperty(g,function(n,_){_&&typeof _=="object"?a[n]=v.recursiveClone(_):a[n]=_}),a},v.generateAnonymousModule=function(){return"===anonymous"+v.NEXT_ANONYMOUS_ID+++"==="},v.isAnonymousModule=function(g){return v.startsWith(g,"===anonymous")},v.getHighPerformanceTimestamp=function(){return this.PERFORMANCE_NOW_PROBED||(this.PERFORMANCE_NOW_PROBED=!0,this.HAS_PERFORMANCE_NOW=l.global.performance&&typeof l.global.performance.now=="function"),this.HAS_PERFORMANCE_NOW?l.global.performance.now():Date.now()},v.NEXT_ANONYMOUS_ID=1,v.PERFORMANCE_NOW_PROBED=!1,v.HAS_PERFORMANCE_NOW=!1,v}();l.Utilities=E})(AMDLoader||(AMDLoader={}));var AMDLoader;(function(l){function E(a){if(a instanceof Error)return a;var n=new Error(a.message||String(a)||"Unknown Error");return a.stack&&(n.stack=a.stack),n}l.ensureError=E;var v=function(){function a(){}return a.validateConfigurationOptions=function(n){function _(e){if(e.phase==="loading"){console.error('Loading "'+e.moduleId+'" failed'),console.error(e),console.error("Here are the modules that depend on it:"),console.error(e.neededBy);return}if(e.phase==="factory"){console.error('The factory method of "'+e.moduleId+'" has thrown an exception'),console.error(e);return}}if(n=n||{},typeof n.baseUrl!="string"&&(n.baseUrl=""),typeof n.isBuild!="boolean"&&(n.isBuild=!1),typeof n.paths!="object"&&(n.paths={}),typeof n.config!="object"&&(n.config={}),typeof n.catchError=="undefined"&&(n.catchError=!1),typeof n.recordStats=="undefined"&&(n.recordStats=!1),typeof n.urlArgs!="string"&&(n.urlArgs=""),typeof n.onError!="function"&&(n.onError=_),Array.isArray(n.ignoreDuplicateModules)||(n.ignoreDuplicateModules=[]),n.baseUrl.length>0&&(l.Utilities.endsWith(n.baseUrl,"/")||(n.baseUrl+="/")),typeof n.cspNonce!="string"&&(n.cspNonce=""),typeof n.preferScriptTags=="undefined"&&(n.preferScriptTags=!1),Array.isArray(n.nodeModules)||(n.nodeModules=[]),n.nodeCachedData&&typeof n.nodeCachedData=="object"&&(typeof n.nodeCachedData.seed!="string"&&(n.nodeCachedData.seed="seed"),(typeof n.nodeCachedData.writeDelay!="number"||n.nodeCachedData.writeDelay<0)&&(n.nodeCachedData.writeDelay=1e3*7),!n.nodeCachedData.path||typeof n.nodeCachedData.path!="string")){var s=E(new Error("INVALID cached data configuration, 'path' MUST be set"));s.phase="configuration",n.onError(s),n.nodeCachedData=void 0}return n},a.mergeConfigurationOptions=function(n,_){n===void 0&&(n=null),_===void 0&&(_=null);var s=l.Utilities.recursiveClone(_||{});return l.Utilities.forEachProperty(n,function(e,t){e==="ignoreDuplicateModules"&&typeof s.ignoreDuplicateModules!="undefined"?s.ignoreDuplicateModules=s.ignoreDuplicateModules.concat(t):e==="paths"&&typeof s.paths!="undefined"?l.Utilities.forEachProperty(t,function(r,i){return s.paths[r]=i}):e==="config"&&typeof s.config!="undefined"?l.Utilities.forEachProperty(t,function(r,i){return s.config[r]=i}):s[e]=l.Utilities.recursiveClone(t)}),a.validateConfigurationOptions(s)},a}();l.ConfigurationOptionsUtil=v;var g=function(){function a(n,_){if(this._env=n,this.options=v.mergeConfigurationOptions(_),this._createIgnoreDuplicateModulesMap(),this._createNodeModulesMap(),this._createSortedPathsRules(),this.options.baseUrl===""){if(this.options.nodeRequire&&this.options.nodeRequire.main&&this.options.nodeRequire.main.filename&&this._env.isNode){var s=this.options.nodeRequire.main.filename,e=Math.max(s.lastIndexOf("/"),s.lastIndexOf("\\"));this.options.baseUrl=s.substring(0,e+1)}if(this.options.nodeMain&&this._env.isNode){var s=this.options.nodeMain,e=Math.max(s.lastIndexOf("/"),s.lastIndexOf("\\"));this.options.baseUrl=s.substring(0,e+1)}}}return a.prototype._createIgnoreDuplicateModulesMap=function(){this.ignoreDuplicateModulesMap={};for(var n=0;n<this.options.ignoreDuplicateModules.length;n++)this.ignoreDuplicateModulesMap[this.options.ignoreDuplicateModules[n]]=!0},a.prototype._createNodeModulesMap=function(){this.nodeModulesMap=Object.create(null);for(var n=0,_=this.options.nodeModules;n<_.length;n++){var s=_[n];this.nodeModulesMap[s]=!0}},a.prototype._createSortedPathsRules=function(){var n=this;this.sortedPathsRules=[],l.Utilities.forEachProperty(this.options.paths,function(_,s){Array.isArray(s)?n.sortedPathsRules.push({from:_,to:s}):n.sortedPathsRules.push({from:_,to:[s]})}),this.sortedPathsRules.sort(function(_,s){return s.from.length-_.from.length})},a.prototype.cloneAndMerge=function(n){return new a(this._env,v.mergeConfigurationOptions(n,this.options))},a.prototype.getOptionsLiteral=function(){return this.options},a.prototype._applyPaths=function(n){for(var _,s=0,e=this.sortedPathsRules.length;s<e;s++)if(_=this.sortedPathsRules[s],l.Utilities.startsWith(n,_.from)){for(var t=[],r=0,i=_.to.length;r<i;r++)t.push(_.to[r]+n.substr(_.from.length));return t}return[n]},a.prototype._addUrlArgsToUrl=function(n){return l.Utilities.containsQueryString(n)?n+"&"+this.options.urlArgs:n+"?"+this.options.urlArgs},a.prototype._addUrlArgsIfNecessaryToUrl=function(n){return this.options.urlArgs?this._addUrlArgsToUrl(n):n},a.prototype._addUrlArgsIfNecessaryToUrls=function(n){if(this.options.urlArgs)for(var _=0,s=n.length;_<s;_++)n[_]=this._addUrlArgsToUrl(n[_]);return n},a.prototype.moduleIdToPaths=function(n){if(this._env.isNode){var _=this.nodeModulesMap[n]===!0||this.options.amdModulesPattern instanceof RegExp&&!this.options.amdModulesPattern.test(n);if(_)return this.isBuild()?["empty:"]:["node|"+n]}var s=n,e;if(!l.Utilities.endsWith(s,".js")&&!l.Utilities.isAbsolutePath(s)){e=this._applyPaths(s);for(var t=0,r=e.length;t<r;t++)this.isBuild()&&e[t]==="empty:"||(l.Utilities.isAbsolutePath(e[t])||(e[t]=this.options.baseUrl+e[t]),!l.Utilities.endsWith(e[t],".js")&&!l.Utilities.containsQueryString(e[t])&&(e[t]=e[t]+".js"))}else!l.Utilities.endsWith(s,".js")&&!l.Utilities.containsQueryString(s)&&(s=s+".js"),e=[s];return this._addUrlArgsIfNecessaryToUrls(e)},a.prototype.requireToUrl=function(n){var _=n;return l.Utilities.isAbsolutePath(_)||(_=this._applyPaths(_)[0],l.Utilities.isAbsolutePath(_)||(_=this.options.baseUrl+_)),this._addUrlArgsIfNecessaryToUrl(_)},a.prototype.isBuild=function(){return this.options.isBuild},a.prototype.isDuplicateMessageIgnoredFor=function(n){return this.ignoreDuplicateModulesMap.hasOwnProperty(n)},a.prototype.getConfigForModule=function(n){if(this.options.config)return this.options.config[n]},a.prototype.shouldCatchError=function(){return this.options.catchError},a.prototype.shouldRecordStats=function(){return this.options.recordStats},a.prototype.onError=function(n){this.options.onError(n)},a}();l.Configuration=g})(AMDLoader||(AMDLoader={}));var AMDLoader;(function(l){var E=function(){function e(t){this._env=t,this._scriptLoader=null,this._callbackMap={}}return e.prototype.load=function(t,r,i,o){var u=this;if(!this._scriptLoader)if(this._env.isWebWorker)this._scriptLoader=new a;else if(this._env.isElectronRenderer){var c=t.getConfig().getOptionsLiteral().preferScriptTags;c?this._scriptLoader=new v:this._scriptLoader=new n(this._env)}else this._env.isNode?this._scriptLoader=new n(this._env):this._scriptLoader=new v;var f={callback:i,errorback:o};if(this._callbackMap.hasOwnProperty(r)){this._callbackMap[r].push(f);return}this._callbackMap[r]=[f],this._scriptLoader.load(t,r,function(){return u.triggerCallback(r)},function(p){return u.triggerErrorback(r,p)})},e.prototype.triggerCallback=function(t){var r=this._callbackMap[t];delete this._callbackMap[t];for(var i=0;i<r.length;i++)r[i].callback()},e.prototype.triggerErrorback=function(t,r){var i=this._callbackMap[t];delete this._callbackMap[t];for(var o=0;o<i.length;o++)i[o].errorback(r)},e}(),v=function(){function e(){}return e.prototype.attachListeners=function(t,r,i){var o=function(){t.removeEventListener("load",u),t.removeEventListener("error",c)},u=function(f){o(),r()},c=function(f){o(),i(f)};t.addEventListener("load",u),t.addEventListener("error",c)},e.prototype.load=function(t,r,i,o){if(/^node\|/.test(r)){var u=t.getConfig().getOptionsLiteral(),c=_(t.getRecorder(),u.nodeRequire||l.global.nodeRequire),f=r.split("|"),p=null;try{p=c(f[1])}catch(m){o(m);return}t.enqueueDefineAnonymousModule([],function(){return p}),i()}else{var d=document.createElement("script");d.setAttribute("async","async"),d.setAttribute("type","text/javascript"),this.attachListeners(d,i,o);var y=t.getConfig().getOptionsLiteral().trustedTypesPolicy;y&&(r=y.createScriptURL(r)),d.setAttribute("src",r);var h=t.getConfig().getOptionsLiteral().cspNonce;h&&d.setAttribute("nonce",h),document.getElementsByTagName("head")[0].appendChild(d)}},e}();function g(e){var t=e.getConfig().getOptionsLiteral().trustedTypesPolicy;try{var r=t?self.eval(t.createScript("","true")):new Function("true");return r.call(self),!0}catch{return!1}}var a=function(){function e(){this._cachedCanUseEval=null}return e.prototype._canUseEval=function(t){return this._cachedCanUseEval===null&&(this._cachedCanUseEval=g(t)),this._cachedCanUseEval},e.prototype.load=function(t,r,i,o){if(/^node\|/.test(r)){var u=t.getConfig().getOptionsLiteral(),c=_(t.getRecorder(),u.nodeRequire||l.global.nodeRequire),f=r.split("|"),p=null;try{p=c(f[1])}catch(h){o(h);return}t.enqueueDefineAnonymousModule([],function(){return p}),i()}else{var d=t.getConfig().getOptionsLiteral().trustedTypesPolicy,y=/^((http:)|(https:)|(file:))/.test(r)&&r.substring(0,self.origin.length)!==self.origin;if(!y&&this._canUseEval(t)){fetch(r).then(function(h){if(h.status!==200)throw new Error(h.statusText);return h.text()}).then(function(h){h=h+`
//# sourceURL=`+r;var m=d?self.eval(d.createScript("",h)):new Function(h);m.call(self),i()}).then(void 0,o);return}try{d&&(r=d.createScriptURL(r)),importScripts(r),i()}catch(h){o(h)}}},e}(),n=function(){function e(t){this._env=t,this._didInitialize=!1,this._didPatchNodeRequire=!1}return e.prototype._init=function(t){this._didInitialize||(this._didInitialize=!0,this._fs=t("fs"),this._vm=t("vm"),this._path=t("path"),this._crypto=t("crypto"))},e.prototype._initNodeRequire=function(t,r){var i=r.getConfig().getOptionsLiteral().nodeCachedData;if(!i||this._didPatchNodeRequire)return;this._didPatchNodeRequire=!0;var o=this,u=t("module");function c(f){var p=f.constructor,d=function(h){try{return f.require(h)}finally{}};return d.resolve=function(h,m){return p._resolveFilename(h,f,!1,m)},d.resolve.paths=function(h){return p._resolveLookupPaths(h,f)},d.main=process.mainModule,d.extensions=p._extensions,d.cache=p._cache,d}u.prototype._compile=function(f,p){var d=u.wrap(f.replace(/^#!.*/,"")),y=r.getRecorder(),h=o._getCachedDataPath(i,p),m={filename:p},P;try{var I=o._fs.readFileSync(h);P=I.slice(0,16),m.cachedData=I.slice(16),y.record(60,h)}catch{y.record(61,h)}var b=new o._vm.Script(d,m),R=b.runInThisContext(m),U=o._path.dirname(p),w=c(this),O=[this.exports,w,this,p,U,process,_commonjsGlobal,Buffer],C=R.apply(this.exports,O);return o._handleCachedData(b,d,h,!m.cachedData,r),o._verifyCachedData(b,d,h,P,r),C}},e.prototype.load=function(t,r,i,o){var u=this,c=t.getConfig().getOptionsLiteral(),f=_(t.getRecorder(),c.nodeRequire||l.global.nodeRequire),p=c.nodeInstrumenter||function(R){return R};this._init(f),this._initNodeRequire(f,t);var d=t.getRecorder();if(/^node\|/.test(r)){var y=r.split("|"),h=null;try{h=f(y[1])}catch(R){o(R);return}t.enqueueDefineAnonymousModule([],function(){return h}),i()}else{r=l.Utilities.fileUriToFilePath(this._env.isWindows,r);var m=this._path.normalize(r),P=this._getElectronRendererScriptPathOrUri(m),I=Boolean(c.nodeCachedData),b=I?this._getCachedDataPath(c.nodeCachedData,r):void 0;this._readSourceAndCachedData(m,b,d,function(R,U,w,O){if(R){o(R);return}var C;U.charCodeAt(0)===e._BOM?C=e._PREFIX+U.substring(1)+e._SUFFIX:C=e._PREFIX+U+e._SUFFIX,C=p(C,m);var M={filename:P,cachedData:w},N=u._createAndEvalScript(t,C,M,i,o);u._handleCachedData(N,C,b,I&&!w,t),u._verifyCachedData(N,C,b,O,t)})}},e.prototype._createAndEvalScript=function(t,r,i,o,u){var c=t.getRecorder();c.record(31,i.filename);var f=new this._vm.Script(r,i),p=f.runInThisContext(i),d=t.getGlobalAMDDefineFunc(),y=!1,h=function(){return y=!0,d.apply(null,arguments)};return h.amd=d.amd,p.call(l.global,t.getGlobalAMDRequireFunc(),h,i.filename,this._path.dirname(i.filename)),c.record(32,i.filename),y?o():u(new Error("Didn't receive define call in "+i.filename+"!")),f},e.prototype._getElectronRendererScriptPathOrUri=function(t){if(!this._env.isElectronRenderer)return t;var r=t.match(/^([a-z])\:(.*)/i);return r?"file:///"+(r[1].toUpperCase()+":"+r[2]).replace(/\\/g,"/"):"file://"+t},e.prototype._getCachedDataPath=function(t,r){var i=this._crypto.createHash("md5").update(r,"utf8").update(t.seed,"utf8").update(process.arch,"").digest("hex"),o=this._path.basename(r).replace(/\.js$/,"");return this._path.join(t.path,o+"-"+i+".code")},e.prototype._handleCachedData=function(t,r,i,o,u){var c=this;t.cachedDataRejected?this._fs.unlink(i,function(f){u.getRecorder().record(62,i),c._createAndWriteCachedData(t,r,i,u),f&&u.getConfig().onError(f)}):o&&this._createAndWriteCachedData(t,r,i,u)},e.prototype._createAndWriteCachedData=function(t,r,i,o){var u=this,c=Math.ceil(o.getConfig().getOptionsLiteral().nodeCachedData.writeDelay*(1+Math.random())),f=-1,p=0,d=void 0,y=function(){setTimeout(function(){d||(d=u._crypto.createHash("md5").update(r,"utf8").digest());var h=t.createCachedData();if(!(h.length===0||h.length===f||p>=5)){if(h.length<f){y();return}f=h.length,u._fs.writeFile(i,Buffer.concat([d,h]),function(m){m&&o.getConfig().onError(m),o.getRecorder().record(63,i),y()})}},c*Math.pow(4,p++))};y()},e.prototype._readSourceAndCachedData=function(t,r,i,o){if(!r)this._fs.readFile(t,{encoding:"utf8"},o);else{var u=void 0,c=void 0,f=void 0,p=2,d=function(y){y?o(y):--p==0&&o(void 0,u,c,f)};this._fs.readFile(t,{encoding:"utf8"},function(y,h){u=h,d(y)}),this._fs.readFile(r,function(y,h){!y&&h&&h.length>0?(f=h.slice(0,16),c=h.slice(16),i.record(60,r)):i.record(61,r),d()})}},e.prototype._verifyCachedData=function(t,r,i,o,u){var c=this;!o||t.cachedDataRejected||setTimeout(function(){var f=c._crypto.createHash("md5").update(r,"utf8").digest();o.equals(f)||(u.getConfig().onError(new Error("FAILED TO VERIFY CACHED DATA, deleting stale '"+i+"' now, but a RESTART IS REQUIRED")),c._fs.unlink(i,function(p){p&&u.getConfig().onError(p)}))},Math.ceil(5e3*(1+Math.random())))},e._BOM=65279,e._PREFIX="(function (require, define, __filename, __dirname) { ",e._SUFFIX=`
});`,e}();function _(e,t){if(t.__$__isRecorded)return t;var r=function(o){e.record(33,o);try{return t(o)}finally{e.record(34,o)}};return r.__$__isRecorded=!0,r}l.ensureRecordedNodeRequire=_;function s(e){return new E(e)}l.createScriptLoader=s})(AMDLoader||(AMDLoader={}));var AMDLoader;(function(l){var E=function(){function s(e){var t=e.lastIndexOf("/");t!==-1?this.fromModulePath=e.substr(0,t+1):this.fromModulePath=""}return s._normalizeModuleId=function(e){var t=e,r;for(r=/\/\.\//;r.test(t);)t=t.replace(r,"/");for(t=t.replace(/^\.\//g,""),r=/\/(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//;r.test(t);)t=t.replace(r,"/");return t=t.replace(/^(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//,""),t},s.prototype.resolveModule=function(e){var t=e;return l.Utilities.isAbsolutePath(t)||(l.Utilities.startsWith(t,"./")||l.Utilities.startsWith(t,"../"))&&(t=s._normalizeModuleId(this.fromModulePath+t)),t},s.ROOT=new s(""),s}();l.ModuleIdResolver=E;var v=function(){function s(e,t,r,i,o,u){this.id=e,this.strId=t,this.dependencies=r,this._callback=i,this._errorback=o,this.moduleIdResolver=u,this.exports={},this.error=null,this.exportsPassedIn=!1,this.unresolvedDependenciesCount=this.dependencies.length,this._isComplete=!1}return s._safeInvokeFunction=function(e,t){try{return{returnedValue:e.apply(l.global,t),producedError:null}}catch(r){return{returnedValue:null,producedError:r}}},s._invokeFactory=function(e,t,r,i){return e.isBuild()&&!l.Utilities.isAnonymousModule(t)?{returnedValue:null,producedError:null}:e.shouldCatchError()?this._safeInvokeFunction(r,i):{returnedValue:r.apply(l.global,i),producedError:null}},s.prototype.complete=function(e,t,r){this._isComplete=!0;var i=null;if(this._callback)if(typeof this._callback=="function"){e.record(21,this.strId);var o=s._invokeFactory(t,this.strId,this._callback,r);i=o.producedError,e.record(22,this.strId),!i&&typeof o.returnedValue!="undefined"&&(!this.exportsPassedIn||l.Utilities.isEmpty(this.exports))&&(this.exports=o.returnedValue)}else this.exports=this._callback;if(i){var u=l.ensureError(i);u.phase="factory",u.moduleId=this.strId,this.error=u,t.onError(u)}this.dependencies=null,this._callback=null,this._errorback=null,this.moduleIdResolver=null},s.prototype.onDependencyError=function(e){return this._isComplete=!0,this.error=e,this._errorback?(this._errorback(e),!0):!1},s.prototype.isComplete=function(){return this._isComplete},s}();l.Module=v;var g=function(){function s(){this._nextId=0,this._strModuleIdToIntModuleId=new Map,this._intModuleIdToStrModuleId=[],this.getModuleId("exports"),this.getModuleId("module"),this.getModuleId("require")}return s.prototype.getMaxModuleId=function(){return this._nextId},s.prototype.getModuleId=function(e){var t=this._strModuleIdToIntModuleId.get(e);return typeof t=="undefined"&&(t=this._nextId++,this._strModuleIdToIntModuleId.set(e,t),this._intModuleIdToStrModuleId[t]=e),t},s.prototype.getStrModuleId=function(e){return this._intModuleIdToStrModuleId[e]},s}(),a=function(){function s(e){this.id=e}return s.EXPORTS=new s(0),s.MODULE=new s(1),s.REQUIRE=new s(2),s}();l.RegularDependency=a;var n=function(){function s(e,t,r){this.id=e,this.pluginId=t,this.pluginParam=r}return s}();l.PluginDependency=n;var _=function(){function s(e,t,r,i,o){o===void 0&&(o=0),this._env=e,this._scriptLoader=t,this._loaderAvailableTimestamp=o,this._defineFunc=r,this._requireFunc=i,this._moduleIdProvider=new g,this._config=new l.Configuration(this._env),this._hasDependencyCycle=!1,this._modules2=[],this._knownModules2=[],this._inverseDependencies2=[],this._inversePluginDependencies2=new Map,this._currentAnonymousDefineCall=null,this._recorder=null,this._buildInfoPath=[],this._buildInfoDefineStack=[],this._buildInfoDependencies=[]}return s.prototype.reset=function(){return new s(this._env,this._scriptLoader,this._defineFunc,this._requireFunc,this._loaderAvailableTimestamp)},s.prototype.getGlobalAMDDefineFunc=function(){return this._defineFunc},s.prototype.getGlobalAMDRequireFunc=function(){return this._requireFunc},s._findRelevantLocationInStack=function(e,t){for(var r=function(m){return m.replace(/\\/g,"/")},i=r(e),o=t.split(/\n/),u=0;u<o.length;u++){var c=o[u].match(/(.*):(\d+):(\d+)\)?$/);if(c){var f=c[1],p=c[2],d=c[3],y=Math.max(f.lastIndexOf(" ")+1,f.lastIndexOf("(")+1);if(f=f.substr(y),f=r(f),f===i){var h={line:parseInt(p,10),col:parseInt(d,10)};return h.line===1&&(h.col-="(function (require, define, __filename, __dirname) { ".length),h}}}throw new Error("Could not correlate define call site for needle "+e)},s.prototype.getBuildInfo=function(){if(!this._config.isBuild())return null;for(var e=[],t=0,r=0,i=this._modules2.length;r<i;r++){var o=this._modules2[r];if(!!o){var u=this._buildInfoPath[o.id]||null,c=this._buildInfoDefineStack[o.id]||null,f=this._buildInfoDependencies[o.id];e[t++]={id:o.strId,path:u,defineLocation:u&&c?s._findRelevantLocationInStack(u,c):null,dependencies:f,shim:null,exports:o.exports}}}return e},s.prototype.getRecorder=function(){return this._recorder||(this._config.shouldRecordStats()?this._recorder=new l.LoaderEventRecorder(this._loaderAvailableTimestamp):this._recorder=l.NullLoaderEventRecorder.INSTANCE),this._recorder},s.prototype.getLoaderEvents=function(){return this.getRecorder().getEvents()},s.prototype.enqueueDefineAnonymousModule=function(e,t){if(this._currentAnonymousDefineCall!==null)throw new Error("Can only have one anonymous define call per script file");var r=null;this._config.isBuild()&&(r=new Error("StackLocation").stack||null),this._currentAnonymousDefineCall={stack:r,dependencies:e,callback:t}},s.prototype.defineModule=function(e,t,r,i,o,u){var c=this;u===void 0&&(u=new E(e));var f=this._moduleIdProvider.getModuleId(e);if(this._modules2[f]){this._config.isDuplicateMessageIgnoredFor(e)||console.warn("Duplicate definition of module '"+e+"'");return}var p=new v(f,e,this._normalizeDependencies(t,u),r,i,u);this._modules2[f]=p,this._config.isBuild()&&(this._buildInfoDefineStack[f]=o,this._buildInfoDependencies[f]=(p.dependencies||[]).map(function(d){return c._moduleIdProvider.getStrModuleId(d.id)})),this._resolve(p)},s.prototype._normalizeDependency=function(e,t){if(e==="exports")return a.EXPORTS;if(e==="module")return a.MODULE;if(e==="require")return a.REQUIRE;var r=e.indexOf("!");if(r>=0){var i=t.resolveModule(e.substr(0,r)),o=t.resolveModule(e.substr(r+1)),u=this._moduleIdProvider.getModuleId(i+"!"+o),c=this._moduleIdProvider.getModuleId(i);return new n(u,c,o)}return new a(this._moduleIdProvider.getModuleId(t.resolveModule(e)))},s.prototype._normalizeDependencies=function(e,t){for(var r=[],i=0,o=0,u=e.length;o<u;o++)r[i++]=this._normalizeDependency(e[o],t);return r},s.prototype._relativeRequire=function(e,t,r,i){if(typeof t=="string")return this.synchronousRequire(t,e);this.defineModule(l.Utilities.generateAnonymousModule(),t,r,i,null,e)},s.prototype.synchronousRequire=function(e,t){t===void 0&&(t=new E(e));var r=this._normalizeDependency(e,t),i=this._modules2[r.id];if(!i)throw new Error("Check dependency list! Synchronous require cannot resolve module '"+e+"'. This is the first mention of this module!");if(!i.isComplete())throw new Error("Check dependency list! Synchronous require cannot resolve module '"+e+"'. This module has not been resolved completely yet.");if(i.error)throw i.error;return i.exports},s.prototype.configure=function(e,t){var r=this._config.shouldRecordStats();t?this._config=new l.Configuration(this._env,e):this._config=this._config.cloneAndMerge(e),this._config.shouldRecordStats()&&!r&&(this._recorder=null)},s.prototype.getConfig=function(){return this._config},s.prototype._onLoad=function(e){if(this._currentAnonymousDefineCall!==null){var t=this._currentAnonymousDefineCall;this._currentAnonymousDefineCall=null,this.defineModule(this._moduleIdProvider.getStrModuleId(e),t.dependencies,t.callback,null,t.stack)}},s.prototype._createLoadError=function(e,t){var r=this,i=this._moduleIdProvider.getStrModuleId(e),o=(this._inverseDependencies2[e]||[]).map(function(c){return r._moduleIdProvider.getStrModuleId(c)}),u=l.ensureError(t);return u.phase="loading",u.moduleId=i,u.neededBy=o,u},s.prototype._onLoadError=function(e,t){var r=this._createLoadError(e,t);this._modules2[e]||(this._modules2[e]=new v(e,this._moduleIdProvider.getStrModuleId(e),[],function(){},null,null));for(var i=[],o=0,u=this._moduleIdProvider.getMaxModuleId();o<u;o++)i[o]=!1;var c=!1,f=[];for(f.push(e),i[e]=!0;f.length>0;){var p=f.shift(),d=this._modules2[p];d&&(c=d.onDependencyError(r)||c);var y=this._inverseDependencies2[p];if(y)for(var o=0,u=y.length;o<u;o++){var h=y[o];i[h]||(f.push(h),i[h]=!0)}}c||this._config.onError(r)},s.prototype._hasDependencyPath=function(e,t){var r=this._modules2[e];if(!r)return!1;for(var i=[],o=0,u=this._moduleIdProvider.getMaxModuleId();o<u;o++)i[o]=!1;var c=[];for(c.push(r),i[e]=!0;c.length>0;){var f=c.shift(),p=f.dependencies;if(p)for(var o=0,u=p.length;o<u;o++){var d=p[o];if(d.id===t)return!0;var y=this._modules2[d.id];y&&!i[d.id]&&(i[d.id]=!0,c.push(y))}}return!1},s.prototype._findCyclePath=function(e,t,r){if(e===t||r===50)return[e];var i=this._modules2[e];if(!i)return null;var o=i.dependencies;if(o)for(var u=0,c=o.length;u<c;u++){var f=this._findCyclePath(o[u].id,t,r+1);if(f!==null)return f.push(e),f}return null},s.prototype._createRequire=function(e){var t=this,r=function(i,o,u){return t._relativeRequire(e,i,o,u)};return r.toUrl=function(i){return t._config.requireToUrl(e.resolveModule(i))},r.getStats=function(){return t.getLoaderEvents()},r.hasDependencyCycle=function(){return t._hasDependencyCycle},r.config=function(i,o){o===void 0&&(o=!1),t.configure(i,o)},r.__$__nodeRequire=l.global.nodeRequire,r},s.prototype._loadModule=function(e){var t=this;if(!(this._modules2[e]||this._knownModules2[e])){this._knownModules2[e]=!0;var r=this._moduleIdProvider.getStrModuleId(e),i=this._config.moduleIdToPaths(r),o=/^@[^\/]+\/[^\/]+$/;this._env.isNode&&(r.indexOf("/")===-1||o.test(r))&&i.push("node|"+r);var u=-1,c=function(f){if(u++,u>=i.length)t._onLoadError(e,f);else{var p=i[u],d=t.getRecorder();if(t._config.isBuild()&&p==="empty:"){t._buildInfoPath[e]=p,t.defineModule(t._moduleIdProvider.getStrModuleId(e),[],null,null,null),t._onLoad(e);return}d.record(10,p),t._scriptLoader.load(t,p,function(){t._config.isBuild()&&(t._buildInfoPath[e]=p),d.record(11,p),t._onLoad(e)},function(y){d.record(12,p),c(y)})}};c(null)}},s.prototype._loadPluginDependency=function(e,t){var r=this;if(!(this._modules2[t.id]||this._knownModules2[t.id])){this._knownModules2[t.id]=!0;var i=function(o){r.defineModule(r._moduleIdProvider.getStrModuleId(t.id),[],o,null,null)};i.error=function(o){r._config.onError(r._createLoadError(t.id,o))},e.load(t.pluginParam,this._createRequire(E.ROOT),i,this._config.getOptionsLiteral())}},s.prototype._resolve=function(e){var t=this,r=e.dependencies;if(r)for(var i=0,o=r.length;i<o;i++){var u=r[i];if(u===a.EXPORTS){e.exportsPassedIn=!0,e.unresolvedDependenciesCount--;continue}if(u===a.MODULE){e.unresolvedDependenciesCount--;continue}if(u===a.REQUIRE){e.unresolvedDependenciesCount--;continue}var c=this._modules2[u.id];if(c&&c.isComplete()){if(c.error){e.onDependencyError(c.error);return}e.unresolvedDependenciesCount--;continue}if(this._hasDependencyPath(u.id,e.id)){this._hasDependencyCycle=!0,console.warn("There is a dependency cycle between '"+this._moduleIdProvider.getStrModuleId(u.id)+"' and '"+this._moduleIdProvider.getStrModuleId(e.id)+"'. The cyclic path follows:");var f=this._findCyclePath(u.id,e.id,0)||[];f.reverse(),f.push(u.id),console.warn(f.map(function(y){return t._moduleIdProvider.getStrModuleId(y)}).join(` => 
`)),e.unresolvedDependenciesCount--;continue}if(this._inverseDependencies2[u.id]=this._inverseDependencies2[u.id]||[],this._inverseDependencies2[u.id].push(e.id),u instanceof n){var p=this._modules2[u.pluginId];if(p&&p.isComplete()){this._loadPluginDependency(p.exports,u);continue}var d=this._inversePluginDependencies2.get(u.pluginId);d||(d=[],this._inversePluginDependencies2.set(u.pluginId,d)),d.push(u),this._loadModule(u.pluginId);continue}this._loadModule(u.id)}e.unresolvedDependenciesCount===0&&this._onModuleComplete(e)},s.prototype._onModuleComplete=function(e){var t=this,r=this.getRecorder();if(!e.isComplete()){var i=e.dependencies,o=[];if(i)for(var u=0,c=i.length;u<c;u++){var f=i[u];if(f===a.EXPORTS){o[u]=e.exports;continue}if(f===a.MODULE){o[u]={id:e.strId,config:function(){return t._config.getConfigForModule(e.strId)}};continue}if(f===a.REQUIRE){o[u]=this._createRequire(e.moduleIdResolver);continue}var p=this._modules2[f.id];if(p){o[u]=p.exports;continue}o[u]=null}e.complete(r,this._config,o);var d=this._inverseDependencies2[e.id];if(this._inverseDependencies2[e.id]=null,d)for(var u=0,c=d.length;u<c;u++){var y=d[u],h=this._modules2[y];h.unresolvedDependenciesCount--,h.unresolvedDependenciesCount===0&&this._onModuleComplete(h)}var m=this._inversePluginDependencies2.get(e.id);if(m){this._inversePluginDependencies2.delete(e.id);for(var u=0,c=m.length;u<c;u++)this._loadPluginDependency(e.exports,m[u])}}},s}();l.ModuleManager=_})(AMDLoader||(AMDLoader={}));var define,AMDLoader;(function(l){var E=new l.Environment,v=null,g=function(s,e,t){typeof s!="string"&&(t=e,e=s,s=null),(typeof e!="object"||!Array.isArray(e))&&(t=e,e=null),e||(e=["require","exports","module"]),s?v.defineModule(s,e,t,null,null):v.enqueueDefineAnonymousModule(e,t)};g.amd={jQuery:!0};var a=function(s,e){e===void 0&&(e=!1),v.configure(s,e)},n=function(){if(arguments.length===1){if(arguments[0]instanceof Object&&!Array.isArray(arguments[0])){a(arguments[0]);return}if(typeof arguments[0]=="string")return v.synchronousRequire(arguments[0])}if((arguments.length===2||arguments.length===3)&&Array.isArray(arguments[0])){v.defineModule(l.Utilities.generateAnonymousModule(),arguments[0],arguments[1],arguments[2],null);return}throw new Error("Unrecognized require call")};n.config=a,n.getConfig=function(){return v.getConfig().getOptionsLiteral()},n.reset=function(){v=v.reset()},n.getBuildInfo=function(){return v.getBuildInfo()},n.getStats=function(){return v.getLoaderEvents()},n.define=g;function _(){if(typeof l.global.require!="undefined"||typeof require!="undefined"){var s=l.global.require||require;if(typeof s=="function"&&typeof s.resolve=="function"){var e=l.ensureRecordedNodeRequire(v.getRecorder(),s);l.global.nodeRequire=e,n.nodeRequire=e,n.__$__nodeRequire=e}}E.isNode&&!E.isElectronRenderer&&!E.isElectronNodeIntegrationWebWorker?(module.exports=n,require=n):(E.isElectronRenderer||(l.global.define=g),l.global.require=n)}l.init=_,(typeof l.global.define!="function"||!l.global.define.amd)&&(v=new l.ModuleManager(E,l.createScriptLoader(E),g,n,l.Utilities.getHighPerformanceTimestamp()),typeof l.global.require!="undefined"&&typeof l.global.require!="function"&&n.config(l.global.require),define=function(){return g.apply(null,arguments)},define.amd=g.amd,typeof doNotInitLoader=="undefined"&&_())})(AMDLoader||(AMDLoader={}));

//# sourceMappingURL=../../min-maps/vs/loader.js.map

;//var ko = require('knockout');

//var BootstrapMenu = require('bootstrap-menu');

var amdRequire = require;
amdRequire.config({
  baseUrl: 'node_modules/monaco-editor/release/min'
});

//are we using node?
if (typeof nw === "object") {
  require = nodeRequire;
  require.nodeRequire = require;

  window.usingNode = true;
  //load our modules:
  var fs = require('fs');
  var cp = require('child_process');
  var mkdirp = require('mkdirp');
  var trash = require('trash');
  var getDirName = require('path').dirname;
  var gui = require('nw.gui');
  var resolvePath = require('path').resolve;
  //var http = require('http');
  //var stream = require('stream');
  var updater = require('cside-updater');
  var mediaServer = require('cside-server');
  var win = gui.Window.get();
  win.show();
  process.on("uncaughtException", function(err) {
    bootbox.alert("<h3>Uncaught Exception <span aria-hidden=\"true\">=(</span></h3><p>" + err.message + "\
        </p><p>Something went (unexpectedly!) wrong.<br/>Please close \
        and restart the application (then report this!).");
    try {
      fs.appendFileSync(gui.App.dataPath + '/cside-errors.txt', new Date(Date.now()) + ": " + err.message + "\n" + err.stack + "\n");
    } catch (err) { /* Failed to write to error log */ }
  });
} else {
  window.usingNode = false;
  var getDirName = function(path) { return path.substring(0, path.lastIndexOf("/") + 1); }
  window.onbeforeunload = function(evt) {
    if (!cside.session.isDirty() || cside.getProjects().length === 0)
      return null;
    else {
      var msg = "Warning: You have unsaved changes."
      evt = evt || window.event;
      if (evt) evt.returnValue = msg;
      return msg;
    }
  }
}

// Overall viewmodel for this screen, along with initial state
function IDEViewModel() {

  //EXTENDERS
  ko.extenders.normalizePaths = function(target, option) {
    target.subscribe(function(path) {
      target(__normalizePath(path));
    });
    return target;
  };
  ko.extenders.lowerCase = function(target, option) {
    target.subscribe(function(val) {
      target(val.toLowerCase());
	});
    return target;
  };
  ko.extenders.callFunc = function(target, option) {
    target.subscribe(function(val) {
      option.func(val);
    });
    return target;
  };
  ko.extenders.validate = function(target, validateFunc) {
    target.isErroneous = ko.observable();
    target.errorMessage = ko.observable();

    function doValidate(newValue) {
      var result = validateFunc(target());
      target.isErroneous(!result.valid);
      target.errorMessage(result.message);
    }

    doValidate(target());
    target.subscribe(doValidate);

    return target;
  };

  function __normalizePath(path) {
    //replace backslashes
    path = path.replace(/\\/g, '/');
    return path;
  }
  // @bobince: https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript/3561711#3561711
  var escapeRegex = new RegExp(/[-\/\\^$*+?.()|[\]{}]/g);
  function __escapeRegexString(string) {
    return string.replace(escapeRegex, '\\$&');
  }

  function __onElementRender(elementSelector, callback) {
    var timeout = false;
    var timer = setTimeout(function() { timeout = true; }, 2000); // bail on timeout
    function __checkRender() {
      if (!document.querySelector(elementSelector) && timeout) {
        window.requestAnimationFrame(__checkRender);
      } else {
              setTimeout(function(){ callback(); }, 0); // catch up
      }
    };
    __checkRender();
  }

  function __elementIsInView(element) {
    var rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.bottom <= window.innerHeight;
  }

  // Limit execution of a given function to every *limit* milliseconds
  // inspired by: https://davidwalsh.name/javascript-debounce-function
  function __limitExecution(func, limit) {
    var timeout = null;
    var locked = false;
    return function () {
      var unlock = function () {
        locked = false;
      }
      var retrigger = function () {
        locked = true;
        clearTimeout(timeout);
        timeout = setTimeout(unlock, limit);
      }
      if (!locked) func.apply(this, arguments);
      retrigger();
    }
  }

  // ╔═╗┌─┐┌┐┌┌─┐┌┬┐┬─┐┬ ┬┌─┐┌┬┐┌─┐┬─┐  ╔═╗┬ ┬┌┐┌┌─┐┌┬┐┬┌─┐┌┐┌┌─┐
  // ║  │ ││││└─┐ │ ├┬┘│ ││   │ │ │├┬┘  ╠╣ │ │││││   │ ││ ││││└─┐
  // ╚═╝└─┘┘└┘└─┘ ┴ ┴└─└─┘└─┘ ┴ └─┘┴└─  ╚  └─┘┘└┘└─┘ ┴ ┴└─┘┘└┘└─┘

  function CSIDEProject(projectData) {
    var self = this;

    //INSTANCE VARIABLES
    var name = ko.observable(projectData.name ? projectData.name : (getLastDirName(projectData.path) ? getLastDirName(projectData.path) : "Untitled")); //take the folder name if no name is stored
    var path = ko.observable().extend({
      normalizePaths: ""
    }); //convert relative paths to direct paths and normalize slashes
    path(projectData.path);
    var files = ko.observableArray([]);
    var markerIssues = ko.observableArray([]);
    var generalIssues = ko.observableArray([]);
    var issues = ko.computed(function() {
      return markerIssues().concat(generalIssues());
    });
    var console_logs = ko.observableArray([])
      .extend({
        rateLimit: {
          timeout: 100
        }, //method: "notifyWhenChangesStop"  //limit rate for perf reasons
        callFunc: {
          func: function() {
            setTimeout(function() {
              var ul = $("#cs-console > ul")[0];
              if (ul) ul.scrollTop = ul.scrollHeight;
            }, 100);
          }
        }
      });
    var unreadLogs = ko.observable(0);
    var consoleOpen = ko.observable(false);
    var source = projectData.source;
    var expanded = ko.observable(projectData.expanded === false ? false : true);
    var locked = ko.observable(false); //locks the project ui/prevents spam operations
    var readOnly = ko.observable(projectData.readOnly || false);
    var editing = ko.observable(false);
    var invalidName = ko.observable(false);
    var projectEditors = ko.observableArray([]);
    self.getEditors = projectEditors;

    //GETTER METHODS
    self.getName = ko.computed(function() {
      return name();
    }, this);
    self.getPath = ko.computed(function() {
      return path();
    }, this);
    self.getFiles = files;
    self.getIssues = ko.computed(function() {
      return files().reduce(function(issues, file) {
        return issues.concat(file.getIssues());
      }, issues());
    }, this);
    self.getFilteredIssues = ko.computed(function() {
      return files().reduce(function(issues, file) {
        return issues.concat(file.getFilteredIssues());
      }, issues());
    }, this);
    self.consoleOpen = ko.computed(function() {
      return consoleOpen();
    }, this);
    self.getLogs = ko.computed(function() {
      return console_logs();
    }, this);
    self.getUnreadLogCount = ko.computed(function() {
      return unreadLogs();
    }, this);
    self.issueCount = ko.computed(function() {
      return self.getIssues().length;
    }, this);
    self.filteredIssueCount = ko.computed(function() {
      return self.getFilteredIssues().length;
    }, this);
    self.hasErrors = ko.computed(function() {
      return (files().some(function(scene) {
        return scene.hasErrors();
      }));
    }, this);
    self.hasWarnings = ko.computed(function() {
      return (files().some(function(scene) {
        return scene.hasWarnings();
      }));
    }, this);
    self.getFilteredIssueCountString = function() {
      var sceneCount = files().filter(function(f) { return f.filteredIssueCount() > 0 }).length;
      return "Showing " + self.filteredIssueCount() + " issue(s) in " + sceneCount + " file(s).";
    }
    self.getIssueCountString = function() {
      var sceneCount = files().filter(function(f) { return f.issueCount() > 0 }).length;
      return "There are " + self.issueCount() + " issue(s) across " + sceneCount + " file(s) in total.";
    }
    self.getSource = function() {
      return source;
    };
    self.isExpanded = ko.computed(function() {
      return expanded();
    }, this);
    self.isLocked = ko.computed(function() {
      return locked();
    }, this);
    self.isReadOnly = ko.computed(function() {
      return readOnly();
    }, this);
    self.beingEdited = ko.computed(function() {
      return editing();
    }, this);
    self.nameInvalid = ko.computed(function() {
      return invalidName();
    }, this);
    self.getSearchResults = ko.computed(function() {
      return ko.utils.arrayMap(files(), function(file) {
        return file.getSearchResults();
      }).filter(function(fileResults) { return fileResults.getResults().length > 0; });
    }, this);
    self.replaceAllFilesSearchResults = function() {
      var _files = files();
      for (var s = 0; s < _files.length; s++) {
        _files[s].replaceAllSearchResults();
      }
    }
    self.isDirty = ko.computed(function() {
      for (var i = 0; i < files().length; i++) {
        if (files()[i].isDirty()) {
          return true;
        } else if (i === files().length - 1) {
          return false;
        }
      }
    });
    self.getWordCount = function() {
      var incCmdWordCount = 0;
      var exCmdWordCount = 0;
      for (var i = 0; i < files().length; i++) {
        var counts = files()[i].getWordCount();
        incCmdWordCount += counts.incmds;
        exCmdWordCount +=counts.excmds;
      }
      return { incmds: incCmdWordCount, excmds: exCmdWordCount }
    }
    self.getCharCount = function() {
      var charCount = 0;
      for (var i = 0; i < files().length; i++) {
        charCount += files()[i].getCharCount();
      }
      return charCount;
    }
    self.logToConsole = function(log, type, meta) {
      if (typeof log !== "boolean" && typeof log !== "number" && typeof log !== "string") {
        return;
      }
      monaco.editor.colorize(log, "choicescript").then(function(formatString) {
        if (typeof type != "string")
          type = "";
        if (console_logs().length > 999) {
          console_logs.shift(); //limit entries
        }
        if (meta) {
          if (typeof meta.scene === "string" && typeof meta.line === "number") {
            console_logs.push({
              value: formatString,
              type: type || "null",
              scene: meta.scene || "",
              line: meta.line || ""
            });
          } else {
            console.log(typeof meta.scene, typeof meta.line);
            console_logs.push({
              value: "Error: attempt to log bad meta data logged to project console!",
              type: "cm-error"
            });
          }
        } else {
          console_logs.push({
            value: formatString,
            type: type || "null"
          });
        }
        if (!consoleOpen() && type != "system")
          unreadLogs(unreadLogs() < 8 ? unreadLogs() + 1 : "9+"); //unsafe type mix...?
      });
    }
    self.toggleConsole = function(force) {
      if (typeof force === "boolean") {
        consoleOpen(force);
      } else {
        consoleOpen(!consoleOpen());
      }
      if (consoleOpen()) {
        unreadLogs(0);
      }
      monacoConsole.layout();
      return consoleOpen();
    }
    self.clearConsole = function() {
      console_logs.removeAll();
    }
    self.addIssue = function(issue) {
      // only for non-marker issue
      generalIssues.push(issue);
    }
    self.removeIssue = function(issue) {
      // only for non-marker issue
      generalIssues.remove(issue);
    }
    self.purgeIssues = function() {
      // only for non-marker issue
      generalIssues([]);
    }
      /* self.markConsoleRead = function() {
          unreadLogs(0);
      } */
    self.dismissAllIssues = function() {
        //so for some reason we need to buffer this into another array
        //if we store the length or use issues() directly, either not all the issues
        //are removed or we (apparently) reference a non-existent issue?
        var t = 0,
          issueBuffer = [];
        var issueList = issues();
        for (var o = 0; o < issueList.length; o++) {
          issueBuffer.push(issueList[o]);
        }
        for (var i = 0; i < issueBuffer.length; i++) {
          issueBuffer[i].dismiss();
        }
        __selectTab("game");
      }
      //SETTER METHODS
    self.setExpand = function(boole, event) {
      /*if (typeof event === "object") { NOW REDUNDANT AS WE'VE MOVED TO PROJECT DRAG HANDLE
				if (!hasClass(event.target, "project-header")) { return; } //ignore bubbling double clicks
			}*/
      if (typeof boole !== "boolean") {
        expanded() ? expanded(false) : expanded(true);
        return;
      }
      expanded(boole);
    }
    self.nameInterface = ko.pureComputed({
      read: function() {
        return name();
      },
      write: function(newValue) {
        validName(newValue, true, function(valid, errMsg) {
          invalidName(valid ? false : true);
          if (valid) {
            name(newValue)
          } else {
            console.log(errMsg);
          }
        });
      },
      owner: this
    });
    self.issueSearch = function(data, event, domObj) {
      if (event.type == "keyup" && SEARCH.CONF.searchOnType()) {
        cside.filterString(event.target.value);
        return true; // allow the char input to take place
      }
      else if (event.type != "keydown") {
        return true;
      }
      if (event.keyCode == 13) {
        if (!event.ctrlKey) {
          cside.filterString(event.target.value);
          return false; // don't allow the Enter press to affect the textarea
        } else { // match monaco's in-model search linebreak behaviour (ctrl+enter)
          event.target.value += "\n";
          event.target.scrollTop = event.target.scrollHeight;
        }
      }
      return true;
    }
    self.searchByEnterKey = function(data, event, domObj) {
      if (event.type == "keyup" && SEARCH.CONF.searchOnType())
        return self.search("", "", SEARCH.MODES.SEARCH) || true; // allow the char input to take place
      else if (event.type != "keydown")
        return true;
      if (event.keyCode == 13) {
        if (!event.ctrlKey) {
          return self.search("", "", SEARCH.MODES.SEARCH) && false; // don't allow the Enter press to affect the textarea
        } else { // match monaco's in-model search linebreak behaviour (ctrl+enter)
          event.target.value += "\n";
          event.target.scrollTop = event.target.scrollHeight;
        }
      }
      return true;
    }
    self.search = function(searchStr, replaceStr, newSearchMode) {
      var curSearchMode = (typeof newSearchMode === "number") ? newSearchMode : searchMode();
      if (typeof searchStr != "string" || searchStr === "")
        searchStr = document.getElementById("searchBox").value;
      if (curSearchMode === SEARCH.MODES.REPLACE) {
        replaceStr = replaceStr || document.getElementById("replaceBox").value;
        bootbox.confirm(self.getSearchResultDesc() + "<br>Replace them with '" + replaceStr + "'?",
          function(result) {
            if (result) {
              files().forEach(function(file) { file.search(searchStr, replaceStr, false /* forceExpand */, curSearchMode); });
            }
          }
        );
      }
      else {
        files().forEach(function(file) {
          /* Once a file's results tab has been manually expanded it is likely that the user wishes to continue to see those results, so we'd rather
             not have them re-collapse on every re-search. However, there's the issue of performance (and screen estate) when multiple file's with large
             result sets are left open.
             So, what we do here is make the collapse/expand state for each file remain honoured *up until* it returns 0 results,
             implying that it is no longer relevant.
             This essentially adds a natural 'reset' that makes sure files are re-collapsed over time, rather than expecting the user to close them,
             whilst still allowing for a user to view result changes in their files of interest.
          */
          var forceExpand = file.getSearchResults() && (file.getSearchResults().keepOpen() && file.getSearchResults().getLength() > 0);
          file.search(searchStr, replaceStr, forceExpand, curSearchMode);
        });
      }
      return false; // prevent form submission
    }
    self.getSearchResultCount = function() {
      var count = 0;
      for (var i = 0; i < self.getSearchResults().length; i++)
        count += self.getSearchResults()[i].getLength();
      return count;
    }
    self.getSearchResultDesc = function() {
      return ("Found " + self.getSearchResultCount() + " results in " + self.getSearchResults().length + " file(s).");
    }
    self.rename = function(data, event) {
      if (readOnly()) return;
      if (event.type == "keyup" && (event.keyCode != 13 && event.keyCode != 27)) {
        return;
      }
      if (event.type != "dblclick") {
        if (invalidName() && editing()) {
          //$(event.target).fadeOut("fast").fadeIn("fast").focus();
          return;
        } else {
          editing(false);
          __updatePersistenceList();
          return;
        }
      }
      editing(true);
      setTimeout(function() { //force select (can't then avoid initial blur)
        $(event.target).focus().select();
      }, 10);
    }
      //MISC METHODS
    self.run = function() {
      if (locked()) return;
      locked(true); //prevent run spam
      if (self.isDirty()) {
        bootbox.confirm("This project has unsaved changes, these will not appear in the test run, do you wish to continue?", function(result) {
          if (result) {
            __runProject(self);
          }
        });
      } else {
        __runProject(self);
      }
      setTimeout(function() { locked(false); }, 5000);
    }
    self.openFolder = function() {
      __openFolder(path());
    }
    self.close = function() {
      __closeProject(self);
    }
    self.select = function(callback) {
      /* select first possible file */
      var file = files()[0];
      if (file) {
        file.viewInEditor(callback);
      } else {
        callback(null);
      }
    }
    self.save = function(cb) {
      if (typeof cb != "function") cb = function() {}; //ui click
      var failed = false;
      var count = files().length;
      files().forEach(function(file, index) {
        if (failed) return;
        file.save(null, null, function(err) {
          if (err) {
            failed = true;
            return cb(err);
          }
          if (--count == 0) cb(null);
        });
      });
    }
    self.addNewFile = function(project, event) {
      if (readOnly()) return;
      if (event) event.stopPropagation();
      addNewFile(self, "untitled");
    }
    self.addFile = function(file) {
      if (file.getProject() !== self && file.getProject() !== false) return; //invalid call (only at file creation or via file.move())
      files.push(file);
    }
    self.removeFile = function(file) {
      if (files().lastIndexOf(file) === -1) {
        return;
      }
      var editors = file.getEditors();
      for (var i = 0; i < editors.length; i++) {
        editors[i].close();
      }
      files.remove(file);
      if (files().length < 1) {
        projects.remove(self);
      }
    }
    self.closeFile = function(file, callback) {
        function closeFile() {
          self.removeFile(file);
          __updatePersistenceList();
          if (typeof callback === 'function') callback(true);
        }
        if (file.isDirty()) {
          bootbox.confirm("This file has unsaved changes, are you sure you wish to close it?", function(result) {
            if (result) {
              closeFile();
            } else {
              if (typeof callback === 'function') callback(false);
              return;
            }
          });
        } else {
          closeFile();
        }
      }
    self.subscribeEditor = function(ed) {
      if (projectEditors.indexOf(ed) < 0) {
        projectEditors.push(ed);
      }
      if (self === activeProject()) {
        var aEd = activeEditor();
        if (aEd) aEd.resize();
      }
    }
    self.unsubscribeEditor = function(ed) {
      projectEditors.remove(ed);
      if (self === activeProject()) {
        var aEd = activeEditor();
        if (aEd) aEd.resize();
      }
    }
      /* callback(err, success_boolean) */
    self.exportFiles = function() {
      fh.selectFolder(function(newPath) {
        if (newPath) {
          bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any files with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>",
            function(result) {
              if (result) {
                __copyProjectTo(path(), newPath, function(err) {
                  if (err) {
                    notification("Error", err.message, {
                      type: "error"
                    });
                    return;
                  }
                  var buttons = [{
                    addClass: 'btn',
                    text: 'Show Folder',
                    onClick: function(note) {
                      __openFolder(newPath);
                      note.close();
                    }
                  }]
                  var n = notification("Game Exported Successfully", "All files exported successfully to " + newPath, {
                    type: "success",
                    buttons: buttons
                  });
                  n.setTimeout(10000);
                });
              }
            }
          );
        }
      });
    }
    self.compile = function() {
      fh.selectFolder(function(newPath) {
        if (newPath) {
          bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any file with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>",
            function(result) {
              if (result) {
                __fullCompile(self, newPath);
              }
            }
          );
        }
      });
    }
    self.test = function(test) {
      __testProject(self, test);
    }
    self.openAllScenes = function() {
      __openAllProjectScenes(self);
    }
    self.reloadAllFiles = function() {
      for (var i = 0; i < files().length; i++)
        files()[i].load();
    }
    /* Display only this project and its editors */
    self.makeActive = function() {
      var oldProject = activeProject();
      if (oldProject) {
         if (oldProject === self) {
          return;
        }
        oldProject.getEditors().forEach(function(ed) {
          ed.hide();
        });
      }
      activeProject(self);
      self.getEditors().forEach(function(ed) {
        ed.show();
      });
    }
  };

  function CSIDESearchResults(data) {
    var self = this;
    var searchTerm = data.searchTerm || "";
    var searchResults = ko.observableArray(data.results || []).extend({ rateLimit: 500 });
    var keepOpen = data.keepOpen || false; // TODO
    var expanded = ko.observable(data.expanded || false)
      .extend({callFunc: { func: function(expand) {
        // Create search result descriptions as they become visible.
        if (expand)
          self.createResultDescriptions();
        }}
      });
    var versionId = data.versionId || null; // state of editor when search initiated
    var file = data.file || null;

    self.getResults = ko.computed(function() {
      return searchResults();
    }, this);
    self.isExpanded = ko.computed(function() {
      return expanded();
    }, this);
    self.getLength = function () {
      return searchResults().length;
    }
    self.getLengthString = function() {
      var len = self.getLength();
      return len >= 999 ? "999+" : len.toString();
    }
    self.getFile = function() {
      return file;
    }
    self.getVersionId = function() {
      return versionId;
    }
    self.getSearchTerm = function() {
      return searchTerm;
    }
    self.keepOpen = function() {
      return keepOpen;
    }
    self.expand = function(expand, stayOpen) {
      if (typeof expand === "boolean") {
        expanded(expand);
      }
      else {
        expanded(!expanded());
      }
      keepOpen = expanded() ? (stayOpen || false) : false;
    }
    /* Determines before/after line text for the search result to provide context. */
    self.createResultDescriptions = function() {
      var SEARCH_MAX_LINE_LEN = 30;
      var descriptiveResults = searchResults(); // matches.match.matches
      for (var i = 0, result = descriptiveResults[i]; i < descriptiveResults.length; result = descriptiveResults[++i]) {
        // preceding match
        result.preText = result.range.startColumn > 0 ?
          file.getLineContent(result.range.startLineNumber).slice(0, result.range.startColumn-1) : "";
          if (result.preText.length > SEARCH_MAX_LINE_LEN)
            result.preText = "…" + result.preText.slice(result.range.startColumn-(SEARCH_MAX_LINE_LEN+1),result.range.startColumn-1);
        // post match
        var endLineLen = file.getLineLength(result.range.endLineNumber);
        result.postText = result.range.endColumn < endLineLen ?
          file.getLineContent(result.range.endLineNumber).slice(result.range.endColumn-1, endLineLen) : "";
        if (result.postText.length > SEARCH_MAX_LINE_LEN)
          result.postText = result.postText.slice(0,SEARCH_MAX_LINE_LEN) + "…";
        // replace text
        result.replaceText = document.getElementById("replaceBox").value || "";
        if (SEARCH.CONF.useRegex())
          result.replaceText = monaco.cside.parseReplaceString(result.replaceText).buildReplaceString(descriptiveResults[i].matches, SEARCH.CONF.preserveCase());
      }
      searchResults(descriptiveResults);
    }
    // Only (re-)create result descriptions if they're visible.
    if (file && expanded) {
      self.createResultDescriptions();
    }
  }

  function CSIDEFile(fileData) {
    var self = this;
    //INSTANCE VARIABLES
    var edModel = ko.observable(null); // holds the Monaco editor document model
    var path = ko.observable(__normalizePath(fileData.path)).extend({
      normalizePaths: "",
      callFunc: {
        func: function(newPath) {
          // automatically replace the Monaco model on renames to keep its Uri in sync
          var oldModel = edModel();
          try {
            edModel(monaco.editor.createModel(edModel() ? edModel().getValue() : "", "choicescript", monaco.Uri.file(newPath)));
            edModel().csideFile = self;
            if (oldModel) oldModel.dispose();
            // update any subscribed editors immediately
            self.getEditors().forEach(function(ed) {
              ed.setDocModel(edModel()); // reset model
            });
            edModel().onDidChangeContent(updateOnModelEdit);
          } catch (err) {
            bootbox.alert("Unrecoverable Error: Couldn't update URI for file.<br><br>" + err.message + ".<br><br> Please restart the application and report this.");
          }
        }
      }
    });
    self.getName = ko.computed(function() {
      return getFileName(path());
    }, this);
    self.expandIssues = ko.observable(false);
    var isImportant = self.getName().toUpperCase().match(reservedSceneNames);
    var source = fileData.source || platform; //won't change - so doesn't need to be an observable?
    var loaded = ko.observable(false);
    var locked = ko.observable(false);
    var readOnly = ko.observable(fileData.readOnly || false); //app relative files are always read-only
    var editing = ko.observable(false);
    var colouring = ko.observable(false);
    var saving = ko.observable(false);
    var inErrState = ko.observable(false);
    var errStateMsg = ko.observable("");
    var searchVersionId = null;

    var searchResults = ko.observable(new CSIDESearchResults({results: []}))
      .extend({ rateLimit: { rateLimit: 1000, method: "notifyWhenChangesStop" }});
    var indentSize = ko.observable(settings.byId("editor", "tabsize").getValue())
      .extend({ callFunc: { func: function(newVal) { edModel().updateOptions({tabSize: newVal});}}});
    var useSpaces = ko.observable(settings.byId("editor", "usespaces").getValue())
      .extend({ callFunc: { func: function(newVal) { edModel().updateOptions({insertSpaces: newVal});}}});

    // create initial model
    edModel(monaco.editor.createModel(fileData.contents || "", "choicescript", monaco.Uri.file(path())));
    edModel().onDidChangeContent(updateOnModelEdit);
    edModel().csideFile = self;

    // used for dirtyness
    var lastVersionId = edModel().getAlternativeVersionId();
    var dirty = ko.observable(false);
    var editorViewState = null;
    //won't change - so doesn't need to be an observable?
    var charCount = ko.observable(fileData.contents ? fileData.contents.length : 0); //prepopulate otherwise .load() text replacement results in '0' on new startup.txts
    var wordCount = ko.observable({ incmds: 0, excmds: 0 });
    var fileStats = fileData.stats || {
      "mtime": new Date()
    }; //won't change - so doesn't need to be an observable?
    var markColour = ko.observable(fileData.color ? fileData.color : isImportant ? "#7797ec" : "#777777");
    markColour.extend({
      callFunc: {
        func: function(newCol) {
          var colIndex = recentFileColours().indexOf(newCol);
          recentFileColours.unshift(newCol);
          if (colIndex > -1) {
            recentFileColours.splice(++colIndex, 1);
          } else {
            recentFileColours.splice(recentFileColours().length-1, 1);
          }
          __updatePersistenceList();
        }
      }
    });
    var markerIssues = ko.observableArray([]);
    var generalIssues = ko.observableArray([]);
    var issues = ko.computed(function() {
      return markerIssues().concat(generalIssues());
    });
    generalIssues.subscribe(function(val) {
      if (self == activeFile()) {
        var ed = self.getEditors()[0];
        __updateEditorDecorations(ed, self);
      }
    });
    issues.subscribe(function(val) {
      if (val.length < SEARCH.CONF.collapseThreshold()) {
        self.expandIssues(true);
      } else {
        self.expandIssues(false);
      }
    });
    var invalidName = ko.observable(false);
    var nameErrMsg = ko.observable();
    self.isLocked = ko.computed(function() {
      if (locked()) return true;
      //is another file selected but also being 'edited'? If yes, we can't select this file yet.
      var curFile = cside.getActiveFile();
      if (curFile && (curFile.beingEdited() && curFile != self)) return true;
      return false;
    }, this);

    //GETTER METHODS
    self.decorations = [];
    self.getPath = ko.computed(function() {
      return path();
    }, this);
    self.getModel = ko.computed(function() {
      return edModel();
    }, this);
    self.hasLoaded = ko.computed(function() {
      return loaded();
    }, this);
    self.isSaving = ko.computed(function() {
      return saving();
    }, this);
    self.isDirty = ko.computed(function() {
      return dirty();
    }, this);
    self.isReadOnly = ko.computed(function() {
      return readOnly();
    }, this);
    self.beingEdited = ko.computed(function() {
      return editing();
    }, this);
    self.isActive = function() {
      return activeFile() === self;
    }
    self.beingColoured = ko.computed(function() {
      return colouring();
    }, this);
    self.getSource = function() {
      return source;
    };
    self.getProject = function() {
      return getProject(getProjectPath(path()));
    };
    self.getEditors = ko.computed(function() {
      if (!self.getProject()) return [];
      return self.getProject().getEditors().filter(function(ed) {
        return ed.getFile() === self;
      });
    }, this);
    self.isSelected = function() {
      return (self.getEditors().length > 0);
    };
    self.getText = function() {
      return edModel().getValue();
    };
    self.getMarkColour = ko.computed(function() {
      return markColour();
    }, this);
    self.nameInvalid = ko.computed(function() {
      return invalidName();
    }, this);
    self.getNameErrorMsg = ko.computed(function() {
      return nameErrMsg();
    }, this);
    self.getIssues = ko.computed(function() {
      return issues();
    });
    self.getFilteredIssues = ko.computed(function() {
      var issueList = issues();
      if (cside.filterString.isErroneous()) // TODO: BROKEN
        return issueList;
      var activeIssueTypes = cside.getActiveIssueTypes();
      issueList = issueList.filter(function(issue) {
        return activeIssueTypes.includes(issue.getSeverity());
      });
      var matchCase = SEARCH.CONF.preserveCase();
      var regex = SEARCH.CONF.useRegex();
      var wholeWord = SEARCH.CONF.matchWholeWord();
      return issueList.filter(function(i) {
        var matchValue = matchCase ? i.getDesc() : i.getDesc().toLowerCase();
        var filterString = matchCase ? cside.filterString() : cside.filterString().toLowerCase();
        if (wholeWord) {
          if (!regex) {
            filterString = __escapeRegexString(filterString);
          }
          filterString = "\\b" + filterString + "\\b";
          try {
            return matchValue.match(new RegExp(filterString));
          } catch(err) {
            return false;
          }
        } else {
          if (regex) {
            try {
              return matchValue.match(new RegExp(filterString));
            } catch(err) {
              return false;
            }
          } else {
            return matchValue.includes(filterString);
          }
        }
      });
    }, this);
    self.issueCount = ko.computed(function() {
      return issues().length;
    }, this);
    self.filteredIssueCount = ko.computed(function() {
      return self.getFilteredIssues().length;
    }, this);
    self.hasErrors = function() {
      return self.getIssues().some(function(i) {
        return i.getSeverity() === monaco.MarkerSeverity.Error;
      });
    }
    self.hasWarnings = function() {
      return self.getIssues().some(function(i) {
        return i.getSeverity() === monaco.MarkerSeverity.Warning;
      });
    }
    self.getContents = function() {
      return edModel().getValue();
    }
    self.getLineContent = function(range) {
      // {} => endColumn, endLineNumber, startColumn, startLineNumber
      return edModel().getLineContent(range);
    }
    self.getLineLength = function(lineNum) {
      return edModel().getLineLength(lineNum);
    }
    self.getSearchResults = ko.computed(function() {
      return searchResults();
    }, this);
    self.getErrStateMsg = ko.computed(function() {
      return errStateMsg() + ' - click here to close';
    }, this);
    self.getErrState = ko.computed(function() {
      return inErrState();
    }, this);
    self.getCharCount = function() {
      return charCount();
    };
    self.getWordCount = function() {
      return wordCount();
    };
    self.usingSpaces = function() {
      return useSpaces();
    }
    self.getIndentSize = function() {
      return indentSize();
    }
    self.getIndentDesc = ko.computed(function() {
      return ((useSpaces() ? "Spaces: " : "Tabs: ") + indentSize());
    }, this);
    self.getState = ko.computed(function() {
      if (saving())
        return "fa fa-spinner fa-spin";
      if (!loaded())
        return "fa fa-ban"
      return inErrState() ? "fa fa-exclamation-triangle scene-unsaved" : readOnly() ? "fa fa-lock" : dirty() ? "fa fa-save scene-unsaved" : "fa fa-save scene-saved"
    });
    // FIXME: See useSpaces setting for explanation
    self.updateIndentSize = function(val) {
      if (typeof val === "undefined")
        val = useSpaces() ? settings.asObject("editor")["indentspaces"].getValue() : settings.asObject("editor")["tabsize"];
      indentSize(val);
    }
    self.updateUseSpaces = function(val) {
      if (typeof val === "undefined")
        val = settings.asObject("editor")["usespaces"];
      useSpaces(val);
    }

    //SETTER METHODS
    self.setText = function(value) {
      if (readOnly()) return;
      if (typeof value != "string") return;
      edModel().setValue(value);
    }
    var renameFile = function(newName) {
      if (invalidName())
        return;
      saving(true);
      var newPath = self.getProject().getPath() + newName;
      fh.renameFile(path(), newPath, function(err) {
        executeRename(err);
      });

      function executeRename(err) {
        saving(false);
        if (err) {
          bootbox.alert(err);
        } else {
          fileStats.mtime ? fileStats.mtime = new Date() : fileStats.modifiedAt = new Date();
          path(newPath);
          __updatePersistenceList();
        }
      }
    }
    self.nameInterface = ko.pureComputed({
      read: function() {
        var name = self.getName();
        return editing() ? name.substring(0, name.length - getFileExtension(name).length) : self.getName();
      },
      write: function(newValue) {
        validName(newValue, false, function(valid, errMsg) {
          invalidName(valid ? false : true);
          if (valid) {
            //name(newValue) but need to check it doesn't already exist - instead we do this on confirm (see self.rename)
          } else {
            nameErrMsg(errMsg);
          }
        });
      },
      owner: this
    });
    self.rename = function(data, event) {
      if (inErrState() || !loaded() || saving() || readOnly()) {
        return;
      }
      if (event.type == "blur" && !editing()) {
        return;
      }
      if (event.type == "keyup" && (event.keyCode != 13 && event.keyCode != 27)) {
        return;
      }
      if (event.type != "dblclick" && event.type != "click") {
        if (invalidName() && editing()) {
          $(event.target).fadeOut("fast").fadeIn("fast").focus();
          return;
        } else {
          var newName = event.target.value.trim() + getFileExtension(path());
          if (newName != self.getName()) {
            pathExists(self.getProject() + newName, function(exists) {
              if (!exists) {
                renameFile(newName);
              } else {
                notification("Failed to Rename File", "File '" + event.target.value.toLowerCase() + "' already exists in this Project", {
                  type: "error"
                });
                event.target.value = self.getName();
              }
            });
          }
          editing(false);
        }
      } else if (isImportant) {
        if (isImportant) {
          notification("", "Reserved file cannot be renamed", {
            type: "error",
            layout: "bottomLeft"
          });
          return;
        }
      } else if (self.isLocked()) {
        return;
      } else {
        editing(true);
        setTimeout(function() { //force select (can't then avoid initial blur)
          $(event.target).focus().select();
        }, 10);
      }
    }
    self.showColours = function(file, event) {
      if (event.type === "mouseleave" && !colouring()) return; // ignore mouseleave after colour select
      colouring(!colouring());
    }
    self.recolour = function(colour, event) {
      markColour(colour);
      colouring(false);
    }
    self.newColour = function(file, event) {
      var bcr = event.target.getBoundingClientRect();
      var colSelector = $("#selectColor");
      colSelector.off();
      colSelector.val(markColour());
      colSelector.css({
        "position": "fixed",
        "left": bcr.x,
        "top": bcr.y,
        "z-index": -999
      }).change(function(evt) {
        markColour(colSelector.val());
        colSelector.hide();
      });
      setTimeout(function() {
        colSelector.show().trigger("click");
      }, 500);
    }
    self.showSearchResult = function(index, data) {
      if (searchVersionId != edModel().getAlternativeVersionId()) {
        notification("Stale Search Results", "This file has been modified since the last search was performed. Please search again.", {type: 'error'});
        return;
      }
      self.focusLine(data, true, function(ed) {
        if (ed) ed.getMonacoEditor().setSelection(data.range);
      });
    }
    self.replaceSearchResult = function(index, data, event) {
      if (event) event.stopPropagation();
      if (searchVersionId != edModel().getAlternativeVersionId()) {
        notification("Stale Search Results", "This file has been modified since the last search was performed. Please search again.", {type: 'error'});
        return;
      }
      self.focusLine(data, true, function(ed) {
        if (ed) ed.getMonacoEditor().setSelection(data.range);
      });
      var oldText = data.matches[0];
      var newText = document.getElementById("replaceBox").value || "";
      if (SEARCH.CONF.useRegex())
        newText = monaco.cside.parseReplaceString(newText).buildReplaceString(data.matches, SEARCH.CONF.preserveCase());
      var oldRange = new monaco.Range(data.range.startLineNumber, data.range.startColumn, data.range.endLineNumber, data.range.endColumn);
      var newRange = oldRange;
      var newSelections = edModel().pushEditOperations([new monaco.Selection(oldRange.startLineNumber, oldRange.startColumn, oldRange.endLineNumber, oldRange.endColumn)], [{text: newText, range: oldRange}], function() {
        // Calculate new cursor position(s)
        if (monaco.Range.spansMultipleLines(data.range)) {
          // TODO handle tricky multi-line change range calculations
          return [data.range.collapseToStart()]; // BROKEN?
        }
        // column only differences
        var columnDiff = -1*(oldText.length - newText.length);
        if (columnDiff != 0)
          newRange = oldRange.setEndPosition(oldRange.endLineNumber, oldRange.endColumn + columnDiff);
        return [new monaco.Selection(oldRange.startLineNumber, oldRange.startColumn, newRange.endLineNumber, newRange.endColumn)];
      });
      edModel().pushStackElement();
      self.viewInEditor(function(ed) {
        if (ed) ed.getMonacoEditor().setSelections(newSelections);
      });
      self.search(self.getSearchResults().getSearchTerm(), newText, true, SEARCH.MODES.SEARCH);
    }
    self.replaceAllSearchResults = function(uiConfirmation) {
      var searchStr = document.getElementById("searchBox").value;
      var replaceStr = replaceStr || document.getElementById("replaceBox").value;
      if (uiConfirmation)
        bootbox.confirm("Replace all matches in this file?",
          function(result) {
            if (result) {
              self.search(searchStr, replaceStr, false /* forceExpand */, SEARCH.MODES.REPLACE);
            }
          }
        );
      else
        self.search(searchStr, replaceStr, false /* forceExpand */, SEARCH.MODES.REPLACE);
      //edModel.pushStackElement(); // Undo stack breakpoint.
    }
    self.focusLine = function(lineNum, noArrow, callback) {
      if (typeof lineNum !== "number") {
        if (lineNum.range && typeof lineNum.range.startLineNumber === "number")
          lineNum = lineNum.range.startLineNumber;
        else
          return;
      }
      self.viewInEditor(function(ed) {
        if (ed) {
          if (!noArrow) {
            __updateEditorDecorations(ed, self, [
              {
                range: new monaco.Range(lineNum,1,lineNum,1),
                options: {
                  isWholeLine: false,
                  className: '',
                  glyphMarginClassName: 'arrow-gutter'
                }
              }
            ]);
          }
          var med = ed.getMonacoEditor();
          var pos = {
            lineNumber: lineNum,
            column: med.getModel().getLineMaxColumn(lineNum)
          };
          med.setPosition(pos);
          med.revealPositionInCenter(pos, monaco.editor.ScrollType.Immediate);
          med.focus();
        }
        if (typeof callback === "function") callback(ed);
      });
      // fail silently
    }
    self.logIssue = function(issue) {
      generalIssues.push(issue);
      var buttons = [{
        addClass: 'btn btn-danger',
        text: 'Show',
        onClick: function(note) {
          note.close();
          __selectTab("issues");
          self.expandIssues(true);
          activeIssue(issue);
          if (issue.getLineNum()) {
            issue.show();
          }
        }
      }]
      var n = notification("New Issue", "New issue with project " + self.getName(), {
        type: "error",
        buttons: buttons
      });
      n.setTimeout(5000);
    }
    self.setMarkerIssues = function(newIssues) {
      markerIssues(newIssues);
    }
    self.addIssue = function(issue) {
      generalIssues.push(issue);
    }
    self.removeIssue = function(issue) {
      generalIssues.remove(issue);
    }
      //MISC METHODS
    self.load = function(callback) {
      if (saving()) return;
      loaded(false);
      saving(true);
      if (typeof callback != 'function') {
        callback = function(err) {
          if (err) {
            console.log(err.message);
          }
        }
      }

      fh.stat(path(), function(err, newfileStats) {
        if (err) {
          finishLoading(err);
        } else {
          fileStats = newfileStats;
          fh.readFile(path(), function(err, data) {
            if (err) {
              finishLoading(err);
            } else {
              finishLoading(err, data);
            }
          });
        }
      });

      function finishLoading(err, data) {
        if (err) {
          inErrState(true);
          errStateMsg(err.message);
          console.log(errStateMsg());
          callback(err);
        } else {
          inErrState(false);
          edModel().setValue(data);
          edModel().detectIndentation(
            settings.byId("editor", "usespaces").getValue(),
            useSpaces() ? settings.byId("editor", "indentspaces").getValue() : settings.byId("editor", "tabsize").getValue()
          );
          useSpaces(edModel().getOptions().insertSpaces);
          // pull the visual tab size from the global setting, or the space count from the model detection
          indentSize(useSpaces() ? edModel().getOptions().indentSize : settings.byId("editor", "tabsize").getValue());
          dirty(false);
          __updatePersistenceList();
        }
        loaded(true);
        saving(false);
        if (typeof callback != 'undefined') callback(err, self);
      }
    }
    self.save = function(file, event, callback) {
      if (event) event.stopPropagation();
      //skip clean, error'd or currently saving files
      if ((!dirty() && loaded()) || inErrState() || saving() || locked() || readOnly()) {
        if (typeof callback == 'function') callback(null);
        return;
      }
      saving(true);
      var lastModifiedAt = fileStats.mtime || fileStats.modifiedAt;
      fh.stat(path(), function(err, newfileStats) {
        if (err && (err.code == 404 || err.code == "ENOENT")) {
          //new file, we're cool, bypass:
          saveFile(callback);
        } else if (err) {
          console.log(err);
          saving(false);
          bootbox.alert("<h3>Warning</h3><p>Unable to save <b>" + self.getName() + "</b> of <b>" + self.getProject().getName() + "</b>: " + err.message + ".</p> \
						<p>Check your internet connection.</p>");
        } else {
          checkDate(newfileStats);
        }
      });

      function checkDate(newfileStats) {
        var newlyModifiedAt = newfileStats.mtime || newfileStats.modifiedAt;
        if (newlyModifiedAt.getTime() > (lastModifiedAt.getTime() + 1000)) {
          bootbox.dialog({
            message: "'" + self.getName() + ".txt' of <b>" + self.getProject().getName() + "</b> appears to have been modified by another program or process \
						since it was last saved. Are you sure you wish to save it?",
            title: "Conflict Warning",
            buttons: {
              cancel: {
                label: "Cancel",
                callback: function() {
                  saving(false);
				  return;
                }
              },
			  reload: {
                label: "Reload",
                callback: function() {
                  saving(false);
                  self.load(function(err, file) {
                    if (!err) {
                      file.viewInEditor();
                    }
                  });
				  return;
                }
              },
			  yes: {
                label: "Save",
                className: "btn-primary",
                callback: function() {
                  saveFile(callback);
                }
              }
            },
            onEscape: function() {
			  saving(false);
			  return;
            }
	       });
        } else {
          saveFile(callback);
        }
      }
    }

    function saveFile(callback) {
      var data = edModel().getValue();
      fh.writeFile(path(), data, function(err) {
        finalizeSave(err);
      });

      function finalizeSave(err) {
        if (err) {
          console.log(err);
        } else {
          dirty(false);
          lastVersionId = edModel().getAlternativeVersionId();
          fileStats.mtime ? fileStats.mtime = new Date() : fileStats.modifiedAt = new Date();
        }
        saving(false);
        if (typeof callback == 'function') callback(err);
      }
    }
    self.viewInEditor = function(callback) {
      self.getProject().makeActive();
      var fileEditor = self.getEditors()[0];
      if (fileEditor) {
        fileEditor.makeActive();
        if (typeof callback === "function") callback(fileEditor);
      } else {
        cside.openNewEditor(self, function(ed) {
          ed.makeActive();
          if (typeof callback === "function") callback(ed);
        });
      }
    }
    self.loadEditorViewState = function(editor) {
      if (editorViewState) {
        editor.waitForRender(function() {
          editor.getMonacoEditor().restoreViewState(editorViewState);
        });
      }
    }
    self.saveEditorViewState = function(editor) {
      editorViewState = editor.getMonacoEditor().saveViewState();
    }
    self.search = function(searchStr, replaceStr, forceExpand, newSearchMode) {
      if (locked())
        return null;
      locked(true);
      newSearchMode = (typeof newSearchMode === "number") ? newSearchMode : searchMode();
      var replacePattern = monaco.cside.parseReplaceString(replaceStr);
      var matches = edModel().findMatches(searchStr, false, SEARCH.CONF.useRegex(), SEARCH.CONF.preserveCase(), getWordSeperationValue(), true);
      // calculate the replace value for display, even if we're just searching:
      matches = matches.map(function(match) {
        // Add the .text attribute to convert it to a valid IIdentifiedSingleEditOperation for use in pushEditOperations below
        match.text = SEARCH.CONF.useRegex() ? replacePattern.buildReplaceString(match.matches, SEARCH.CONF.preserveCase()) : replaceStr;
        return match;
      });
      if ((newSearchMode === SEARCH.MODES.REPLACE) && (matches.length > 0)) {
        var newSelections = edModel().pushEditOperations([new monaco.Selection(matches[0].range.startLineNumber, matches[0].range.startColumn, matches[0].range.endLineNumber, matches[0].range.endColumn)], matches, function() {
            return [new monaco.Selection(1,1,1,1)];
        });
      }
      if (newSearchMode === SEARCH.MODES.REPLACE) // re-run initial search after a replace (to keep displayed results valid)
        matches = edModel().findMatches(searchStr, false, SEARCH.CONF.useRegex(), SEARCH.CONF.preserveCase(), getWordSeperationValue(), true);
      locked(false);
      searchVersionId = edModel().getAlternativeVersionId();
      // Continue to signal expansion of any result updates, unless the expansion is due to the collpaseThreshold (rather than user request).
      var expandResults = forceExpand || (matches.length < SEARCH.CONF.collapseThreshold());
      searchResults(new CSIDESearchResults({ searchTerm: searchStr, file: self, versionId: searchVersionId, results: matches, expanded: expandResults, keepOpen: forceExpand }));
      return searchResults();
    }
    self.close = function() {
      if (self.isLocked()) return;
      self.getProject().closeFile(self, function(closed) {
        if (closed) {
          self.getEditors().forEach(function(ed) {
            ed.close();
          });
          edModel().dispose();
        }
      });
    }
    self.copyTo = function(targetProject) {
      if (typeof targetProject !== "object") return;
      if (inErrState() || !loaded() || saving()) return;
      if (targetProject.isReadOnly()) {
        notification("", "Cannot Move File to Read-Only Project", {
          type: 'error',
          closeWith: ["click"]
        });
        return;
      }
      var newPath = targetProject.getPath() + self.getName();
      fh.copyFile(path(), newPath, function(err, fileStat) {
        executeCopy(err);
      });

      function executeCopy(err) {
        if (err) {
          bootbox.alert(err.message);
          console.log(err);
        } else {
          var newFile = new CSIDEFile({
            "path": newPath,
            "source": source,
            "contents": edModel().getValue()
          });
          targetProject.addFile(newFile);
          newFile.load(); //contains _updatePersistenceList()
        }
      }
    }
    self.moveTo = function(targetProject) {
      if (typeof targetProject !== "object") return;
      if (inErrState() || !loaded() || saving() || readOnly()) return;
      if (isImportant) {
        notification("", "Cannot Move Reserved File", {
          type: 'error',
          closeWith: ["click"]
        });
        return;
      }
      if (targetProject.isReadOnly()) {
        notification("", "Cannot Move File to Read-Only Project", {
          type: 'error',
          closeWith: ["click"]
        });
        return;
      }
      var currentProject = self.getProject();
      if (targetProject === currentProject) return;
      var newPath = targetProject.getPath() + self.getName();
      fh.renameFile(path(), newPath, function(err) {
        executeMove(err);
      });

      function executeMove(err) {
        if (err) {
          bootbox.alert(err.message);
          console.log(err);
        } else {
          currentProject.removeFile(self);
          path(newPath);
          targetProject.addFile(self);
          __updatePersistenceList();
        }
      }
    }
    self.del = function() {
        if (inErrState() || !loaded() || saving()) return;
        if (isImportant) {
          notification("", "Cannot Delete Reserved File", {
            type: 'error',
            closeWith: ["click"]
          });
          return;
        } else if (readOnly()) {
          notification("", "Cannot Delete Read-Only File", {
            type: 'error',
            closeWith: ["click"]
          });
          return;
        } else {
          bootbox.confirm("<h3>Confirm</h3><p>Are you sure you want to permanently delete '" + self.getName() + "'?</p>" + "<p style='font-size:12px;'>" + path() + "<p>",
            function(result) {
              if (result) {
                executeDeletion();
              }
            }
          );
        }

        function executeDeletion() {
          fh.deleteFile(path(), function(err) {
            if (err) {
              bootbox.alert(err.message);
            } else {
              self.close();
            }
          });
        }
      }

    //Update dirty status, char count etc - on change
    var __updateOnModelEdit = __limitExecution(function() {
      if (!saving())
        lastVersionId !== edModel().getAlternativeVersionId() ? dirty(true) : dirty(false);
      if (searchResults().getSearchTerm() != "")
        searchResults().getVersionId !== edModel().getAlternativeVersionId() ? self.search(searchResults().getSearchTerm(), null /* replaceStr */, searchResults() && searchResults().isExpanded() /* forceExpand */, SEARCH.MODES.SEARCH) : null;
      charCount(edModel().getValueLength());
      if (wordCountOn() > 0)
        wordCount(__wordCount(edModel().getValue()));
    }, 250);

    function updateOnModelEdit() {
      __updateOnModelEdit();
    }

  }

  function CSIDEIssue(issueData) {
    var self = this;

    //INSTANCE VARIABLES
    var file = issueData.file || null;
    var project = issueData.project || null;
    if (project === null) {
      if (file) {
        project = file.getProject();
      } else {
        throw new Error("A CSIDEIssue must have a valid project or scene!")
      }
    }
    var desc = issueData.desc || "No description available";
    var lineHandle = null;
    var lineNum = ((typeof issueData.lineNum === "number") && (issueData.lineNum > -1)) ? issueData.lineNum : null;
    var severity = issueData.severity || 2;
    var canDismiss = issueData.canDismiss || false; // runtime errors can be dismissed
    var date, time;

    var d = new Date();
    date = d.getDate() + "/" + (d.getMonth() + 1) + "/" + d.getFullYear();
    time = d.getHours() + ":" + d.getMinutes();

    //GETTER METHODS
    self.getFile = function() {
      return file;
    }
    self.getDesc = function() {
      return desc;
    }
    self.getDate = function() {
      return date;
    }
    self.getTime = function() {
      return time;
    }
    self.getLineNum = function() {
      return lineHandle ? lineHandle.lineNo() : lineNum;
    };
    self.getSeverity = function() {
      return severity;
    }
    self.getIconClasses = function() {
      switch(severity) {
        case monaco.MarkerSeverity.Error:
          return "fa fa-bug error";
        case monaco.MarkerSeverity.Warning:
          return "fa fa-warning warning";
        case monaco.MarkerSeverity.Info:
          return "fa fa-info-circle info";
        default:
          return "fa fa-info-circle";
      }
    }
    self.isActive = function() {
      return activeIssue() === self;
    }
    self.canDismiss = function() {
      return canDismiss;
    }
    self.dismiss = function() {
      project.removeIssue(self);
      if (file) {
        file.removeIssue(self);
      }
    }
    self.show = function() {
      if (!file) {
        return;
      }
      if (typeof self.getLineNum() === "number") {
        file.focusLine(self.getLineNum(), true);
      } else {
        file.viewInEditor();
      }
    }
  }

  function CSIDESetting(settingData) {
    var setting = this;
    var value = ko.observable(settingData.value);
    value.extend({ notify: 'always' });
    var id = settingData.id;
    var name = settingData.name;
    var selectedOption = 0;
    var type = settingData.type || "binary";
    var cat = settingData.cat || "app";
    var desc = ko.observable(settingData.desc || "");
    var visible = ko.observable(true);

    if (type === "binary") {
      var options = ko.observableArray([{
        "desc": "on",
        "value": true
      }, {
        "desc": "off",
        "value": false
      }]);
    } else if (type === "number")  {
      value.extend({ notify: 'always', validate: settingData.validate.bind(setting) });
    } else {
      var options = ko.observableArray(settingData.options);
    }

    //ACCESSOR METHODS
    setting.getValue = ko.computed(function() {
      return value();
    }, this);
    setting.getId = function() {
      return id;
    }
    setting.getName = function() {
      return name;
    }
    setting.getType = function() {
      return type;
    }
    setting.getCat = function() {
      return cat;
    }
    setting.getOptions = ko.computed(function() {
      return options ? options() : null;
    }, this);
    setting.getSelectedOptionId = function () {
      for (var i = 0; i < options().length; i++)
        if (value() == options()[i].value)
          return i;
      return null;
    }
    setting.getDesc = ko.computed(function() {
      return desc();
    }, this);
	setting.isVisible = ko.computed(function() {
      return visible();
	}, this);

    //MUTATOR METHODS
    setting.setDesc = function(val) {
      desc(val);
    }
    setting.apply = settingData.apply; // unique apply method for each setting
    setting.toggle = function(option, evt) {
      if (type != "binary") {
        value(option.value);
      } else if ((selectedOption + 1) == options().length) {
        selectedOption = 0;
        value(options()[selectedOption].value);
      } else {
        selectedOption += 1;
        value(options()[selectedOption].value);
      }
    }
    setting.setOptions = function(optionList) {
      options(optionList);
    }
    setting.setValue = function(newVal) {
      value(newVal);
    }
    setting.setVisibility = function(newVal) {
        if (typeof newVal == "boolean")
          visible(newVal);
    }
    value.subscribe(function(option) {
      config.settings[cat][id] = value(); //store
      if (typeof value.isErroneous === "undefined" || !value.isErroneous()) {
        setting.apply(value());
        __updateConfig(); //then write new settings object to localStorage
      }
    });

    setting.max = settingData.max || null;
    setting.min = settingData.min || null;
    setting.step = settingData.step || null;

    setting.extAPI = {
      getName: setting.getName,
      getType: setting.getType,
      getDesc: setting.getDesc,
      getValue: setting.getValue,
      value: value,
      toggle: setting.toggle,
      getOptions: setting.getOptions,
      isVisible: setting.isVisible,
      max: setting.max,
      min: setting.min,
      step: setting.step
    }
  }

  var edId = 0;
  function __createEditorAnchor() {
    var li = document.createElement("LI");
    li.setAttribute("name", "monaco-anchor-" + edId++);
    li.style.flexGrow = "1";
    // hide by default as this might not be for the active project
    li.style.display = "none";
    document.getElementById("editor-list").appendChild(li);
    return li;
  }

  var MIN_EDITOR_WIDTH = 400; /* (pixels) used to auto-inflate active editor size */
  function CSIDEEditor(data) {
    var self = this;
    var _flexSize = ko.observable(1);
    var _pinned = ko.observable(false);
    var _file = ko.observable(data.file || null);
    var _cursorPos = ko.observable({lineNumber: 0, column: 0});
    var _selectedChars = ko.observable(0);
    var _editorDOMAnchor = __createEditorAnchor();
    var _monacoEditor = monaco.editor.create(_editorDOMAnchor, editorOptionStore);

    self.waitForRender = function(func) {
      __onElementRender("li[name='" + self.getAnchor().getAttribute("name") + "'] > div", func);
    }

    self.getName = function() {
      if (!_file()) return "";
      var editorName = _file().getName();
      if (_type === "diff") {
        editorName = "Diff: " + editorName;
      }
    }

    self.saveFile = function() {
      _file().save();
    }

    self.assignAnchor = function(htmlElement) {
      _editorDOMAnchor = htmlElement;
    }

    self.getAnchor = function() {
      return _editorDOMAnchor;
    }

    self.getCursorPositionString = function() {
      if (!_monacoEditor) return "";
      if (!_cursorPos()) return "";
      return "Ln " + (_cursorPos().lineNumber) + ", Col " + _cursorPos().column;
    };

    self.getCharCountString = function() {
      if (!_monacoEditor) return "";
      var charCount = _file().getCharCount();
      if (_selectedChars() > 0) {
        return charCount + " (" + _selectedChars() + ")";
      }
      return charCount;
    };

    self.getWordCountString = function() {
      if (!_monacoEditor) return "";
      var excludeCommands = wordCountOn() > 1;
      var wordCount = _file().getWordCount()[excludeCommands ? "excmds" : "incmds"];
      var suffix = (excludeCommands) ? " [excl. cmds]" : " [inc. cmds]";
      if (_selectedChars() > 0) {
        var counts = __wordCount(_monacoEditor.getModel().getValueInRange(_monacoEditor.getSelection()));
        var selectedCount = (excludeCommands) ? counts.excmds : counts.incmds;
        return (wordCount + (" (" + selectedCount + ") " + suffix));
      }
      return wordCount + suffix;
    };

    self.getDocModel = function() {
      if (_monacoEditor) {
        return _monacoEditor.getModel();
      }
      return null;
    }

    self.setDocModel = function(model) {
      if (_monacoEditor) {
        _monacoEditor.setModel(model);
      }
    }

    self.getMonacoEditor = function() {
      return _monacoEditor;
    }

    self.getFile = function() {
      return _file();
    }

    self.setFile = function(newFile, diffFile) {
      var file = _file();
      if (file.getProject() !== newFile.getProject()) {
        file.getProject().unsubscribeEditor(self);
        newFile.getProject().subscribeEditor(self);
      }
      file.saveEditorViewState(self);
      newFile.loadEditorViewState(self);
      var model = newFile.getModel();
      _monacoEditor.updateOptions(Object.assign(editorOptionStore, { insertSpaces: newFile.usingSpaces(), tabSize: newFile.getIndentSize(), indentSize: newFile.getIndentSize() }));
      _monacoEditor.setModel(model);
      _file(newFile);
    }

    self.getName = function() {
      if (_file())
        return _file().getName();
      return "Empty";
    }

    function _dispose() {
      if (_monacoEditor) _monacoEditor.dispose();
      if (_editorDOMAnchor) {
        // li -> #editor-list
        _editorDOMAnchor.parentElement.removeChild(_editorDOMAnchor);
      }
    }

    self.show = function() {
      if (_editorDOMAnchor) _editorDOMAnchor.style.display = "";
    }

    self.hide = function() {
       if (_editorDOMAnchor) _editorDOMAnchor.style.display = "none";
    }

    self.close = function() {
      var file = _file();
      file.getProject().unsubscribeEditor(self);
      file.saveEditorViewState(self);
      _dispose();
      var aEd = activeEditor();
      if (aEd === self) {
        activeEditor(null);
      }
    }

    self.pin = function() {
      _pinned(true);
    }

    self.unpin = function() {
      _pinned(false);
    }

    self.resize = function(flexSize, project) {
      project = project || activeProject();
      if (!flexSize) {
        var edCount = project.getEditors().length;
        if ((_editorDOMAnchor.parentElement.clientWidth / edCount) < MIN_EDITOR_WIDTH) {
          flexSize = edCount;
        } else {
          flexSize = 1;
        }
      }
      _editorDOMAnchor.style.flexGrow = flexSize;
      _flexSize(flexSize);
    }

    self.makeActive = function() {
      var oldEd = null;
      var isNewProject = activeEditor() && (activeEditor().getFile().getProject() !== activeProject());
      /* TODO: Revisit manual resizing.
         For now this is a simple flexbox hack to keep
         the active editor from getting too small.
       */
      if (oldEd = activeEditor()) {
        oldEd.resize(1, oldEd.getFile().getProject());
      }
      self.resize();
      activeEditor(self);
      if (!_monacoEditor.hasTextFocus()) _monacoEditor.focus();
    }

    self.isActive = function() {
      return activeEditor() === self;
    }

    self.isPinned = function() {
      return _pinned();
    }

    self.flexSize = function() {
      return _flexSize();
    }

    self.getFileStateCSS = function() {
      if (_file().isDirty()) {
        return "codicon codicon-circle-outline";
      } else {
        return "codicon codicon-close";
      }
    }

    self.getPinStateCSS = function() {
      if (_pinned()) {
        return "codicon codicon-pinned";
      } else {
        return "codicon codicon-pin";
      }
    }

    // initialize various monaco editor configurations
    __registerEditorActions(_monacoEditor);
    __overrideEditorServices(_monacoEditor);
    _monacoEditor.onDidFocusEditorText(function() {
      self.makeActive();
    });

    var updateCursorInfo = __limitExecution(function(evt) {
      _selectedChars(_monacoEditor.getModel().getValueInRange(_monacoEditor.getSelection()).length);
      _cursorPos(evt.position);
    }, 250);

    _monacoEditor.onDidChangeCursorPosition(function(evt) {
      updateCursorInfo(evt); // only displays primary selection / cursor
    });
    _cursorPos(_monacoEditor.getPosition());

  }

  // ╔═╗┬ ┬┌┐ ┬  ┬┌─┐  ╔═╗┌─┐┌─┐┌─┐┌─┐
  // ╠═╝│ │├┴┐│  ││    ╚═╗│  │ │├─┘├┤
  // ╩  └─┘└─┘┴─┘┴└─┘  ╚═╝└─┘└─┘┴  └─┘

  var self = this;

  if (usingNode) {
    var CSIDE_version = gui.App.manifest.version;
    var nw_version = process.versions['node-webkit'];
    var platform = (process.platform === "darwin" ? platform = "mac_os" : platform = process.platform);
    var execPath = (platform === "mac_os") ? process.execPath.substring(0, process.execPath.lastIndexOf('/') + 1) : process.execPath.substring(0, process.execPath.lastIndexOf('\\') + 1);
    var updating = false;
    var autoSaveFn = null;
    var autoUpdateCheckFn = null;
	var autoSuggestFn = null;
    self.isUpdating = function() {
      return updating;
    }
  } else {
    var CSIDE_version = "Dropbox Alpha";
    var platform = "web-dropbox";
  }

  var CONST_IMG_PREFIX = "csideimg_";

  //INSTANCE VARIABLES
  var user = {
    "name": usingNode ? nodeRequire('username').sync() : 'Dropbox User',
    "path": "/"
  }
  user.name = user.name.charAt(0).toUpperCase() + user.name.slice(1);

  var projectMenuOptions = ko.observableArray([
    new menuOption("Add new scene", function(menu) {
      menu.getTarget().addNewFile(menu.getTarget(), "untitled");
    }),
    new menuOption("Open all scenes", function(menu) {
      menu.getTarget().openAllScenes();
    }),
    new menuOption("Reload all files", function(menu) {
      menu.getTarget().reloadAllFiles();
    }),
    new menuOption("Review", function(menu) {
      //do nothing
    }, [
      new menuOption("Word count", function(menu) {
        cside.showWordCount(menu.getTarget());
      })
    ]),
    new menuOption("Export", function(menu) {
      //do nothing
    }, [
      new menuOption("All files to folder", function(menu) {
        menu.getTarget().exportFiles();
      })
    ]),
    new menuOption("Open folder in " + (platform === "mac_os" ? "Finder" : "Explorer"), function(menu) {
      menu.getTarget().openFolder();
    }),
    new menuOption("Show/hide project", function(menu) {
      menu.getTarget().setExpand();
    }),
    new menuOption("Close project", function(menu) {
      menu.getTarget().close();
    })
  ]);

  var fileMenuOptions = ko.observableArray([
    new menuOption("Open", function(menu) {
      //do nothing
    }, [
      new menuOption("In new editor", function(menu) {
        self.openNewEditor(menu.getTarget());
      }),
    ]),
    new menuOption("Edit", function(menu) {
      //do nothing
    }, [
      new menuOption("Convert all spaces to tabs", function(menu) {
        activeEditor().getMonacoEditor().getAction('editor.action.indentationToTabs').run();
      }),
      new menuOption("Convert all tabs to spaces", function(menu) {
        activeEditor().getMonacoEditor().getAction('editor.action.indentationToSpaces').run();
      })
    ]),
    new menuOption("Review", function(menu) {
      //do nothing
    }, [
      new menuOption("Word count", function(menu) {
        cside.showWordCount(menu.getTarget());
      })
    ]),
    new menuOption("Reload", function(menu) {
      var file = menu.getTarget();
      var callback = function(err, file) {
        if (!err && activeFile() === menu.getTarget()) {
          file.viewInEditor();
        }
      }
      if (file.isDirty()) {
        bootbox.confirm("<h3>Warning</h3><p>The file '" + file.getName() + "' has unsaved changes. Are you sure you wish to reload it?</p>", function(result) {
          if (result)
            file.load(callback);
        });
      } else {
        file.load(callback);
      }
    }),
    new menuOption("Close", function(menu) {
      menu.getTarget().close();
    }),
    new menuOption("Delete file", function(menu) {
      menu.getTarget().del();
    }),
  ]);

  var EditorTagOptions = ko.observableArray([
    new menuOption("Close editor", function(menu) {
      menu.getTarget().close();
    }),
    new menuOption("Close other editors", function(menu) {
      var project = cside.getActiveProject();
      var thisEditor = menu.getTarget();
      var projectEditors = project.getEditors().slice();
      var editorsToClose = projectEditors.filter(function(ed, index) {
        return ed !== thisEditor;
      });
      editorsToClose.forEach(function(ed) { ed.close(); });
    }),
    new menuOption("Close editors to the right", function(menu) {
      var project = cside.getActiveProject();
      var thisEditor = menu.getTarget();
      var projectEditors = project.getEditors().slice();
      var thisEditorIndex = projectEditors.indexOf(thisEditor);
      var editorsToClose = projectEditors.filter(function(ed, index) {
        return index > thisEditorIndex;
      });
      editorsToClose.forEach(function(ed) { ed.close(); });
    }),
    new menuOption("Close all editors", function(menu) {
      var project = cside.getActiveProject();
      var projectEditors = project.getEditors().slice();
      projectEditors.forEach(function(ed) { ed.close(); });
    })
  ]);

  if (usingNode) {
    fileMenuOptions.push(
      new menuOption("Export", function(menu) {
        //do nothing
      }, [
        new menuOption("Copy file to folder", function(menu) {
          var file = menu.getTarget();
          fh.selectFolder(function(newPath) {
            if (newPath) {
              bootbox.confirm("<h3>Warning</h3><p>This will <b>overwrite</b> any file with the same name in '<i>" + newPath + "</i>'.<br>Are you sure you wish to continue?</p>",
                function(result) {
                  if (result) {
                    fh.copyFile(file.getPath(), newPath + file.getName(), function(err, data) {
                      if (err) {
                        notification("Export Failed", err.message, {
                          type: "error"
                        });
                      } else {
                        var note;
                        var buttons = [{
                          addClass: 'btn',
                          text: 'Show Folder',
                          onClick: function(note) {
                            __openFolder(newPath);
                            note.close();
                          }
                        }];
                        note = notification("Export Succesful", "Copied " + file.getName() + " to " + newPath, {
                          type: "success",
                          buttons: buttons
                        });
                        note.setTimeout(3000);
                      }
                    });
                  }
                }
              );
            }
          });
        }),
        new menuOption("Print file", function(menu) {
          nw.Window.open("file://" + menu.getTarget().getPath(), {
            focus: true,
            width: 800,
            height: 600
          }, function(win) {
            win.window.print();
          });
        })
      ])
    );
    // Tests only allowed on desktop version
    projectMenuOptions.splice(4, 0,
      new menuOption("Import", function(menu) {
        //do nothing
      }, [
        new menuOption("Image (as scene)", function(menu) {
          if (menu.getTarget().isReadOnly()) {
            return;
          }
          fh.selectImage(function(path) {
            if (path) {
              __createImageScene(menu.getTarget(), path);
            }
          });
        })
      ])
    );
    projectMenuOptions.splice(6, 0,
      new menuOption("Test Project", function(menu) {
          //do nothing
        }, [
          new menuOption("Quicktest", function(menu) {
            menu.getTarget().test("quick");
          }),
          new menuOption("Randomtest", function(menu) {
            if (platform != "web-dropbox")
              menu.getTarget().test("random");
            else
              bootbox.alert("<h3>Apologies...</h3><p>But due to technical limitations randomtest can only be run in the Desktop version of the Choicescript IDE.</p></h3>");
          })
        ]
      )
    );
    projectMenuOptions()[5].getSubMenuOptions().push(
      new menuOption("Compiled game", function(menu) {
        menu.getTarget().compile();
      })
    );
  }

  var panelStatus = {
    "scene": ko.observable(true),
    "tab": ko.observable(true)
  }

  // these are hoisted intentionally for
  // use in the following definitions (mac menu etc.)
  var activeProject = ko.observable(null);
  var activeEditor = ko.observable(null);
  var activeIssue = ko.observable(null);
  var activeFile = ko.computed(function() {
    return activeEditor() ? activeEditor().getFile() : null;
  }, this);

  self.togglePanel = function(panel, force) {
    // force is an optional boolean
    var project;
    var isOpen = typeof force === "boolean" ? force : !panelStatus[panel]();
    panelStatus[panel](isOpen);
    // resize editors automatically
    var ed;
    if (ed = activeEditor()) {
      ed.resize();
    }
  }
  self.isPanelOpen = function(panel) {
    return panelStatus[panel]();
  }
  var SEARCH = {
    MODES: { SEARCH: 0, REPLACE: 1 },
    CONF: {
      wordSeperators: "`~!@#$%^&*()-=+[{]}\|;:'\",.<>/?",
      // The number of results that triggers an automatic UI collapse
      collapseThreshold: ko.observable(6),
      // Controls whether the find box expects regexes and the replace box replace patterns
      useRegex: ko.observable(false).extend({ callFunc: { func: function() { activeProject().search("", "", SEARCH.MODES.SEARCH); }}}),
      preserveCase: ko.observable(true).extend({ callFunc: { func: function() { activeProject().search("", "", SEARCH.MODES.SEARCH); }}}),
      matchWholeWord: ko.observable(false).extend({ callFunc: { func: function() { activeProject().search("", "", SEARCH.MODES.SEARCH); }}}),
      searchOnType: ko.observable(true)
    }
  }
  self.SEARCH_MODES = SEARCH.MODES;
  function getWordSeperationValue() {
    if (SEARCH.CONF.matchWholeWord())
      return SEARCH.CONF.wordSeperators;
    return null;
  }
  var searchMode = ko.observable(SEARCH.MODES.SEARCH);
  searchMode.extend({ callFunc:
    {
      func: function(newVal) {
        setTimeout(function() { document.getElementById((newVal == SEARCH.MODES.REPLACE) ? "replaceBox" : "searchBox").focus(); }, 200);
        activeProject().search("", "", SEARCH.MODES.SEARCH);
      }
    }
  });
  self.toggleSearchMode = function(newSearchMode) {
    if (typeof newSearchMode === "number") {
      searchMode(newSearchMode);
    } else {
      switch(searchMode()) {
        case SEARCH.MODES.REPLACE:
          newSearchMode = SEARCH.MODES.SEARCH;
          break;
        case SEARCH.MODES.SEARCH:
          newSearchMode = SEARCH.MODES.REPLACE;
          break;
        default:
          throw new Error("Unrecognized search mode: " + searchMode() + ". Please report this.");
      }
      searchMode(newSearchMode);
    }
  }
  self.inReplaceMode = ko.computed(function() {
    return searchMode() === SEARCH.MODES.REPLACE;
  }, this);
  self.searchToggles = ko.observableArray([
    { title: "Match Whole Word", cssClass: 'codicon-whole-word', value: SEARCH.CONF.matchWholeWord },
    { title: "Use Regular Expression", cssClass: 'codicon-regex', value: SEARCH.CONF.useRegex },
    { title: "Match Case", cssClass: 'codicon-case-sensitive', value: SEARCH.CONF.preserveCase },
    { title: "Search on Type", cssClass: 'codicon-record-keys', value: SEARCH.CONF.searchOnType }
  ]);

  self.issueToggles = [
    { 'text': 'Errors' , 'fa': 'fa fa-bug', 'color': 'salmon', 'state': ko.observable(true), severity: monaco.MarkerSeverity.Error },
    { 'text': 'Warnings', 'fa': 'fa fa-warning', 'color': '#edc979', 'state': ko.observable(true), severity: monaco.MarkerSeverity.Warning },
    { 'text': 'Infos', 'fa': 'fa fa-info-circle', 'color': '#799fed', 'state': ko.observable(true), severity: monaco.MarkerSeverity.Info },
    { 'text': 'Hints', 'fa': 'fa fa-question-circle', 'color': '#b9b9b9', 'state': ko.observable(false), severity: monaco.MarkerSeverity.Hint }
  ]

  self.getActiveIssueTypes= ko.computed(function() {
    var activeTypes = [];
    for (var type = 0; type < self.issueToggles.length; type++) {
      if (self.issueToggles[type].state()) activeTypes.push(self.issueToggles[type].severity);
    }
    return activeTypes;
  });

  /*
  arg.item - the actual item being moved
  arg.sourceIndex - the position of the item in the original observableArray
  arg.sourceParent - the original observableArray
  arg.sourceParentNode - the container node of the original list. Useful if moving items between lists, but within a single array.
    The value of this in the callback will be the target container node.
  arg.targetIndex - the position of the item in the destination observableArray
  arg.targetParent - the destination observableArray
  */
  self.moveEditor = function(arg, event, ui) {
    var list = document.getElementById("editor-list");
    var movingLi = arg.targetParent()[arg.sourceIndex].getAnchor();
    var targetLi = arg.targetParent()[arg.targetIndex].getAnchor();
    if (list.children.length <= arg.targetIndex) {
      list.removeChild(movingLi);
      list.appendChild(movingLi, list.lastElementChild);
    } else if (arg.targetIndex > arg.sourceIndex) {
      list.removeChild(movingLi);
      list.insertBefore(movingLi, targetLi.nextSibling);
    } else {
      list.removeChild(movingLi);
      list.insertBefore(movingLi, targetLi);
    }
    /*var moving = g_editors.indexOf(arg.targetParent[arg.sourceIndex]);
    var target = g_editors.indexOf(arg.targetParent[arg.targetIndex]);
    var cache = g_editors()[moving];
    g_editors.replace(g_editors()[moving], g_editors()[target]);
    g_editors.replace(g_editors()[target], cache);*/
  }

  self.openNewEditor = function(file, callback) {
    // don't allow multiple editors per file
    if (file.isSelected()) {
      file.viewInEditor();
      if (typeof callback === "function") callback(file.getEditors()[0]);
      return;
    }
    var ed = new CSIDEEditor({file: file});
    ed.setFile(file);
    if (file.getProject() === activeProject())
      ed.show();
    file.getProject().subscribeEditor(ed);
    if (typeof callback === "function") callback(ed);
  }

  if (platform === "mac_os") {
    var nativeMenuBar = new nw.Menu({
      type: "menubar"
    });
    if (process.platform === "darwin") {
      nativeMenuBar.createMacBuiltin("CSIDE");
    }
    win.menu = nativeMenuBar;
    (function() {
      var projectMenu = new nw.Menu();
      projectMenu.getTarget = activeProject;
      var subMenu;
      var options = projectMenuOptions();
      for (var i = 0; i < options.length; i++) {
        if (options[i].getSubMenuOptions()) {
          subMenu = new nw.Menu();
          for (var o = 0; o < options[i].getSubMenuOptions().length; o++) {
            subMenu.append(new nw.MenuItem({
              label: options[i].getSubMenuOptions()[o].getLabel(),
              click: options[i].getSubMenuOptions()[o].doAction.bind(null, projectMenu)
            }));
          }
          projectMenu.append(new nw.MenuItem({
            label: options[i].getLabel(),
            click: options[i].doAction.bind(null, projectMenu),
            submenu: subMenu
          }));
        } else {
          projectMenu.append(new nw.MenuItem({
            label: options[i].getLabel(),
            click: options[i].doAction.bind(null, projectMenu)
          }));
        }
      }
      var index = ((platform === "mac_os") ? 3 : 1);
      win.menu.insert(new nw.MenuItem({
        label: "Project",
        submenu: projectMenu
      }), index);
    })();

    (function() {
      var fileMenu = new nw.Menu();
      fileMenu.getTarget = activeFile;
      var subMenu;
      var options = fileMenuOptions();
      for (var i = 0; i < options.length; i++) {
        if (options[i].getSubMenuOptions()) {
          subMenu = new nw.Menu();
          for (var o = 0; o < options[i].getSubMenuOptions().length; o++) {
            subMenu.append(new nw.MenuItem({
              label: options[i].getSubMenuOptions()[o].getLabel(),
              click: options[i].getSubMenuOptions()[o].doAction.bind(null, fileMenu)
            }));
          }
          fileMenu.append(new nw.MenuItem({
            label: options[i].getLabel(),
            click: options[i].doAction.bind(null, fileMenu),
            submenu: subMenu
          }));
        } else {
          fileMenu.append(new nw.MenuItem({
            label: options[i].getLabel(),
            click: options[i].doAction.bind(null, fileMenu)
          }));
        }
      }
      var index = ((platform === "mac_os") ? 4 : 2);
      win.menu.insert(new nw.MenuItem({
        label: "File",
        submenu: fileMenu
      }), index);
    })();

    if (platform != "mac_os") {
      nw.Window.get().menu = win.menu; // display on Windows
    }
    else {
      ko.extenders.updateMenuBarStates = function(target, option) {
        target.subscribe(function(file) {
          var b = file ? true : false;
          var projectIndex = ((platform === "mac_os") ? 3 : 1);
          var fileIndex = ((platform === "mac_os") ? 4 : 2);
          win.menu = nw.Window.get().menu;
          for (var index = projectIndex; index <= fileIndex; index++) {
            for (var item = 0; item < win.menu.items[index].submenu.items.length; item++) {
              win.menu.items[index].submenu.items[item].enabled = b;
            }
          }
          nw.Window.get().menu = win.menu;
        });
        return target;
      };
      activeFile.extend({ updateMenuBarStates: "" });
      activeEditor.valueHasMutated(); //force initialMenubarStates call
    }
  }

  var reservedSceneNames = "(STARTUP.TXT|CHOICESCRIPT_STATS.TXT)"; //Should be in upper case
  var recentFileColours = ko.observableArray(["#72c374", "#7797ec", "#d9534f", "#a5937a", "#ff8d2b", "#e079f5", "#00a8c3", "#777777"]);
  var uiColour = ko.observable().extend({
    notify: 'always',
    callFunc: { func: function() {
      // refresh header colour on documentation
      if (self.tabs) {
        var path = document.getElementById("help-tab-frame").contentWindow.location.href;
        if (path && path.match(/\.html$/))
          __reloadTab(__getTab("help"), path);
      }
    }}
  });
  uiColour("90,90,90");
  var consoleOpen = ko.observable(false);
  var projects = ko.observableArray([]);
  var allEditors = ko.computed(function() {
    return projects().reduce(function(editors, currentProject, currentIndex, array) {
      return editors.concat(currentProject.getEditors());
    }, []);
  }, this);
  var wordCountOn = ko.observable(true);
  var config;
  var defaultConfig = {
    "settings": {
      "editor": {
        "usespaces": true,
        "smartindent": true,
        "tabsize": 4,
        "indentspaces": 4,
        "linewrap": true,
        "fontsize": "12px",
        "fontfamily": "'Courier New', Courier, monospace",
        "spell_dic": "en_US",
        "theme": "cs-dark",
        "night-mode": false,
        "spellcheck": true,
        "autosuggest": false,
        "autoformat": true,
        "word-count": 2,
        "visible-tabs": false,
        "selection-match": false,
        "cursor-match": false
      },
      "app": {
        "persist": true,
        "autosave": true,
        "cmdhelp": false,
        "update-channel": "stable",
        "ui-colour": "90,90,90",
        "project-path": "default" //COME BACK TO ME CJW
      }
    },
	"justUpdated": false,
    "openProjects": [],
    "recentColours": [],
    "userDictionary": {},
    "tabs": [
      "game",
      "issues",
      "settings",
      "search",
      "help",
      "dictionary"
    ]
  };
  var editorOptionStore = {
    theme: 'cs-light',
    value: "",
    language: 'choicescript',
    autoIndent: true,
    formatOnType: true,
    dragAndDrop: false,
    renderLineHighlight: "all",
    minimap: {enabled:false},
    wordWrap: 'bounded',
    //wordWrapColumn: 60,
    wrappingIndent: "same",
    roundedSelection: true,
    folding: true,
    automaticLayout: true,
    detectIndentation: false,
    lightbulb: { enabled: true },
    glyphMargin: true,
    model: null
  };
  if (usingNode) {
    defaultConfig.tabs.push("examples");
  }
  config = defaultConfig;
  try {
    storedConfig = JSON.parse(localStorage.getItem("CSIDE_appConfig"));
    for (var item in storedConfig) { config[item] = storedConfig[item]; }
  } catch (err) {
    bootbox.alert("Sorry, there was a problem parsing your configuration settings.<br> \
		They have been repaired and reset to the defaults.<br><br> \
		<b>Error:</b> " + err.message);
    localStorage.setItem("CSIDE_appConfig", JSON.stringify(defaultConfig));
    config = defaultConfig;
  }
  var userDictionary = {};
  var fh = { //FILE HANDLER
    "writeFile": function(path, data, callback) {
      switch (platform) {
        //WRITE
        case "web-dropbox":
          db.filesUpload({path: path, contents: data, mode:{ ".tag": "overwrite" }, autorename: false})
            .then(function(response) {
              callback(null);
            })
            .catch(function(err) {
              callback(normalizeError(err));
            });
          break;
        default:
          mkdirp(getDirName(path), function(err) {
            if (err) {
              callback(normalizeError(err));
            } else {
              fs.writeFile(path, data, {
                encoding: 'utf8'
              }, function(err) {
                callback(normalizeError(err));
              });
            }
          });
      }
    },
    "getDropboxImageUrl": function(path, callback) {
      // Dropbox Only
      switch (platform) {
        case "web-dropbox":
          db.filesDownload({path:path})
            .then(function(response) {
              try {
                var url = window.URL.createObjectURL(response.result.fileBlob);
                callback(null, url);
              } catch (err) {
                callback(normalizeError(err));
              }
            })
          .catch(function(err) {
            callback(normalizeError(err));
          });
          break;
        default:
          throw new Error("getDropboxImageUrl is a Dropbox only method!");
      }
    },
    "readFile": function(path, callback) {
      switch (platform) {
        //WRITE
        case "web-dropbox":
          db.filesDownload({path:path})
            .then(function(fileData) {
              var reader = new FileReader()
              reader.addEventListener("loadend", function() {
                if (reader.result) {
                  callback(null, new TextDecoder("utf-8").decode(reader.result));
                }
                else {
                  callback({}); // unlikely reader error?
                }
              }); // fh.reader.result
              reader.readAsArrayBuffer(fileData.result.fileBlob);
            })
            .catch(function(err) {
              callback(normalizeError(err));
            });
          break;
        default:
          fs.readFile(path, {
            encoding: 'utf8'
          }, function(err, data) {
            callback(normalizeError(err), data);
          });
      }
    },
    "copyFile": function(oldPath, newPath, callback) {
      switch (platform) {
        case "web-dropbox":
          db.filesCopy({from_path:oldPath, to_path:newPath})
            .then(function(response) {
              callback(null);
            })
            .catch(function(err) {
              callback(normalizeError(err));
            });
          break;
        default:
          fs.readFile(oldPath, {
            encoding: 'utf8'
          }, function(err, data) {
            if (err) {
              callback(normalizeError(err));
            } else {
              fs.writeFile(newPath, data, function(err) {
                callback(normalizeError(err));
              });
            }
          });
      }
    },
    "renameFile": function(oldPath, newPath, callback) {
      switch (platform) {
        case "web-dropbox":
          db.filesMove({from_path:oldPath, to_path:newPath})
            .then(function(response) {
              callback(null);
            })
            .catch(function(err) {
              callback(normalizeError(err));
            });
          break;
        default:
          fs.rename(oldPath, newPath, function(err) {
            callback(normalizeError(err));
          });
      }
    },
    "deleteFile": function(path, callback) {
      switch (platform) {
        case "web-dropbox":
          db.filesDelete({path:path})
            .then(function(response) {
              callback(null);
            })
            .catch(function(err) {
              callback(normalizeError(err));
            });
          break;
        default:
          trash([path], function(err) {
            callback(normalizeError(err))
          });
          break;
      }
    },
    "readDir": function(path, callback, dbMetaData) {
      switch (platform) {
        case "web-dropbox":
          path = (path == "/") ? "" : path;
          db.filesListFolder({path:path})
            .then(function(response) {
              // extra db metadata for file explorer
              if (typeof dbMetaData != "undefined" && dbMetaData == true) // standardize path and folder properties
                callback(null, response.result.entries.map(function(item) { item.path = item.path_lower; item.isFolder = (item[".tag"] == "folder"); return item; }));
              // just return an array of paths for standard use
              else
                callback(null, response.result.entries.map(function(item) { return getLastDirName(item.path_lower); }));
            })
            .catch(function(err) {
              callback(normalizeError(err));
            });
          break;
        default:
          fs.readdir(path, function(err, filePathArray) {
            callback(normalizeError(err), filePathArray);
          });
          break;
      }
    },
    "makeDir": function(path, callback) {
      switch (platform) {
        case "web-dropbox":
          if (path.slice(-1, path.length) == "/") {
            path = path.slice(0, -1); // db API doesn't allow trailing slashes
          }
          db.filesCreateFolder({path:path})
            .then(function(response) {
              callback(null);
            })
            .catch(function(error) {
              if (err && err.status == 403) { //FOLDER ALREADY EXISTS ??? 409??
                delete err.status;
                err.code = "EEXIST";
              }
              callback(normalizeError(err));
            });
          break;
        default:
          mkdirp(path, function(err) {
            callback(normalizeError(err));
          });
          break;
      }
    },
    "stat": function(path, callback) {
      switch (platform) {
        case "web-dropbox":
          db.filesGetMetadata({path: path})
          .then(function(response) {
            callback(null, {mtime: new Date(response.client_modified) })
          })
          .catch(function(err) {
            callback(normalizeError(err));
          });
          break;
        default:
          fs.stat(path, function(err, fileStats) {
            callback(normalizeError(err), fileStats);
          });
          break;
      }
    },
    "selectFolder": function(callback) {
      switch (platform) {
        case "web-dropbox":
          fileBrowser.selectFolders(function(selection) {
            if (selection.length > 0) {
              callback(selection[0].path + '/');
            } else {
              callback(null);
            }
          });
          break;
        default:
          var chooser = $("#selectFolder");
          chooser.off().change(function(evt) {
            callback($(this).val() + '/');
            $(this).val("");
          });
          setTimeout(function() {
            chooser.trigger("click");
          }, 200);
      }
    },
    "selectImage": function(callback) {
      switch (platform) {
        case "web-dropbox":
          bootbox.alert("TODO: Image scene import not yet implemented on the web-version.")
          break;
        default:
          var chooser = $("#getImagePaths");
          chooser.off().change(function(evt) {
            callback($(this).val());
            $(this).val("");
          });
          setTimeout(function() {
            chooser.trigger("click");
          }, 200);
      }
    },
    "selectFiles": function(callback, options) {
      options = options || {};
      if (usingNode) {
        var extensions = options.extensions || [".txt", ".log"];
        var chooser = $("#getFilePaths");
        chooser.attr("accept", extensions.join(","));
        chooser.off().change(function(evt) {
          var selection = $(this).val().split(";");
          if (selection.length === 1 && selection[0] === "") {
            callback(null);
          }
          $(this).val("");
          callback(selection);
        });
        chooser.trigger("click");
      } else {
        fileBrowser.open(function(selection) {
          if (selection.length < 1) {
            callback(null);
          }
          selection = selection.filter(function(file) {
              return !file.isFolder();
            })
            .map(function(file) {
              return file.path;
            });
            callback(selection);
        }, options);
      }
    },
  }

  var normalizeError = function(err) {
    if (!err) return null;
    if (typeof err.message == 'undefined') {
      try {
        err.message = JSON.parse(err.responseText).error;
      } catch (e) {
        err.message = "Unable to get an error description";
      }
    }
    if (typeof err.code == 'undefined') {
      err.code = err.status || "Unknown Error Code";
    }
    // Dropbox's new API format is rather strange, so we do what we can here.
    // With luck we'll migrate to dashingdon in the near future.
    if (typeof err.code != "undefined" && err.code == 409) {
      if (err.error.error[err.error.error[".tag"]][".tag"] == "not_found")
        err.code = 404;
      err.message = "Dropbox: " + err.error.error_summary;
    }
    switch (err.code) {
      case 409:
        if (err.error.error_summary !== "path/not_found/")
          break;
      case "not_found":
      case "ENOENT":
      case 404:
        err.code = 404;
        break;
      case "EEXIST":
        //FILE ALREADY EXISTS
        break;
      case 403:
      case "EACCES":
        //DENIED ACCESS or FORBIDDEN operation
        break;
      default:
        break;
    }
    return err;
  }

  var notification = function(title, message, options) {
    var options = options || {};
    options.theme = "bootstrap-v3";
    options.layout = options.layout || "bottomRight";
    options.type = options.type || "alert";
    options.timeout = options.timeout === false ? false : options.timeout || 5000;
    options.closeWith = options.closeWith === false ? false : options.closeWith || ["click"];
    options.buttons = options.buttons || null;
    if (options.buttons) {
      options.buttons = options.buttons.map(function(btn) {
        return Noty.button(btn.text, btn.addClass, function(note) {
            btn.onClick(note);
          }
        );
      });
    }

    function wrapMessage(title, msg) {
      return "<h5>" + title + "</h5>\
					 <p>" + msg + "</p>";
    }
    options.text = wrapMessage(title, message);
    if (options.progress) {
      options.text += "<progress value='0' max='100'></progress>";
    }
    var n = new Noty(options);
    if (options.progress) {
      n.setProgress = function(val) {
        $(n.barDom).find(".noty_body").find("progress").val(val);
      }
    }
    n.show();
    return n;
  }
  self.notification = function(title, message, options) {
    return notification(title, message, options);
  };

  function _bootboxSelect(msg, opts, callback, currentValue) {
    function _createWideBootboxBtn(val) {
      var btn = document.createElement("button");
      btn.className = "btn " + ((currentValue == val) ? "btn-primary" : "btn-default");
      btn.innerText = val;
      return btn;
    }

    function _createBootBoxBtnWrapper(msg) {
      var template = document.createElement("template");
      template.innerHTML = ("<div class=\"bootbox-select\"><p></p></div>");
      template.content.firstChild.querySelector("p").innerText = msg;
      return template.content.firstChild;
    }

    var div = _createBootBoxBtnWrapper(msg);
    for (var i = 0; i < opts.length; i++) {
      var btnElement = _createWideBootboxBtn(opts[i]);
      (function(x) { btnElement.addEventListener(
        "click", function() { bootbox.hideAll(); callback(opts[x]); }
        );
      })(i);
      div.appendChild(btnElement);
    }
    bootbox.dialog({ message: div, closeButton: false, onEscape: true });
  }

  self.promptForFileIndentation = function() {
    var types = ["Tabs", "Spaces"];
    var docModel = activeEditor().getDocModel();
    if (!docModel) return;
    _bootboxSelect("Select Indentation Unit", types,
      function(unitOpt) {
        var useSpaces = (unitOpt === "Spaces");
        var setting = settings.byId("editor", useSpaces ? "indentspaces" : "tabsize");
        self.getActiveFile().updateUseSpaces(useSpaces);
        __promptForInteger(function(value, errmsg) {
          if (value) {
            self.getActiveFile().updateIndentSize(value);
          } else if (errmsg) {
            bootbox.alert("Invalid value: " + errmsg);
          } else {
            // user cancelled / didn't give a value
          }
        }, "Indentation Size", setting.getValue(), { max: setting.max, min: setting.min });
      }, types[Number(docModel.getOptions().insertSpaces)]
    );
  }

  self.footerBtnHover = function(IDEmodel, evt) {
    var ele = evt.currentTarget;
    switch (evt.type) {
      case "mousedown":
        ele.style.backgroundColor = this.getUIColour(-20);
        break;
      case "mouseover":
        ele.style.backgroundColor = this.getUIColour(-10);
        break;
      case "mouseup":
      case "mouseout":
        ele.style.backgroundColor = "transparent";
        break;
      default:
        return;
    }
  }

  // initiate dropbox:
  if (platform == "web-dropbox") {

    if (!!utils.parseQueryString(window.location.hash).access_token) {
      var db = new Dropbox.Dropbox({ accessToken: utils.parseQueryString(window.location.hash).access_token });
    }
    else {
      var db = new Dropbox.Dropbox({ clientId: "hnzfrguwoejpwbj" });
      db.auth.getAuthenticationUrl(window.location).then((authUrl) => {
        window.location = authUrl;
      });
    }

    // try and source the DB username:
    db.usersGetCurrentAccount().then(function(acc) {
      user.name = acc.name.display_name;
    })
    .catch(function(err) {}); // we don't mind errors, we'll just stick with the default name

  }

  window.db = db;

  var dropboxAuthorised = ko.observable(false);

  //GETTER METHODS
  self.dbAuth = ko.computed(function() {
    return dropboxAuthorised();
  }, this);
  self.getProjects = projects;
  self.getActiveEditor = ko.computed(function() {
    return activeEditor();
  }, this);
  self.getActiveFile = ko.computed(function() {
    return activeFile();
  }, this);
  self.getActiveProject = ko.computed(function() {
    return activeProject();
  }, this);
  self.getRecentFileColours = ko.computed(function() {
    return recentFileColours();
  }, this);
  self.getPlatform = function() {
    return platform;
  }
  self.wordCountOn = ko.computed(function() {
    return wordCountOn();
  });
  self.getUIColour = function(delta) {
    delta = delta || 0;
    if (self.isInNightMode()) {
      delta -= 30;  // darken night-mode colours even further
    }
    var rgb = uiColour().split(",");
    var val;
    for (var i = 0; i < rgb.length; i++) {
      val = (parseInt(rgb[i]) + delta);
      if (val < 0) {
        val = 0;
      } else if (val > 255) {
        val = 255;
      }
      rgb[i] = val;
    }
    var color = rgb.join(",");
    return ("rgb(" + color + ")");
  };
  self.isInNightMode = function() {
    return config.settings.app["night-mode"];
  }

  self.selectTab = function(tab) {
    var tabs = self.tabs();
    for (var i = 0; i < tabs.length; i++) {
      if (tab === tabs[i].id) {
        __selectTab(tab);
        break;
      }
    }
  }

  //MUTATOR METHODS

  //MISC METHODS
  self.readFile = function(url, callback) {
    fh.readFile(url, callback);
  };
  self.getDropboxImageUrl = function(url, callback) {
    fh.getDropboxImageUrl(url, callback);
  };
  self.selectFileClick = function(file, event) {
    var aProject = activeProject();
    var nProject = file.getProject();
    var tProject = (aProject !== nProject) ? nProject : aProject;
    if (file.isSelected()) {
      file.viewInEditor();
      return;
    } else if (!event.shiftKey) {
      var editor = __getFreeEditor(tProject);
      if (editor) {
        editor.setFile(file);
        file.viewInEditor();
        return;
      }
    }
    self.openNewEditor(file, function(ed) {
      if (ed) file.viewInEditor();
    });
  }
  self.session = {
    "save": function(cb) {
      var failed = false;
      var count = projects().length;
      if (count < 1) {
        cb(null);
        return;
      }
      projects().forEach(function(project, index) {
        project.save(function(err) {
          if (err) {
            if (failed) return;
            failed = true;
            return cb(err);
          }
          if (--count == 0) cb(null);
        });
      });
    },
    "isDirty": ko.computed(function() {
      for (var i = 0; i < projects().length; i++) {
        if (projects()[i].isDirty()) {
          return true;
        }
      }
      return false;
    })
  }

  //frameless window control interface
  self.session.win = function() {
    var fullScreen = ko.observable(true);
    return {
      "isFullscreen": ko.computed(function() {
        return fullScreen();
      }, this),
      "toggleMaximize": function() {
        if (fullScreen()) {
          win.restore();
          //platform === "mac_os" ? win.leaveFullscreen() : win.restore();
        } else {
          platform === "mac_os" ? win.enterFullscreen() : win.maximize();
        }
        fullScreen(!fullScreen());
      }
    }
  }();

  function __registerEditorActions(editor) {

    editor.addAction({
      id: 'ignore-word',
      label: 'Ignore Word this Session',
      contextMenuGroupId: "1_modification",
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        var wordObj = ed.getModel().getWordAtPosition(meditor.getSelection().getStartPosition());
        if (wordObj) {
          editor.trigger("", `add-words`, {uri: "", dict: "session", words: [wordObj.word]});
        }
      }
    });

    editor.addAction({
      id: 'add-word-to-dictionary',
      label: 'Add Word to Dictionary',
      contextMenuGroupId: "1_modification",
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        var wordObj = ed.getModel().getWordAtPosition(meditor.getSelection().getStartPosition());
        if (wordObj) {
          editor.trigger("", `add-words`, {uri: "", dict: "persistent", words: [wordObj.word]});
        }
      }
    });

    editor.addAction({
      id: 'replace-project-files',
      label: 'Replace in Project Files',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyR,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        if (!cside.getActiveProject())
          return;
        cside.toggleSearchMode(SEARCH.MODES.REPLACE);
        __selectTab("search");
        cside.togglePanel("tab", true /* open */);
        document.getElementById("replaceBox").focus();
      }
    });

    editor.addAction({
      id: 'search-project-files',
      label: 'Search Project Files',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyF,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        if (!cside.getActiveProject())
          return;
        cside.toggleSearchMode(SEARCH.MODES.SEARCH);
        __selectTab("search");
        cside.togglePanel("tab", true /* open */);
        document.getElementById("searchBox").focus();
      }
    });

    editor.addAction({
      id: 'save-selected-file',
      label: 'Save Selected File',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveEditor().saveFile();
        return null;
      }
    });

    editor.addAction({
      id: 'select-previous-file',
      label: 'Select Previous File',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.PageUp,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        __cycleFileSelection(true);
      }
    });

    editor.addAction({
      id: 'select-next-file',
      label: 'Select Next File',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.PageDown,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        __cycleFileSelection(false);
      }
    });

    editor.addAction({
      id: 'close-selected-file',
      label: 'Close Selected File',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyW,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        if (platform !== "mac_os") {
          cside.getActiveEditor().close();
        }
        return null;
      }
    });

    editor.addAction({
      id: 'add-new-scene',
      label: 'Add New Scene',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyN,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        var project = cside.getActiveProject();
        project.addNewFile(project, "untitled");
        return null;
      }
    });

    editor.addAction({
      id: 'save-selected-project',
      label: 'Save Selected Project',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveProject().save();
        return null;
      }
    });

    editor.addAction({
      id: 'close-selected-project',
      label: 'Close Selected Project',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyW,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveProject().close();
        return null;
      }
    });

    editor.addAction({
      id: 'create-project',
      label: 'Create Project',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyN,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.createProject();
        return null;
      }
    });

    editor.addAction({
      id: 'toggle-scene-panel-project',
      label: 'Toggle Scene Panel',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.Comma,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.togglePanel("scene");
        return null;
      }
    });

    editor.addAction({
      id: 'toggle-tab-panel',
      label: 'Toggle Tab Panel',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.Period,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.togglePanel("tab");
        return null;
      }
    });

    editor.addAction({
      id: 'increase-font-size',
      label: 'Increase Editor Font Size',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.Equal
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        var fontSizeSetting = settings.byId("editor", "fontsize");
        var value = fontSizeSetting.getValue();
        if (value < fontSizeSetting.min) {
          fontSizeSetting.setValue(fontSizeSetting.min);
        } else if (value < fontSizeSetting.max) {
          fontSizeSetting.setValue(++value);
        }
        return null;
      }
    });

    editor.addAction({
      id: 'decrease-font-size',
      label: 'Decrease Editor Font Size',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.Minus
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        var fontSizeSetting = settings.byId("editor", "fontsize");
        var value = fontSizeSetting.getValue();
        if (value > fontSizeSetting.max) {
          fontSizeSetting.setValue(fontSizeSetting.max);
        } else if (value > fontSizeSetting.min) {
          fontSizeSetting.setValue(--value);
        }
        return null;
      }
    });

    editor.addAction({
      id: 'open-all-scenes',
      label: 'Open All Scenes',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyO,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveProject().openAllScenes();
        return null;
      }
    });

    editor.addAction({
      id: 'open-file-browser',
      label: 'Open File Browser',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyO,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.openFileBrowser();
        return null;
      }
    });

    editor.addAction({
      id: 'toggle-bold',
      label: 'Toggle Bold',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyB,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        insertTextTags("[b]", "[/b]");
      }
    });

    editor.addAction({
      id: 'wrap-variable',
      label: 'Wrap Variable',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyD,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        insertTextTags("${", "}");
      }
    });

    editor.addAction({
      id: 'toggle-italics',
      label: 'Toggle Italics',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyI,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        insertTextTags("[i]", "[/i]");
      }
    });

    editor.addAction({
      id: 'toggle-comment',
      label: 'Toggle Comment',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.Slash,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        insertTextTags("*comment ", "", true);
      }
    });

    editor.addAction({
      id: 'quicktest',
      label: 'Quicktest Project',
      keybindings: [
        monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyT,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveProject().test("quick");
        return null;
      }
    });

    editor.addAction({
      id: 'randomtest-project',
      label: 'Randomtest Project',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyT,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveProject().test("random");
        return null;
      }
    });

    editor.addAction({
      id: 'run-project',
      label: 'Run Project',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        cside.getActiveProject().run();
        return null;
      }
    });

    editor.addAction({
      id: 'toggle-console',
      label: 'Toggle ChoiceScript Console',
      keybindings: [
        monaco.KeyMod.Shift | monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyC,
      ],
      precondition: null,
      keybindingContext: null,
      run: function(ed) {
        var open = cside.getActiveProject().toggleConsole();
        if (open) $("#cs-console > input").focus();
      }
    });

  }

  var insertTextTags = function(tagStart, tagEnd, allowSpecialLines) {
    ed = activeEditor();
    if (!ed) return;
    ed = ed.getMonacoEditor();
    var text = ed.getModel().getValueInRange(ed.getSelection());
    if (!text) {
      text = tagStart + tagEnd;
      var currentSel = ed.getSelection();
      var originalSel = Object.assign({}, currentSel);
      currentSel = ed.getModel().pushEditOperations(
        [originalSel], // Return to original pos on undo
        [{range: new monaco.Range(originalSel.startLineNumber, originalSel.startColumn, originalSel.startLineNumber, originalSel.startColumn), text: text }],
        function (inverseEditOperations) { // Set cursor between tags post-edit
          currentSel.startColumn = currentSel.selectionStartColumn = currentSel.positionColumn = (currentSel.startColumn + tagStart.length);
          return [currentSel];
        }
      );
      if (currentSel)
        ed.setSelection(currentSel[0]);
    } else {
      var line;
      var whitespace;
      text = text.split("\n");
      for (var i = 0; i < text.length; i++) {
        line = text[i].replace(/\r?\n|\r/,"");
        if (line === "") continue; //ignore blank lines
        if (!allowSpecialLines && (line.match(/^\s*\*[A-Za-z_]+\b/) || line.match(/^\s*#/))) continue; //ignore full command or option lines
        if (whitespace = line.match(/^\s+/g)) { //retain leading whitespace
          line = line.replace(/^\s+/g, "");
        }
        if ((line.substring(0, tagStart.length) === tagStart) && (line.substring(line.length - tagEnd.length, line.length) === tagEnd)) {
          line = line.substring(tagStart.length, line.length - tagEnd.length); //remove tags
        } else {
          line = tagStart + line + tagEnd; //add tags
        }
        whitespace = whitespace || "";
        text[i] = (whitespace + line);
      }
      text = text.join("\n");
      ed.executeEdits("insertTextTags", [{range: ed.getSelection(), text: text }]);
    }
  }

  var __csideTabs = {
    "game": {
      "id": "game",
      "title": "Game",
      "showTitle": true,
      "iconClass": function() { return "fa fa-cube" },
      "href": ko.observable(""),
      "content": "",
      "visible": ko.observable(true),
      "getHeaderTitle": ko.computed(function() {
        return (activeProject() ? activeProject().getName() : "Run a Project");
      }, this)
    },
    "issues": {
      "id": "issues",
      "title": "Issues",
      "showTitle": true,
      "iconClass": function() { return "fa fa-exclamation-triangle"; },
      "href": "",
      "content": "",
      "visible": ko.observable(true),
      "notificationCount": ko.computed(function() {
        var ap;
        if (ap = activeProject()) {
          var issueCount = ap.issueCount()
          return (issueCount > 99) ? "99+" : issueCount;
        }
        return 0;
      }),
      "getHeaderTitle": ko.computed(function() {
        return (activeProject() ? ("Issues with " + activeProject().getName()) : "Select a Project");
      }, this)
    },
    "settings": {
      "id": "settings",
      "title": "Settings",
      "showTitle": false,
      "iconClass": function() { return "fa fa-cog" },
      "href": "",
      "content": "",
      "visible": ko.observable(true),
      "getHeaderTitle": ""
    },
    "help": {
      "id": "help",
      "title": "Help & Information",
      "showTitle": true,
      "iconClass": function() { return "fa fa-question-circle" },
      "href": ko.observable("help/site/index.html"),
      "onload": function() {
        //__csideTabs["help"].href(this.contentWindow.location);
      },
      "content": "",
      "visible": ko.observable(true),
      "getHeaderTitle": ""
    },
    "search": {
      "id": "search",
      "title": "Search and Replace",
      "showTitle": true,
      "iconClass": function() { return "fa fa-search" },
      "href": "",
      "content": "",
      "visible": ko.observable(true),
      "getHeaderTitle": ko.computed(function() {
        return (activeProject() ?  ((self.inReplaceMode()) ? "Replace" : "Search") + " in " + activeProject().getName() : "Select a Project");
      }, this)
    },
    "dictionary": {
      "id": "dictionary",
      "title": "User Dictionary",
      "showTitle": true,
      "iconClass": function() { return "fa fa-book" },
      "href": "",
      "content": "",
      "visible": ko.observable(true),
      "getHeaderTitle": "User Dictionary"
    },
    "examples": {
      "id": "examples",
      "title": "Example Projects & Templates",
      "showTitle": true,
      "iconClass": function() { return "fa fa-lightbulb-o" },
      "href": "",
      "content": "",
      "visible": ko.observable(true),
      "getHeaderTitle": "Example Projects & Templates"
    }
  }
  self.tabs = ko.observableArray([]);
  self.tabs.subscribe(function(tabList) {
    // Silently drop any tabs we don't recognise.
    for (var i = 0; i < tabList.length; i++)
      if (!tabList[i])
        tabList.splice(i, 1);
  });

  if (usingNode) {

    self.cs_examples = [
      {
        title: "Interactive CSIDE Tutorial",
        desc: "A great starting point tutorial - developed by Vendetta. Useful for those new to both Choicescript and the Choicescript IDE.",
        path: "cs_examples/CSIDE Tutorial/"
      },
      {
        title: "ChoiceScript Basics Tutorial",
        desc: "A simple tutorial template by FairyGodfeather. This example project is designed to get you started with handling name, gender and relationship stats in your ChoiceScript games. A great starting point for any new project!",
        path: "cs_examples/Basics Tutorial/"
      },
      {
        title: "Pronouns with Gender-Neutral Options Template",
        desc: "A template for including gender neutral pronouns in your game (they/them), created by Lynnea Glasser. This includes a variable system to make sure your verbs and pronouns will match (\"They go on ahead\"/\"She goes on ahead\").",
        path: "cs_examples/GNO Pronoun Template/"
      }
    ];

    self.runExample = function(data) {
     __runProject(new CSIDEProject({ "path": data.path }));
    }

    self.cloneExample = function(data) {
      self.createProject("", function(err, project) {
        if (err) {
          notification("Error", err.message, {
            type: "error"
          });
          return;
        }
        __copyProjectTo(data.path, project.getPath(), function(err) {
          if (err) {
            notification("Error", err.message, {
              type: "error"
            });
            return;
          }
          project.openAllScenes();
          notification("Import Successful", data.title + " imported to " + project.getPath(), {
            type: "success"
          });
        });
      }, true);
    }
  }

  function __cycleFileSelection(direction) {
    // "up" = true / "down" = false
    if (!cside.getActiveProject())
      return;
    var index;
    var currentEditor = cside.getActiveEditor();
    var currentFile = cside.getActiveFile();
    var newFile = null;
    var fileList = cside.getActiveProject().getFiles();
    var index = fileList.indexOf(cside.getActiveFile());
    if (!currentFile || index < 0)
      return null;
    while (!newFile && newFile !== currentFile) {
      if (direction) {
        if (index > 0) {
          newFile = fileList[--index];
        } else {
          newFile = fileList[fileList.length - 1];
          index = [fileList.length - 1];
        }
      } else {
        if (index < (fileList.length - 1)) {
          newFile = fileList[++index];
        } else {
          newFile = fileList[0];
          index = 0;
        }
      }
      if (newFile === currentFile) break;
      if (newFile.isSelected()) newFile = null;
      else { currentEditor.setFile(newFile); }
    }
    return null;
  }

  function __getTab(id) {
    var tabs = self.tabs();
    for (var i = 0; i < tabs.length; i++) {
      if (id === tabs[i].id) {
        return tabs[i];
      }
    }
    return null;
  }

  /* Returns an unpinned editor if one is available,
     preferring the currently active editor. */
  function __getFreeEditor(project) {
    var editor;
    if (!project) {
      project = activeProject();
    }
    if (project === activeProject()) {
      editor = activeEditor();
    }
    if (!editor || editor.isPinned()) {
      if (project) {
        editor = project.getEditors().find(function(ed) {
          return !ed.isPinned();
        });
      }
    }
    return editor;
  }

  // obtain CSIDEHelp object for interacting with help and information tab
  function __getCSIDEHelp() {
    for (var i = 0; i < frames.length; i++)
      if (frames[i].csideHelp)
        return frames[i].csideHelp;
    return null;
  }

  var settings = {
    'editor': ko.observableArray([
      new CSIDESetting({
        "id": "smartindent",
        "name": "Smart Indentation",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Automatically indent (or dedent) the cursor after flow-control commands",
        "apply": function(val) {
          if (!val) {
            this.handle = monaco.languages.setLanguageConfiguration('choicescript', {
              onEnterRules: []
            });
          } else {
            if (this.handle) this.handle.dispose();
          }
        }
      }),
      new CSIDESetting({
        "id": "linewrap",
        "name": "Line Wrapping",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Wrap lines that exceed the editor's width (no horizontal scrolling)",
        "apply": function(val) {
          __applyToAllEditors("wordWrap", val ? "on" : "off");
        }
      }),
      new CSIDESetting({
        "id": "autosuggest",
        "name": "Auto Suggest",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Prompt quick-complete word suggestions as you type",
        "apply": function(val) {
          __applyToAllEditors("quickSuggestions", val);
        }
      }),
      new CSIDESetting({
        "id": "autoformat",
        "name": "Auto Format",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Automatically replace certain character combinations with their formatted equivalents",
        "apply": function(val) {
          __applyToAllEditors("formatOnType", val);
        }
      }),
      new CSIDESetting({
        "id": "selection-match",
        "name": "Selection Match",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Highlight matching instances of selected text",
        "apply": function(val) {
          // FIXME: Highlights can get stuck if disabled whilst visible.
          __applyToAllEditors("selectionHighlight", val);
        }
      }),
      new CSIDESetting({
        "id": "cursor-match",
        "name": "Cursor Match",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Highlights other instances of the word under the editor caret",
        "apply": function(val) {
          __applyToAllEditors("occurrencesHighlight", val);
        }
      }),
      new CSIDESetting({
        "id": "visible-tabs",
        "name": "Visible Indentation",
        "value": false,
        "type": "binary",
        "cat": "editor",
        "desc": "Provides a visible representation of the indentation level in the editor window",
        "apply": function(val) {
          __applyToAllEditors("renderIndentGuides", val);
        }
      }),
      new CSIDESetting({
        "id": "spellcheck",
        "name": "Spell Check",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Underline any misspelt words in active scenes",
        "apply": function(val) {
          // enable/disable editor diagnostics
          var monacoOptions = __getMonacoDiagnosticOptions();
          monacoOptions.spellcheck.enabled = Boolean(val);
          __updateMonacoDiagnosticOptions(monacoOptions);
          if (val) {
            this.handle = monaco.languages.choicescript.onDictionaryChange((dictEvent) => {
              for (var i = 0; i < dictEvent.words.length; i++) {
                if (dictEvent.removed) {
                  userDictionary.remove(dictEvent.words[i], dictEvent.dictionary);
                } else {
                  userDictionary.add(dictEvent.words[i], dictEvent.dictionary);
                }
              }
            });
          } else {
            if (this.handle) this.handle.dispose();
          }
        }
      }),
      new CSIDESetting({
        "id": "spell_dic",
        "name": "Spell Check Dictionary",
        "value": "en_US",
        "type": "variable",
        "cat": "editor",
        "options": [{
          "desc": "US",
          "value": "en_US"
        }, {
          "desc": "GB",
          "value": "en_GB"
        }],
        "desc": "The dictionary to spellcheck against",
        "apply": function(val) {
          var monacoOptions = __getMonacoDiagnosticOptions();
          monacoOptions.spellcheck.dictionary = val;
          __updateMonacoDiagnosticOptions(monacoOptions);
        }
      }),
      new CSIDESetting({
        "id": "word-count",
        "name": "Word Count",
        "value": 2,
        "type": "variable",
        "cat": "editor",
        "desc": "Display the current scene's word and character counts at the bottom of the editor window",
        "options": [{
          "desc": "Exclude cmd lines",
          "value": 2
        }, {
          "desc": "Include cmd lines",
          "value": 1
        }, {
          "desc": "Off",
          "value": 0
        }],
        "apply": function(val) {
          wordCountOn(val); // 0 == false? off
        }
      }),
      new CSIDESetting({
        "id": "usespaces",
        "name": "Use Spaces for Indentation",
        "value": true,
        "type": "binary",
        "cat": "editor",
        "desc": "Sets the preferred indentation unit to spaces (on) or tabs (off). Note that this will only be applied to newly created files. This setting can be overridden per file.",
        "apply": function(val) {} // only adjusts value for new files
      }),
      new CSIDESetting({
        "id": "tabsize",
        "name": "Tab/Indent Block Size",
        "value": "4",
        "type": "number",
        "cat": "editor",
        "min": 1,
        "max": 12,
        "step": 1,
        "desc": "Sets the default visual size of tabs. This setting can be overridden per file.",
        "validate": function(newValue) {
          var message = "Invalid value";
          newValue = parseInt(newValue);
          var valid = !isNaN(newValue);
          if (valid) {
            if (newValue < this.min) {
              valid = false;
              message = "Value should be greater than or equal to " + this.min;
            } else if (newValue > this.max) {
              valid = false;
              message = "Value should be less than or equal to " + this.max;
            }
          }
          return { valid: valid, message: message }
        },
        "apply": function(val) {}, // only adjusts value for new files
      }),
      new CSIDESetting({
        "id": "indentspaces",
        "name": "Space Indentation Size",
        "value": "4",
        "type": "number",
        "cat": "editor",
        "min": 1,
        "max": 12,
        "step": 1,
        "desc": "Sets the preferred number of spaces used for indentation. Note that this will only be applied to newly created files. This setting can be overridden per file.",
        "validate": function(newValue) {
          var message = "Invalid value";
          newValue = parseInt(newValue);
          var valid = !isNaN(newValue);
          if (valid) {
            if (newValue < this.min) {
              valid = false;
              message = "Value should be greater than or equal to " + this.min;
            } else if (newValue > this.max) {
              valid = false;
              message = "Value should be less than or equal to " + this.max;
            }
          }
          return { valid: valid, message: message }
        },
        "apply": function(val) {} // only adjusts value for new files
      }),
      new CSIDESetting({
        "id": "fontsize",
        "name": "Font Size (px)",
        "value": "12",
        "type": "number",
        "cat": "editor",
        "min": 8,
        "max": 30,
        "step": 1,
        "desc": "The size of the font in the editor window",
        "validate": function(newValue) {
          var message = "Invalid value";
          newValue = parseInt(newValue);
          var valid = !isNaN(newValue);
          if (valid) {
            if (newValue < this.min) {
              valid = false;
              message = "Value should be greater than or equal to " + this.min;
            } else if (newValue > this.max) {
              valid = false;
              message = "Value should be less than or equal to " + this.max;
            }
          }
          return { valid: valid, message: message }
        },
        "apply": function(val) {
          __applyToAllEditors("fontSize", val);
        }
      }),
      new CSIDESetting({
        "id": "fontfamily",
        "name": "Font Family",
        "value": "'Century Gothic', AppleGothic, Arial, Helvetica, sans-serif",
        "type": "dropdown",
        "cat": "editor",
        "options": [{
          "desc": "Mono",
          "value": "'Courier New', Courier, monospace"
        }, {
          "desc": "Sans-Serif",
          "value": "Arial, Helvetica, sans-serif"
        }, {
          "desc": "Serif",
          "value": "'Times New Roman', Times, serif"
        }, {
          "desc": "Gothic",
          "value": "'Century Gothic', AppleGothic, Arial, Helvetica, sans-serif"
        }],
        "desc": "The font family used in the editor window",
        "apply": function(val) {
          __applyToAllEditors("fontFamily", val);
        }
      }),
      new CSIDESetting({
        "id": "theme",
        "name": "Editor Theme",
        "value": "cs-light",
        "type": "dropdown",
        "cat": "editor",
        "options": [
          /* We need dummy theme values here to prevent things
             going awry on startup. We then repopulate the list
             via Monaco's themeService below */
          { "desc": "Light", "value": "cs-light"},
          { "desc": "Dark", "value": "cs-dark"},
        ],
        "desc": "Sets the colour and style of the editor window and its text",
        "apply": function(val) {
          var self = this;
          var BASE_THEMES = ["vs", "vs-dark", "hc-black"];
          var CS_THEMES = ["cs-light", "cs-dark"];
          // unfortunately we need an editor instance to grab theme information
          // and the console editor is the only one guaranteed to be available
          editor = monacoConsole;
          if (editor._themeService._knownThemes.size > (self.getOptions().length + BASE_THEMES.length)) {
            var options = [];
            editor._themeService._knownThemes.forEach(function(theme) {
              if (BASE_THEMES.indexOf(theme.themeName) < 0) // ignore Monaco's base themes
                options.push({ desc: CS_THEMES.indexOf(theme.themeName) > -1 ? theme.themeName : theme.themeName + " (custom)", value: theme.themeName });
            });
            self.setOptions(options);
            if (options.some(function(opt) { return opt.value === val; })) {
              self.apply(val);
            }
          }
          if (!self.getOptions().some(function(opt) { return opt.value === val; })) {
            val = "cs-light"; // handle any old/invalid theme config values
          }
          editorOptionStore["theme"] = val;
          monaco.editor.setTheme(val);
          $("#code-footer, #cs-console").removeClass(function(i, className) {
            return (className.match(/cs-\w+/g) || []).join(' ');
          }).addClass(val);
        }
      })
    ]),
    "app": ko.observableArray([
      new CSIDESetting({
        "id": "version",
        "name": "Version: " + CSIDE_version,
        "value": "",
        "type": "variable",
        "options": [],
        "desc": "",
        "apply": function(val) {}
      }),
      new CSIDESetting({
        "id": "autosave",
        "name": "Autosave Files & Projects",
        "value": false,
        "type": "binary",
        "desc": "Save all unsaved changes automatically (every 5 minutes)",
        "apply": function(val) {
          if (typeof autoSaveFn != "undefined" && autoSaveFn) {
            clearInterval(autoSaveFn);
          }
          if (val) {
            autoSaveFn = setInterval(function() {
              ///var status = notification("Saving...", "Please wait", {closeWith: false, timeout: false});
              self.session.save(function(err) {
                if (err) {
                  bootbox.alert("<h3>Save Error</h3>" + err.message);
                }
                //status.close();
              });
            }, 300000);
          } else {}
        }
      }),
      new CSIDESetting({
        "id": "persist",
        "name": "Persistent Session",
        "value": false,
        "type": "binary",
        "desc": "Retain open file & project data between sessions",
        "apply": function(val) {
          if (val) {
            //self.updatePersistenceList(); causes issues
          }
        }
      }),
      new CSIDESetting({
        "id": "cmdhelp",
        "name": "Command Help (prompts & links)",
        "value": false,
        "type": "binary",
        "desc": "Hovering the cursor over a command in the editor window will display additional information",
        "apply": function(val) {
          __applyToAllEditors("hover", { enabled: val });
        }
      }),
      new CSIDESetting({
        "id": "night-mode",
        "name": "Night Mode",
        "value": false,
        "type": "binary",
        "desc": "Toggle between a light and dark application interface",
        "apply": function(val) {
          var help = __getCSIDEHelp();
          if (val) {
            $("body").addClass("night");
            if (help)
              $(help.document.body).addClass("night");
          }
          else {
            $("body").removeClass("night");
            if (help)
              $(help.document.body).removeClass("night");
          }
          uiColour(uiColour()); // refresh night/day shade
        }
      }),
      new CSIDESetting({
        "id": "project-path",
        "name": "Project Folder",
        "value": "default",
        "type": "custom",
        "options": [{
          "desc": "Select",
          "value": "select"
        }, {
          "desc": "Default",
          "value": "default"
        }, ],
        "desc": "",
        "apply": function(val) {
          var self = this;
          if (val == "default") {
            if (usingNode) {
              var userDir = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];
            }
            var path = usingNode ? (userDir + "/Documents/Choicescript Projects/") : ("/Choicescript Projects/");
            self.setDesc(path);
            user.path = path;
          } else if (val == "select") {
            fh.selectFolder(function(path) {
              if (path) {
                /* this is a bit hacky, ideally I will improve settings management to allow for proper custom value settings CJW */
                path = __normalizePath(path); //deal with Windows backslashes etc.
                self.setValue(path);
                self.setDesc(path);
                user.path = path;
                config.settings[self.getCat()][self.getId()] = path;
                __updateConfig();
              }
            });
            //make sure 'select' isn't the option stored in config
            self.setValue(user.path);
            config.settings[self.getCat()][self.getId()] = user.path;
            __updateConfig();
          } else {
            self.setDesc(val);
            user.path = val;
          }
        }
      }),
      new CSIDESetting({
        "id": "allowscript",
        "name": "Allow Script",
        "value": false,
        "type": "binary",
        "desc": "Enables usage of the \*script command in your ChoiceScript games.",
        "apply": function(val) {
          if (platform === "web-dropbox")
            this.setVisibility(false);
        }
      }),
      new CSIDESetting({
        "id": "update-channel",
        "name": "Update Channel",
        "value": "stable",
        "type": "variable",
        "options": [{
          "desc": "Stable",
          "value": "stable"
        }, {
          "desc": "Latest",
          "value": "latest"
        }, {
         "desc": "Development",
         "value": "development"
        }, {
          "desc": "None",
          "value": "none"
        }],
        "desc": "Speed and stability of the updates CSIDE will receive",
        "apply": function(channel) {
          var self = this;
          if (platform == "web-dropbox") {  // no update-channel on web version
            self.setVisibility(false);
            return;
          }
          if (typeof autoUpdateCheckFn != "undefined" && autoUpdateCheckFn) {
            clearInterval(autoUpdateCheckFn);
          }
          if (channel != "none" && usingNode) {
            var autoUpdate = function() {
              if (self.prompt && !self.prompt.closed) // prevent notification stacking
                return;
              var n = notification("", "<i aria-hidden=true class='fa fa-refresh fa-spin'></i> Checking for updates...", { closeWith: false, timeout: false });
              updater.checkForUpdates({
                cside: CSIDE_version,
                nw: nw_version
              }, channel, function(err, update) {
                n.close();
                if (err) {
                  notification("Connection Error", "Failed to obtain update data from server. " + err.message, { type: "error" });
                } else if (update) {
                  self.prompt = __showUpdatePrompt(channel, update);
                }
              });
            }
            autoUpdateCheckFn = setInterval(autoUpdate, 1000 * 60 * 60);
            autoUpdate();
          }
          else {}
        }
      }),
      new CSIDESetting({
        "id": "ui-colour",
        "name": "Colour Scheme",
        "value": "rgb(90, 90, 90)",
        "type": "variable",
        "desc": "",
        "options": [{
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(90, 90, 90)'></div>",
          "value": "granite"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(175, 93, 111)'></div>",
          "value": "garnet"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(147, 122, 175)'></div>",
          "value": "amethyst"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(107, 166, 125)'></div>",
          "value": "emerald"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(94,104,121)'></div>",
          "value": "slate"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(129,127,122)'></div>",
          "value": "sandstone"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(51, 164, 164)'></div>",
          "value": "jade"
        }, {
          "desc": "<div class='setting-colour-swatch' style='background-color: rgb(76,91,152)'></div>",
          "value": "sapphire"
        }],
        "apply": function(val) {
          var colour;
          switch (val) {
            case "granite":
              colour = "90,90,90";
              break;
            case "amethyst":
              colour = "147,122,175";
              break;
            case "garnet":
              colour = "175,93,111";
              break;
            case "emerald":
              colour = "60,100,80";
              break;
            case "slate":
              colour = "94,104,121";
              break;
            case "sandstone":
              colour = "129,127,122";
              break;
            case "jade":
              colour = "51,164,164";
              break;
            case "sapphire":
              colour = "76,91,152";
              break;
            default:
              colour = "90,90,90";
          }
          uiColour(colour);
        }
      })
    ]),
    "byId": function(settingType, id) {
      if (typeof settings[settingType] != 'undefined') {
        for (var i = 0; i < settings[settingType]().length; i++) {
          if (settings[settingType]()[i].getId() == id)
            return settings[settingType]()[i];
        }
      }
      return null;
    },
    "asObject": function(settingType) {
      if (typeof settings[settingType] != 'undefined') {
        var arr = settings[settingType]();
        var obj = {};
        for (var i = 0; i < arr.length; i++) {
          obj[arr[i].getId()] = arr[i].getValue();
        }
        return obj;
      } else {
        console.log("Invalid settings type passed to settings.asObject function.");
      }
    }
  };

  self.getEditorSettings = ko.computed(function() {
    return settings.editor().map(function(setting) {
      return setting.extAPI;
    });
  });
  self.getAppSettings = ko.computed(function() {
    return settings.app().map(function(setting) {
      return setting.extAPI;
    });
  });

  var monacoConsole = null;

  var consoleCmdBuf = [];
  var consoleCmdBufPtr = 0;
  var consoleIndicator = ko.observable(0);
  self.consoleInput = function(keyCode) {
    var consoleCommands = /^\*(console_)?(clear|track|untrack|track_all_off|track_all_on|track_list|help)/
    var validCSCommands = /^\*(?:set|temp|rand|achieve|restart|goto|goto_scene)/
    if (!keyCode) {
      return;
    }
    var input = monacoConsole.getValue();
    if (keyCode === monaco.KeyCode.UpArrow) {
      if (consoleCmdBuf.length <= 0) return;
      if (--consoleCmdBufPtr < 0) {
        consoleCmdBufPtr = (consoleCmdBuf.length - 1);
      }
      monacoConsole.setValue(consoleCmdBuf[consoleCmdBufPtr]);
    } else if (keyCode === monaco.KeyCode.DownArrow) {
      if (consoleCmdBuf.length <= 0) return;
      if (++consoleCmdBufPtr > (consoleCmdBuf.length - 1)) {
        consoleCmdBufPtr = 0;
      }
      monacoConsole.setValue(consoleCmdBuf[consoleCmdBufPtr]);
    }
    if (!input || keyCode !== monaco.KeyCode.Enter) {
      return;
    }
    if (consoleCmdBuf.length > 9) {
      consoleCmdBuf.shift(); //keep no more than 10 entries
    }
    consoleCmdBuf.push(input);
    consoleCmdBufPtr = consoleCmdBuf.length;
    activeProject().logToConsole(input, input.substring(0,1) == "*" ? "cm-builtin" : "cm-variable");
    // Must have a running game
    var gameFrame = document.getElementById("game-tab-frame").contentWindow || document.getElementById("#game-tab-frame");
    if (typeof gameFrame === 'undefined' || typeof gameFrame === 'undefined') {
      activeProject().logToConsole("Error: no choicescript game running", "cm-error");
      monacoConsole.setValue("");
      return;
    }
    // Prevent the confusing use of commands through non active project consoles
    if (activeProject() != activeProject()) {
      activeProject().logToConsole("Error: this project is not the one running", "cm-error");
      monacoConsole.setValue("");
      return;
    }
    try {
      var toks;
      if (input.match(/^\*/)) {
        if ((toks = input.match(validCSCommands)) || (toks = input.match(consoleCommands))) { //input is a command
          if (toks.length > 1) { //console_ command
            if (toks[1] !== "console_") {
              input = ("*console_" + input.substring(1, input.length));
            }
          }
          if (input.match(/^\*goto/)) {
            if (input.match(/^\*goto\s+/)) {
              input = input.replace(/^\*goto\s+/, ""); //convert *goto label into (*goto_scene) current_scene label
              gameFrame.postMessage({ type: "runCommand", cmd: "CSIDEConsole_goto", input: input });
            }
            else {
              input = input.replace(/^\*goto_scene\s+/, "");
              gameFrame.postMessage({ type: "runCommand", cmd: "CSIDEConsole_goto_scene", input: input });
            }
          } else {
            gameFrame.postMessage({ type: "runCommand", cmd: null, input: input });
          }
        } else {
          activeProject().logToConsole("Error: invalid console command", "cm-error");
        }
      } else { //assume expression:
        gameFrame.postMessage({ type: "runCommand", cmd: "CSIDEConsole_eval_expr", input: input });
      }
    } catch (e) {
      //strip error scene & line num - as the information is irrelevant
      e.message = e.message.replace(/line [0-9]+ of\s\w+: /, "");
      activeProject().logToConsole("Error: " + e.message, "cm-error");
    }
    monacoConsole.setValue("");
  }

  // used by nodeCSIDE.js drag/drop file opening
  self.openScene = function(path, callback) {
    __openScene(path, callback);
  }
  self.openLogFile = function(path, callback) {
    if (getFileExtension(path)) {
      __openLogFile(path, callback);
    }
  }
  self.openFileBrowser = function() {
    fh.selectFiles(function(selection) {
      if (selection && selection.length >= 1)
        __openFiles(selection, true);
    });
  }

  function __openFiles(paths, selectLast) {
    var lastIndex = selectLast ? (paths.length - 1) : paths.length;
    for (var i = 0; i < lastIndex; i++) {
      var ext = getFileExtension(paths[i]);
      switch (ext) {
        case ".txt":
          __openScene(paths[i], function() {});
          break;
        case ".log":
          __openLogFile(paths[i], function() {});
          break;
        default:
          bootbox.alert("<h3>Error</h3>Attempting to open an unsupported file type: " + ext + ". Please report this.");
          return;
      }
    }
    if (selectLast) {
      switch (getFileExtension(paths[lastIndex])) {
        case ".txt":
          __openScene(paths[lastIndex], function(err, scene) {
            if (!err) scene.viewInEditor();
          });
          break;
        case ".log":
          __openLogFile(paths[lastIndex], function() {});
          break;
        default:
          bootbox.alert("<h3>Error</h3>Attempting to open an unsupported file type: " + ext + ". Please report this.");
        return;
      }
    }
  }

  userDictionary = {
    "monacoCmds": {
      //interface for Monaco's CodeAction Commands/Quick Fixes
    },
    "persistentList": {
      //always ignore these words
    },
    "persistentListArray": ko.observableArray([
      //for GUI display
    ]),
    "sessionList": {
      //for this session only
    },
    "validateWord": function(word) {
      return word.match(/^([A-Za-z\u00C0-\u00FF\u0100-\u017F]+'[A-Za-z\u00C0-\u00FF\u0100-\u017F]+|[A-Za-z\u00C0-\u00FF\u0100-\u017F]{2,}|[AaI]'?)$/); //word chars, accented chars, apostrophes
    },
    "add": function(word, list) {
      if (!userDictionary.validateWord(word)) {
        return false;
      }
      if (userDictionary[list + "List"][word])
        return true;
      userDictionary[list + "List"][word] = true;
      userDictionary.update(list);
      if (list == "persistent")
        userDictionary.persistentListArray.push(word);
      return true;
    },
    "remove": function(word, list) {
      if (userDictionary[list + "List"]) {
        delete userDictionary[list + "List"][word];
      }
      userDictionary.update(list);
      userDictionary.persistentListArray.remove(word);
    },
    "removeAll": function() {
      userDictionary.persistentList = {};
      userDictionary.persistentListArray.removeAll();
    },
    "check": function(word) {
      var pList = this.persistentList;
      var sList = this.sessionList;
      if (sList[word] || pList[word]) {
        return true;
      } else {
        return false;
      }
    },
    "load": function() {
      try {
        userDictionary.persistentList = JSON.parse(localStorage.getItem("userDictionary")) || {};
        for (var i in userDictionary.persistentList) {
          if (userDictionary.persistentList.hasOwnProperty(i)) {
            userDictionary.persistentListArray.push(i);
          }
        }
        userDictionary.sync("persistent");
      } catch (err) {
        if (err) {
          //no userDictionary.json file - write it:
          userDictionary.update();
        } else {
          bootbox.alert("Sorry, there was a problem loading or parsing your user dictionary data.<br>" + "If you're seeing this message frequently please file a bug report.");
        }
      }
    },
    "update": function(list) {
      if (typeof list == 'undefined' || list == "persistent") {
        var newDictionary = JSON.stringify(userDictionary.persistentList, null, "\t");
        localStorage.setItem("userDictionary", newDictionary);
      }
    },
    "sync": function(list) {
      // propagate to monaco for spelling validation
      var monacoOptions = __getMonacoDiagnosticOptions();
      if (!monacoOptions.spellcheck.userDictionary)
        monacoOptions.spellcheck.userDictionary = Object.create({});
      monacoOptions.spellcheck.userDictionary[list] = userDictionary[list+"List"];
      __updateMonacoDiagnosticOptions(monacoOptions);
    },
    "sanitize": function() {
      var arr = Object.keys(userDictionary.persistentList);
      for (var i = 0; i < arr.length; i++)
        if (!userDictionary.validateWord(arr[i]))
          throw new Error("Error: Invalid entry (not a word): " + arr[i]);
        else if (userDictionary.persistentList[arr[i]] !== true)
          throw new Error("Error: Entry value should be 'true' for: " + arr[i])
    },
    "import": function() {
      var path;
      fh.selectFiles(function(selection) {
        if (!selection || selection.length < 1) {
          return;
        }
        path = selection[0];
        if (selection.length > 1 || getFileExtension(path) != ".json") {
          bootbox.alert("<h3>Error</h3>Please select a single valid JSON file.");
          return;
        }
        bootbox.confirm("Are you sure you wish to import this dictionary?<br>All words from the current dictionary will be lost.", function(result) {
          if (result) {
            fh.readFile(path, function(err, data) {
              if (err) {
                notification("Failed to Read Dictionary", path, {
                  type: 'error'
                });
              }
              else {
                try {
                  userDictionary.persistentList = JSON.parse(data);
                  userDictionary.sanitize();
                  userDictionary.update();
                  userDictionary.removeAll();
                  userDictionary.load();
                  notification("Dictionary Import Succesful", path, {
                    type: 'success'
                  });
                } catch(e) {
                  notification("Dictionary Import Failed", path, {
                    type: 'error'
                  });
                  throw e;
                }
              }
            });
          }
        });
      }, { extensions: [".json"]});
    },
    "export": function() {
      var path;
      fh.selectFolder(function(url) {
        if (!url) return;
        __promptForString(function(filename) {
          if (filename) {
            validName(filename, false, function(valid, err) {
              if (valid) {
                path = url + filename + ".json";
                fh.stat(path, function(err, stats) {
                  if (err && err.code === 404) {
                    fh.writeFile(path, localStorage.userDictionary, function(err) {
                      if (err)
                        return;
                      else {
                        notification("Dictionary Export Successful", path, {
                          type: 'success',
                          buttons: [{
                            addClass: 'btn',
                            text: 'Show Folder',
                            onClick: function(note) {
                              __openFolder(getDirName(path));
                              note.close();
                            }
                          }]
                        });
                      }
                    });
                  } else {
                    notification("Export Failed: File already exists", path, { type: "error" });
                  }
                });
              } else {
                notification("Export Failed: Naming error", err, { type: "error" });
              }
            });
          }
        }, "Filename for Exported Dictionary", "CSIDE_Dictionary");
      });
    }
  }
  // External dictionary APIs
  self.importDictionary = userDictionary.import;
  self.exportDictionary = userDictionary.export;
  self.checkUserDictionary = function(word) {
    if (typeof word !== "string")
      return false;
    return userDictionary.check(word);
  }
  self.clearDictionary = function() {
    bootbox.confirm("Are you sure you wish to remove all words from the user dictionary?", function(result) {
      if (result) {
        userDictionary.removeAll();
        userDictionary.update();
      }
    });
  }
  self.dictWord = ko.observable("");
  self.filterString = ko.observable("").extend({
    notify: 'always',
    validate: function(value) {
      try {
        if (SEARCH.CONF.useRegex()) {
          new RegExp(value);
        }
        return { valid: true, message: "" };
      }
      catch(e) {
        return { valid: false, message: "Error: Filter string is not a valid regular expression" };
      }
    }
  });
  self.addToDictionary = function(obj, e) {
    if (e.type == "click" || e.type == "keyup" && e.keyCode == 13) {
      if (!userDictionary.validateWord(self.dictWord())) {
        bootbox.alert("<h3>Error</h3>Unable to add to user dictionary: not a word!");
        return;
      }
      monacoConsole.trigger("", `add-words`, {uri: "", dict: "persistent", words: [self.dictWord()]});
    }
  };
  self.removeFromDictionary = function(word) {
    monacoConsole.trigger("", `remove-words`, {uri: "", dict: "persistent", words: [word]});
  };
  self.getDictionaryArray = ko.computed(function() {
    var query = self.dictWord();
    if (query == "")
      return userDictionary.persistentListArray().sort();
    return userDictionary.persistentListArray().filter(function(word) { return word.startsWith(query); } ).sort();
  }, this);

  self.init = function() {

    monaco.editor.onDidChangeMarkers(function(uri) {
      for (var i = 0; i < uri.length; i++) {
        var project = getProject(getProjectPath(uri[i].path));
        if (project) {
          var markers = monaco.editor.getModelMarkers({resource: uri[i], take: 500 });
          var file = project.getFiles().find(function(f) {
            return f.getPath() === uri[i].path;
          });
          var newIssues = markers.map(function(m) {
            return new CSIDEIssue({ file: file, lineNum: m.startLineNumber, desc: m.message, severity: m.severity });
          });
          if (file) file.setMarkerIssues(newIssues);
        }
      }
    });

    // Create the "console" input as a single-line Monaco Editor instance
    // to allow for more interactive behaviour in the future.
    // This is a bit hacky as there is no official support right now.
    // See: https://github.com/microsoft/monaco-editor/issues/2009
    monacoConsole = monaco.editor.create(document.getElementById("monaco-console-input"), {
      wordWrap: 'off',
      lineNumbers: 'off',
      lineNumbersMinChars: 0,
      overviewRulerLanes: 0,
      overviewRulerBorder: false,
      lineDecorationsWidth: 0,
      hideCursorInOverviewRuler: true,
      glyphMargin: false,
      folding: false,
      scrollBeyondLastColumn: 0,
      scrollbar: {horizontal: 'hidden', vertical: 'hidden'},
      find: { addExtraSpaceOnTop: false, autoFindInSelection: 'never', seedSearchStringFromSelection: false },
      minimap: {enabled: false},
      language: "choicescript",
      lineHeight: "30px",
      fontSize: "12px",
      renderValidationDecorations: "off",
      contextmenu: false,
      hover: { enabled: false },
      suggestOnTriggerCharacters: false,
      lightbulb: { enabled: false },
      parameterHints: { enabled: false },
      quickSuggestions: false
    });

    monacoConsole.onKeyDown(e => {
      switch(e.keyCode) {
        case monaco.KeyCode.Enter:
        case monaco.KeyCode.UpArrow:
        case monaco.KeyCode.DownArrow:
          self.consoleInput(e.keyCode);
          e.preventDefault();
          break;
        default:
          return;
      }
    });

    monaco.cside = {};

    // Patch in replace pattern support for find/replace with regexes
    amdRequire(['vs/editor/contrib/find/replacePattern'], function(replacePattern) {
      monaco.cside.parseReplaceString = replacePattern.parseReplaceString;
      monaco.cside.getReplaceString = function(replaceStr, matches, preserveCase) {
        return replacePattern.parseReplaceString(replaceStr).buildReplaceString(matches, preserveCase);
      }
    });

    if (usingNode) {
      // Load user-themes for the editor
      var themeDir = gui.App.dataPath + "/userThemes";
      var themeData = __loadEditorCustomThemes(themeDir);
      if (themeData.err && themeData.err.code === "ENOENT") {
        try {
          fs.mkdirSync(themeDir);
          themeData = __loadEditorCustomThemes(themeDir);
        } catch (err) { // give up
          notification("Unable to Detect Custom Themes",
            "CSIDE couldn't find or create a themes folder", {
            type: "error",
            layout: "bottomRight"
          });
        }
      }
      if (!themeData.err && themeData.themes.length > 0) {
        themeData.themes.filter(function(theme) { return theme.err })
          .forEach(function(theme) {
            notification("Failed to Load Custom Theme: " + theme.name, theme.err.message || "", {
              type: "error",
              layout: "bottomRight"
            });
          });
      }
    }

    if (!usingNode) {
      user.name = "dropbox-user";
    }
    if (config.settings.app.persist) {

      // load preferred file colour swatches
      if (Array.isArray(config.recentColours) && (config.recentColours.length > 0))
        recentFileColours(config.recentColours);

      var thisProjectData = [];
      for (var i = 0; i < config.openProjects.length; i++) {
        thisProjectData = config.openProjects[i];
        var project = new CSIDEProject(thisProjectData);
        __addProject(project);
        for (var n = 0; n < thisProjectData.openScenes.length; n++) {
          var file = new CSIDEFile(thisProjectData.openScenes[n]);
          project.addFile(file);
          file.load();
        }
      }
      // Attempt to restore tab order.
      if (config.tabs.length === __csideTabs.length) {
        for (var e = 0; e < config.tabs.length; e++) {
          self.tabs.push(__csideTabs[config.tabs[e]]);
        }
      } else {
        // If there is a list mismatch silently restore the defaults.
        for (var tab in __csideTabs) {
          self.tabs.push(__csideTabs[tab]);
        }
      }
    }
    else {
      for (var tab in __csideTabs) {
        self.tabs.push(__csideTabs[tab]);
      }
    }
    // Pre-configure the language service:
    var diagnosticsOptions = __getMonacoDiagnosticOptions();
    diagnosticsOptions.validate = false;
    __updateMonacoDiagnosticOptions(diagnosticsOptions);
    var scope = settings.editor();
    for (var i = 0; i < scope.length; i++) {
      var val = typeof config.settings.editor[scope[i].getId()] != 'undefined' ? config.settings.editor[scope[i].getId()] : defaultConfig.settings.editor[scope[i].getId()];
      scope[i].setValue(val);
    }
    scope = settings.app();
    for (var i = 0; i < scope.length; i++) {
      var val = typeof config.settings.app[scope[i].getId()] != 'undefined' ? config.settings.app[scope[i].getId()] : defaultConfig.settings.app[scope[i].getId()];
      scope[i].setValue(val);
    }

    // load userDictionary
    try {
      userDictionary.sanitize();
      userDictionary.load();
    }
    catch(err) {
      bootbox.alert("Sorry, there was a problem loading or parsing your user dictionary data.<br>" + "If you're seeing this message frequently please file a bug report.");
    }

    // ensure the tab panel starts open and on the 'help' tab
    __selectTab("help");

    // force redraw of the scene panel based on display width
    cside.togglePanel("scene", true /* open */);

    // hook post-update behaviour here
    if (config.justUpdated || typeof config.justUpdated === "undefined") {
      config.justUpdated = false;
      __updateConfig();
      setTimeout(function() {
        var n = notification("Updated to v" + CSIDE_version, "A full list of changes can be found under 'Changelog' in the help and information tab.", {
          buttons: [{ addClass: 'btn', text: 'Show Changelog',
            onClick: function(note) {
              var csideHelp = __getCSIDEHelp();
              if (csideHelp) {
                csideHelp.breadcrumbs = [{ 'url' : 'home.html', 'title': 'Home' }, { 'url' : 'changelog.md', 'title' : 'Changelog' }];
                csideHelp.history = ['home.html', 'changelog.md'];
                csideHelp.drawPage('changelog.md');
              }
              note.close();
            }
          }]
        });
        n.setTimeout(5000);
      }, 10000);
    }

    // hide preload screen
    document.getElementById("preload").style.opacity = 0;
    document.getElementById("preload").style.visibility = "hidden";
  }

  //animations
  self.slideUpAndOut = function(elem) {
    $(elem).parent().find("ul").remove();
    $(elem).animate({
      minHeight: 0,
      height: 0,
      padding: 0
    }, 400, function() {
      $(elem).remove();
    })
  };
  self.slideDownAndIn = function(elem) {
    $(elem).hide().slideDown(400)
  };
  self.fadeIn = function(elem) {
    $(elem).hide().fadeIn("fast")
  };
  self.fadeOutAndUp = function(elem) {
    $(elem).animate({
      opacity: 0,
      height: 0,
      padding: 0
    }, 400, function() {
      $(elem).remove();
    })
  };

  self.showWordCount = function(sceneOrProject) {
    var type = sceneOrProject.constructor.name.substring("CSIDE".length, sceneOrProject.constructor.name.length);
    var title = (type + " - " + sceneOrProject.getName());
    var counts = sceneOrProject.getWordCount();
    var msg = "<h5>Word Count</h5> \
      Including command lines: " + counts.incmds +
      "<br>Excluding command lines: " + counts.excmds;
    msg += "<br>Characters: " + sceneOrProject.getCharCount();
    msg += "<br><br>Please note that these figures are only approximations.<br>Project word counts only include those of open scenes.";
    bootbox.alert({message: msg, title: title});
  }

  function __updateMonacoDiagnosticOptions(diagOptions) {
    monaco.languages.choicescript.setDiagnosticsOptions(diagOptions);
  }

  function __getMonacoDiagnosticOptions() {
    return monaco.languages.choicescript.diagnosticsOptions;
  }


  // OVERRIDE INTERNAL MONACO EDITOR SERVICES
  function __overrideEditorServices(monacoEditorInst) {
    // Links in Monaco use a data-href attribute rather than the href attribute.
    // This means NWJS's new-win-policy event can't determine the url/target.
    // Thus we need to patch in an alternative handler here.
    monacoEditorInst.getContribution('editor.linkDetector').openerService._externalOpener = {
      openExternal: function(href) {
        if (usingNode) {
          gui.Shell.openExternal(href);
        } else if (matchesScheme(href, Schemas.http) || matchesScheme(href, Schemas.https)) {
          dom.windowOpenNoOpener(href);
        } else {
          window.location.href = href;
        }
        return Promise.resolve(true);
      }
    }

    // Make sure Monaco will look at more than just the editor's attached model.
    monacoEditorInst._codeEditorService.findModel = function (editor, resource) {
      const model = editor.getModel();
      if (!resource)
        return model;
      if (model && model.uri.toString() !== resource.toString()) {
        var newModel = monaco.editor.getModel(resource.toString());
        return newModel;
      }
      return model;
    }

    // Teach Monaco how to select new files in CSIDE.
    monacoEditorInst._codeEditorService.doOpenEditor = function (editor, input) {
      var model = this.findModel(editor, input.resource);
      if (!model) {
        if (input.resource) {
          var schema = input.resource.scheme;
          if (schema === network_1.Schemas.http || schema === network_1.Schemas.https) {
            // This is a fully qualified http or https URL
            // dom_1.windowOpenNoOpener(input.resource.toString());
            return editor;
          }
        }
        return null;
      }
      if (editor.getModel().uri.toString() !== input.resource.toString()) {
        model.csideFile.viewInEditor(function(ed) {
          if (ed) {
            var med = ed.getMonacoEditor();
            ed.waitForRender(function() {
              var selection = (input.options ? input.options.selection : null);
              if (selection) {
                if (typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
                  med.setSelection(selection);
                  med.revealRangeInCenter(selection, 1);
                }
                else {
                  var pos = {
                    lineNumber: selection.startLineNumber,
                    column: selection.startColumn
                  };
                  med.setPosition(pos);
                  med.revealPositionInCenter(pos, 1);
                }
                med.focus();
              }
            });
          }
        });
      }
    }
  }

  function __createImageScene(project, path) {

    var image = new Image();

    image.onload = function() {
      var canvas = document.createElement('canvas');
      var fileExt = getFileExtension(path);
      var imgSceneName = (CONST_IMG_PREFIX + getLastDirName(path).replace(fileExt, "")).replace(/\s/g, "_").toLowerCase();
      var scenePath = (project.getPath() + imgSceneName + ".txt");
      canvas.width = this.naturalWidth; // or 'width' if you want a special/scaled size
      canvas.height = this.naturalHeight; // or 'height' if you want a special/scaled size
      if (canvas.width <= 0 && canvas.height <= 0) {
        notification("Image Import Failed", path, {
          type: 'error'
        });
        return;
      }
      canvas.getContext('2d').drawImage(image, 0, 0);
      pathExists(project + imgSceneName, function(exists) {
        if (exists) {
          bootbox.prompt({
            title: "That Image Already Exists - Copy & Paste Code Below",
            value: "*gosub_scene " + imgSceneName,
            callback: function(result) {}
          });
        } else {
          var newScene = new CSIDEFile({
            "path": scenePath,
            "source": platform
          });
          var dataUrl = canvas.toDataURL(); //'image/' + fileExt
          newScene.setText("*comment ENCODED IMAGE FILE - DO NOT EDIT\n*comment source: " + path + "\n*comment usage: *gosub_scene " + newScene.getName() + "\n*image " + dataUrl + "\n*return");
          newScene.save(null, null, function(err) {
            if (err) {
              bootbox.alert(err.message);
            } else {
              notification("Image Import Successful", "", {
                type: 'success'
              });
              bootbox.prompt({
                title: "Copy & Paste Code Below",
                value: "*gosub_scene " + newScene.getName(),
                callback: function(result) {}
              });
            }
          });
        }
      });
    }
    image.onabort = image.onerror = function() {
      notification("Image Import Failed", path, {
        type: 'error'
      });
    }
    image.src = "file://" + path;
  }

  function __promptForString(callback, title, placeholder) {
    bootbox.prompt({
      title: title || "Please enter text",
      value: placeholder || "",
      callback: function(str) {
        if (typeof str != "string") {
          callback("");
        }
        else {
          callback(__trimWhitespace(str));
        }
      }
    });
  }

  function __promptForInteger(callback, title, placeholder, options) {
    // options = { min, max }
    bootbox.prompt({
      title: title || "Please enter text",
      value: placeholder || "",
      callback: function(input) {
        newVal = Number(input);
        isInteger = Number.isInteger(newVal);
        if (!input) {
          callback("", (input === null) ? "" : "no input"); // cancelled / empty
        } else if (isNaN(newVal)) {
          callback("", "not a number");
        } else if (!Number.isInteger(newVal)) {
          callback("", "not an integer");
        } else {
          if (options) {
            if (newVal > options.max) {
              callback("", newVal + " should be less than or equal to " + options.max);
            } else if (newVal < options.min) {
              callback("", newVal + " should be greater than or equal to " + options.min);
            } else {
              callback(newVal);
            }
          }
        }
      }
    });
  }

  function __validateEditorCustomThemes(themeData) {
    // IStandaloneThemeData:
    //  base: BuiltinTheme
    //    ("vs" | "vs-dark" | "hc-black")
    //  colors: IColors
    //    [colorId: string]: string,
    //    e.g.: ["editor.foreground": "#0000FF", ...]
    //  inherit: boolean
    //  rules: ITokenThemeRule[]
    //    token: string
    //    fontStyle?: string
    //    background?: string
    //    foreground?: string
    //  encodedTokensColors?: string[]
    var compulsoryAttrs = [
      { key: "base", isValid:
        function(val) {
          return ["vs", "vs-dark", "hc-black"].some(function(theme) { return val === theme  });
        }
      },
      { key: "colors", isValid:
        function(val) {
          for (key in val) {
            if (val.hasOwnProperty(key)) {
              // TODO: Check colorId is valid
              if (!val[key].match(/^#[0-9A-Fa-f]{6,8}$/)) {
                return false;
              }
            }
          }
          return true;
        }
      },
      { key: "rules", isValid:
        function(val) {
          return Array.isArray(val) && val.every(function(entry) {
            // TODO: Confirm token names are valid? Properties look difficult.
            return true;
          });
        }
      },
      { key: "inherit", isValid:
        function(val) {
          return typeof val === "boolean";
        }
      },
    ];
    for (var i = 0; i < compulsoryAttrs.length; i++) {
      var attr = compulsoryAttrs[i].key;
      var val = themeData[attr];
      if (typeof val === "undefined" || val === null)
        return new Error("Incomplete editor theme is missing an attribute: " + attr);
      else if (!compulsoryAttrs[i].isValid(val))
        return new Error("Invalid editor theme: " + attr + " is invalid");
    }
    return null;
  }

  // Returns: { err: err || null, themes: [ { name: string, err: err || null } ]};
  function __loadEditorCustomThemes(themeDir) {
    var result = { err: null, themes: [] };
    try {
      var themes = fs.readdirSync(themeDir).filter(function(file) {
        return getFileExtension(file) === ".json";
      });
      themes.forEach(function(theme) {
        var themePath = themeDir + "/" + theme;
        var themeName = getFileName(themePath);
        var theme = { name: themeName, err: null };
        try {
          var themeData = JSON.parse(fs.readFileSync(themePath).toString());
          var valErr = __validateEditorCustomThemes(themeData);
          if (!valErr)
            monaco.editor.defineTheme(themeName, themeData);
          else
            theme.err = valErr;
        } catch(err) {
          theme.err = err;
        }
        result.themes.push(theme);
      });
    } catch(err) {
      result.err = err;
    }
    return result;
  }

  /* blank is an optional boolean, default is false: creates with startup & choicescript_stats */
  self.createProject = function(projectName, cb, blank) {
    blank = blank || false;
    if (typeof cb != "function")
      cb = function(err, project) { if (!err) notification("Project created", project.getPath(), { type: 'success', layout: 'bottomRight' }); };
    function __create(projectName) {
      validName(projectName, true, function(valid, err) {
        if (valid) {
          projectExists(user.path + projectName, function(exists) {
            if (!exists) {
              __createProject(projectName, cb, blank);
            }
            else {
              notification("Project Naming Error", "A Project with that name already exists in the project directory", { type: "error" });
            }
          });
        } else {
          notification("Project Naming Error", err, { type: "error" });
        }
      });
    }
    if (typeof projectName != "string" || projectName == "") {
      __promptForString(function(str) {
          if (str)
            __create(str);
      }, "Name of Project?");
    }
    else {
      __create(projectName);
    }
  }

  // ╔═╗┬─┐┬┬  ┬┌─┐┌┬┐┌─┐  ╔═╗┌─┐┌─┐┌─┐┌─┐
  // ╠═╝├┬┘│└┐┌┘├─┤ │ ├┤   ╚═╗│  │ │├─┘├┤
  // ╩  ┴└─┴ └┘ ┴ ┴ ┴ └─┘  ╚═╝└─┘└─┘┴  └─┘

  function addNewFile(project, name, options) {
    if (!(project instanceof CSIDEProject)) return;
    var fileName = name || "untitled";
    var ext = options && options.fileExt ? options.fileExt : ".txt";
    generateName(fileName);

    function generateName(newName) {
      pathExists(project.getPath() + newName + ext, function(exists) {
        if (exists) {
          var n = newName.substring(newName.lastIndexOf("_") + 1, newName.length);
          if (isNaN(n)) {
            n = 0;
          } else {
            n = (parseInt(n) + 1)
          };
          generateName(fileName + "_" + n);
        } else {
          var filePath = project.getPath() + newName + ext;
          var newFile = new CSIDEFile(Object.assign({
            "path": filePath,
            "source": platform,
            "readOnly": project.isReadOnly()
          }, options || {}));
          project.addFile(newFile);
          newFile.save(null, null, function(err) {
            if (err) {
              bootbox.alert(err.message);
            } else {
              newFile.load(function(err, file) {
                if (!err) file.viewInEditor();
              });
            }
          });
        }
      });
    }
  }

  function __applyToAllEditors(settingId, value) {
    editorOptionStore[settingId] = value;
    var valueData = {};
    valueData[settingId] = value;
    allEditors().forEach(function(ed) {
      ed.getMonacoEditor().updateOptions(valueData);
    });
  }

  function __addProject(project) {
    if (project instanceof CSIDEProject) {
      projects.unshift(project);
      return;
    }
    bootbox.alert("Error: Unable to add non-CSIDE Project.");
  }

  /* blank is an optional boolean, default is false: if true, startup & choicescript_stats scenes are not created */
  function __createProject(projectName, cb, blank) {
    blank = blank || false;
    function createProjectFolder(cpf_cb) {
      var projectPath = user.path + (projectName + '/');
      fh.makeDir(projectPath, function(err) {
        if (err && err.code == "EEXIST") {
          bootbox.alert("Error: That Project folder could not be created because it already exists.");
          cpf_cb(true);
        } else if (err) {
          bootbox.alert("Error: Unable to create the project folder, check your permissions.");
          cpf_cb(true);
        } else {
          cpf_cb(false, projectPath);
        }
      });
    }
    createProjectFolder(function(err, projectPath) {
      if (err) {
        cb(err);
      }
      var project = new CSIDEProject({
        'name': projectName,
        'path': projectPath,
        'source': platform
      });
      __addProject(project);
      var startupContents =
        "*title " + projectName +
        "\n*author " + user.name +
        "\n*ifid " + uuidv4() +
        "\n*comment your code goes here" +
        "\n*finish\n";
      var scenes = blank ? [] : [
        new CSIDEFile({
          'path': projectPath + 'choicescript_stats.txt',
          'contents': "",
          'source': platform
        }),
        new CSIDEFile({
          'path': projectPath + 'startup.txt',
          'contents': startupContents,
          'source': platform
        })
      ];
      scenes.forEach(function(scene, index) {
        scene.save(null, null, function(err) {
          if (err) {
            bootbox.alert(err.message);
            return;
          }
          project.addFile(scene);
          scene.load(function(err, scene) {
            if (!err && scene.getName() === "startup") {
              scene.viewInEditor();
            }
          });
        });
      });
      cb(null, project);
    });
  }

  function __saveFileTo(file, callback) {
    var chooser = $('#saveFileTo');
    chooser.attr("nwsaveas", file.getName());
    chooser.off().change(function(evt) {
      var savePath = $(this).val();
      if (!savePath) return;
      fs.writeFile(savePath, file.document.getValue(), function(err) {
        if (err) {
          bootbox.alert(err.message);
          return;
        } else {
          //success doesn't do anything (as our original version may still be dirty etc)
        }
      });
    });
    setTimeout(function() {
      chooser.trigger('click');
    }, 200);
  }

  function __openLogFile(path, callback) {
    nw.Window.open("file://" + path, {
      focus: true,
      width: 800,
      height: 600
    }, callback);
  }
  function __openScene(scenePath, callback) {
    if (typeof scenePath !== "string") {
      throw new Error("Error: Bad scenePath - expect a string.");
    }

    scenePath = __normalizePath(scenePath);

    var sceneProjectPath = getProjectPath(scenePath);
    var sceneProject = projectIsOpen(sceneProjectPath);
    var scene;

    if (!sceneProject) {
      sceneProject = new CSIDEProject({
        "path": sceneProjectPath,
        "source": platform
      });
      __addProject(sceneProject);
    }
    else {
      scene = fileAlreadyOpen(getFileName(scenePath), sceneProject);
      if (scene) {
        if (callback) callback(null, scene);
        return;
      }
    }

    var newScene = new CSIDEFile({
      "path": scenePath,
      "source": platform
    });
    sceneProject.addFile(newScene);
    newScene.load(callback);
  }

  function hasClass(el, cls) { //https://gist.github.com/jjmu15/8646098
    return el.className && new RegExp("(\\s|^)" + cls + "(\\s|$)").test(el.className);
  }

  function getFileName(filePath) {
    return getLastDirName(filePath);
  }

  function getLastDirName(path) {
    if ((path.charAt(path.length - 1) == "/" || path.charAt(path.length - 1) == "\\") && path.length > 2)
      path = path.substring(0, path.length - 1);
    if (path.lastIndexOf("/") != -1) {
      var divider = "/";
    } else {
      var divider = "\\";
    }
    return path.substring(path.lastIndexOf(divider) + 1, path.length);
  }

  function getFileExtension(filePath) {
    return filePath.substring(filePath.lastIndexOf("."), filePath.length);
  }

  function getProject(projectPath) {
    for (var n = 0; n < projects().length; n++) {
      if (projects()[n].getPath() === projectPath) {
        return projects()[n];
      }
    }
    return null; //project doesn't exist
  }

  function getProjectPath(filePath) {
    return filePath.substring(0, filePath.lastIndexOf("/") + 1);
  }

  function fileAlreadyOpen(fileName, project) {
    fileName = fileName.toLowerCase();
    var files = project.getFiles();
    for (var i = 0; i < files.length; i++) {
      if (files[i].getName() === fileName) {
        return files[i];
      } else if (i === files.length - 1) {
        return false;
      }
    }
  }

  function projectIsOpen(projectPath) {
    for (var i = 0; i < projects().length; i++) {
      if (projects()[i].getPath() === projectPath) {
        return projects()[i];
      } else if (i === projects().length - 1) {
        return false;
      }
    }
  }

  function validName(name, allowSpaces, callback) {
    var err;
    var valid = false;
    if (!name || name === "" || /^\s*$/.test(name)) {
      err = "Name required";
    } else if (!name.match(/^[\w-\s]+$/) && allowSpaces) {
      err = "Name contains invalid characters."; //Please use only letters, spaces, numbers, underscores and hypens
    } else if (!name.match(/^[\w-]+$/) && !allowSpaces) {
      err = "Name contains invalid characters."; // Please use only letters, numbers, underscores and hypens
    } else if (name.toUpperCase().match(reservedSceneNames)) {
      err = "That name is reserved";
    } else {
      valid = true;
    }
    callback(valid, err);
  }

  function __trimWhitespace(str) {
    str = str.trim() //cull preceding and trailing whitespace
    str = str.replace(/\s{2,}/g, " "); //remove repetitive whitespace
    return str;
  }

  function __updateEditorDecorations(editor, file, additional) {
    var meditor = editor.getMonacoEditor();
    var issues = file.getIssues();
    additional = additional || [];
    file.decorations = meditor.deltaDecorations(file.decorations,
      issues.filter(function(issue) { return typeof issue.getLineNum() === "number" && issue.canDismiss() })
        .map(function(issue) {
          var col = meditor.getModel().getLineFirstNonWhitespaceColumn(issue.getLineNum());
          return {
            range: new monaco.Range(issue.getLineNum(),col,issue.getLineNum(),col),
            options: {
              isWholeLine: true,
              className: 'line-delete',
              stickiness: monaco.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
            }
          }
        }).concat(additional)
    );
  }

  function __wordCount(string) {
    var nonCommandLines = string.replace(/\*.+$/gm, "");
    return {
      incmds: string.replace(/^\s+|\s+$/g, "").split(/\s+/).length,
      excmds: nonCommandLines.replace(/^\s+|\s+$/g, "").split(/\s+/).length
    }
  }

  function __copyProjectTo(oldPath, newPath, callback) {
    fh.readDir(oldPath, function(err, filenames) {
      if (err) {
        callback(err);
        return;
      }
      filenames = filenames.filter(function(file) {
        return (getFileExtension(file) === ".txt");
      });
      var count = filenames.length;
      for (var i = 0; i < filenames.length; i++) {
        fh.copyFile((oldPath + filenames[i]), (newPath + filenames[i]), function(err, data) {
          if (err) {
            callback(err);
            return;
          } else if (--count === 0) {
            callback(null);
          }
        });
      }
    });
  }

  function __openFolder(path) {
    if (usingNode) {
      gui.Shell.openItem(path);
    } else {
      fileBrowser.open(path, function(selection) {
        if (selection.length < 1) {
          return;
        }
        selection = selection.filter(function(file) {
            return !file.isFolder();
          })
          .map(function(file) {
            return file.path;
          });
          __openFiles(selection, true);
      });
    }
  }

  function projectExists(projectPath, callback) {
    fh.stat(projectPath, function(err, stat) {
      if (err && err.code == 404) {
        callback(false);
      } else if (stat.isRemoved !== 'undefined' && stat.isRemoved == true) {
        callback(false);
      } else {
        callback(true);
      }
    });
  }

  function pathExists(filePath, callback) {
    fh.stat(filePath, function(err, stat) {
      if (err && err.code == 404) {
        callback(false);
      } else if (stat.isRemoved !== 'undefined' && stat.isRemoved == true) {
        callback(false);
      } else {
        callback(true);
      }
    });
  }

  function __closeProject(project, ask) {
    function __commitCloseProject() {
      if (project === activeProject()) {
        if (activeProject() == activeProject()) {
          activeProject(null);
        }
        __getTab("game").href("");
      }
      // copy to avoid mutating array during iteration
      var files = Array.from(project.getFiles());
      files.forEach(function(f) {
        f.close();
      });
      projects.remove(project);
      __updatePersistenceList();
    }
    if (!project.isDirty()) {
      __commitCloseProject();
    } else {
      bootbox.confirm("This project has unsaved files, are you sure you wish to close it?", function(result) {
        if (result) {
          __commitCloseProject();
        }
      });
    }
  }

  function __testProject(project, test) {
    if (test != "random" && test != "quick") {
      alert("Error: no such test as " + test + "test!");
      return;
    }
    if (typeof project === "undefined" || project === "") {
      alert("Error: no project given to " + test + "test!");
      return;
    }
    var path = ("node_modules/cside-choicescript/" + test + "test.html");
    activeProject(project);
    if (platform === "web-dropbox") {
      project.test_win = window.open(path, "Quicktest", "toolbar=0,location=0,status=0,menubar=0,scrollbars,resizable,width=500,height=400");
      project.test_win.addEventListener("beforeunload", function(event) {
        project.test_win = null;
      });
      setTimeout(function() {
        project.test_win.title = test.toUpperCase() + "TEST - " + project.getName();
      }, 200);
    } else {
      if (project.test_win) {
        //re-run (open)
        project.test_win.close();
        project.test_win = null;
        __testProject(project, test);
      } else {
        nw.Window.open(path, {
          focus: true,
          width: 500,
          height: 500,
          title: ""
        }, function(test_win) {
          project.test_win = test_win;
          test_win.on("closed", function() {
            //project.test_win.leaveFullscreen();
            project.test_win.hide();
            project.test_win.close(true);
            project.test_win = null;
          });
        });
      }
    }
    //__reloadTab(self.tabs()[0], "lib/choicescript/" + test + "test.html");
  }

  function __openAllProjectScenes(project) {
    var projectPath = project.getPath();
    fh.readDir(projectPath, function(err, filepaths) {
      load(err, filepaths);
    });

    function load(err, filepaths) {
      if (err) {
        console.log(err);
      } else {
        __openFiles(filepaths.filter(function(filepath) {
            return (getFileExtension(filepath) === ".txt" && !filepath.match(CONST_IMG_PREFIX)); //only .txt files, ignore img scenes
          }, false)
          .map(function(filepath) {
            return (projectPath + filepath);
          })
        );
      }
    }
  }

  function __reloadTab(tab, path) { //refreshes iframe tabs, or changes target if second param is passed
    var href = path || tab.href();
    tab.href('');
    tab.href(href);
  }

  function __selectTab(id) {
    $("#tabs").tabs("option", "active", $("#" + id).index() - 1);
  }

  function __runProject(project) {
    if (platform != "web-dropbox") {
      mediaServer.setDir(project.getPath());
      document.getElementById("game-tab-frame").terminate();
    }
    __shortCompile(project, function(err, allScenes) {
      if (err) {
        bootbox.alert("<h3>Compilation Error</h3>" + err.message);
        console.log(err);
      } else {
        notification("Running", project.getName(), {
          timeout: 2000
        });
        project.makeActive();
        __reloadTab(__getTab("game"), 'run_index.html?restart=true');
        cside.togglePanel("tab", true /* open */);
        __selectTab("game");
        setTimeout(function() {
          var webview = document.getElementById('game-tab-frame');
          webview.addEventListener("unresponsive", function(pid) {
            var buttons = [
              {
                addClass: 'btn', text: 'Close', onClick: function(note) { webview.terminate(); note.close(); }
              },
              {
                addClass: 'btn', text: 'Wait', onClick: function(note) { note.close(); }
              }
            ];
            return notification(project.getName() + " Seems to be Unresponsive", "Should we force it to close?" ,
              { closeWith: true, timeout: false, buttons: buttons, type: "warning" }
            );
          });
          webview.contentWindow.postMessage(
            {
              type: "startGame",
              allScenes: allScenes,
              project: { path: project.getPath(), name: project.getName() },
              platform: platform,
              server: platform != "web-dropbox" ? mediaServer.getAddr() : null,
              allowScript: (platform !== "web-dropbox") && settings.byId("app", "allowscript").getValue(),
            }
          );
        }, 1000);
      }
    });
  }

  var loadedSceneJS = false;

  function __shortCompile(project, cb, transpile) {
    var statusBox = notification("Compiling... ", project.getName(), {
      closeWith: false,
      timeout: false
    });
    var allScenes = {};
    var failed = false;
    var projectPath = project.getPath();

    getProjectFileList();

    function getProjectFileList() {
      fh.readDir(projectPath, function(err, fileNames) {
        if (err) {
          statusBox.close();
          return cb(err);
        }
        var fileNames = fileNames.filter(function(fileName) {
          return (getFileExtension(fileName) === ".txt");
        });
        var count = fileNames.length;
        fileNames.forEach(function(fileName, index) {
          fh.readFile(projectPath + fileName, function(err, data) {
            if (failed) return;
            if (err) {
              failed = true;
              statusBox.close();
              if (err.code == 404)
                err = new Error("File not found: " + fileName);
              return cb(err);
            }
            if (err = addScene(fileName, data)) {
              statusBox.close();
              return cb(err);
            }
            if (--count == 0) {
              statusBox.close();
              cb(null, allScenes);
            }
          });
        });
        if (failed) {
          statusBox.close();
          return cb(err);
        }
      });
    }

    function addScene(fileName, data) {
      var scene = new Scene(); // ChoiceScript's 'Scene'
      var sceneName = fileName.substring(0, (fileName.length - ".txt".length));
      try {
        scene.loadLines(data);
      } catch (err) {
        statusBox.close();
        return new Error(err.message + " - " + sceneName + ".txt");
      }
      if (transpile) {
        var changes = [];
        for (var lineNum = 0; lineNum < scene.lines.length; lineNum++) {
          var command = /^\s*\*(\w+)(.*)/.exec(scene.lines[lineNum]);
          if (!command)
            continue;
          else if (cse[command[1]]) {
            var block_size = 1;
            while (scene.getIndent(scene.lines[lineNum + block_size]) > scene.getIndent(scene.lines[lineNum]))
              block_size++;
            changes.push({
              targetLine: lineNum,
              targetLength: block_size,
              change: cse[command[1]].transpile(scene, command[2], lineNum, block_size)
            });
          }
        }
        // reintegrate the changes
        for (var c = 0; c < changes.length; c++) {
          Array.prototype.splice.apply(scene.lines, [changes[c].targetLine, changes[c].targetLength].concat(changes[c].change));
        }
      }
      allScenes[sceneName] = {};
      allScenes[sceneName].crc = scene.temps.choice_crc;
      allScenes[sceneName].labels = scene.labels;
      allScenes[sceneName].lines = scene.lines;
      return false;
    }
  }

  var cse = {
    "getFreeLabelName": function(scene, prefix) {
      for (var i = 0; i < prefix; i++) {
        if (typeof scene.labels[prefix + ("_" + i)] === 'undefined')
          break;
      }
      return (prefix + ("_" + i));
    },
    "while": {
      "transpile": function(scene, expr, line, block_size) {
        var lines = [];
        var label = cse.getFreeLabelName(scene, "while_loop");
        lines.push("*label " + label);
        lines.push("*if" + expr);
        lines = lines.concat(scene.lines.slice(line + 1, line + block_size));
        lines.push("\t*goto " + label);
        return lines;
      }
    }
  }

  function __fullCompile(project, path) {
    var compile_process = cp.fork("compile.js", [path + project.getName() + ".html", "web/", project.getPath()], {
      cwd: "node_modules/cside-choicescript/"
    });
    var status = notification("Exporting Game", "Do not close the program", { progress: true, closeWith: false, timeout: false });

    compile_process.on("message", function(log) {
      if (log.type === "progress") {
        status.setProgress(log.value);
      } else if (log.type === "exitCode") {
        if (log.value === 0) {
          var n = notification("Game Exported Successfully", project.getName(), {
            type: "success",
            buttons: [{
              addClass: 'btn',
              text: 'Show Folder',
              onClick: function(note) {
                __openFolder(path);
                note.close();
              }
            }]
          });
        }
      } else if (log.type === "error") {
        notification("Game Export Failed", log.value, {
          type: "error"
        });
      }
    });
    compile_process.on('disconnect', function() {
      status.close();
    });
  }

  function __rollbackUpdate() {
    updater.restore(function(err) {
      if (err) {
        notification("Warning - Rollback failed: Package Corrupt", err.message, {
          type: "error", timeout: 10000
        });
      } else {
        notification("Rollback Succesful", "The previous app package has been restored");
      }
    });
  }

  function __update(channel) {
    if (updating) return; //don't allow simultaneous updates
    var status = notification("Downloading Update", "Do not close the program", { progress: true, closeWith: false, timeout: false });
    var eventHandlers = {
      progress: function(val) {
        if (!isNaN(val)) {
         status.setProgress(val);
        }
      },
      error: function(title, msg) {
        notification(title, msg, { type: "error" });
      }
    }
    updating = true;
    updater.update(channel, eventHandlers, function(err) {
      status.close();
      updating = false;
      if (err) {
        notification("Update Failed", err.message, { type: "error", timeout: 10000 });
        __rollbackUpdate();
      } else {
        config.justUpdated = true;
        __updateConfig();
        notification("Update Complete", "Please restart the application.", { closeWith: false, timeout: false, type: "success" });
      }
    });
  }

  function __showUpdatePrompt(channel, update) {
    var buttons = [{
      addClass: 'btn',
      text: 'Download',
      onClick: function(note) {
        note.close();
        __update(channel);
      }
    },
    {
      addClass: 'btn',
      text: 'Cancel',
      onClick: function(note) {
        note.close();
      }
    }];
    return notification("Update Available on " + (channel.charAt(0).toUpperCase() + channel.slice(1)), update.desc, { closeWith: false, timeout: false, buttons: buttons, type: (channel === "development") ? "warning" : "alert" });
  }

  function __updateConfig() {
    var newConfig = JSON.stringify(config, null, "\t");
    localStorage.setItem("CSIDE_appConfig", newConfig);
  }

  function __updatePersistenceList() {
    config.openProjects = [];
    config.tabs = [];
    config.recentColours = [];
    var thisProject;
    for (var i = 0; i < projects().length; i++) {
      thisProject = {
        "path": projects()[i].getPath(),
        "source": projects()[i].getSource(),
        "name": projects()[i].getName(),
        "expanded": projects()[i].isExpanded(),
        "openScenes": []
      };
      var thisScene;
      for (var n = 0; n < projects()[i].getFiles().length; n++) {
        thisScene = {
          "path": projects()[i].getFiles()[n].getPath(),
          "source": projects()[i].getFiles()[n].getSource(),
          //"readOnly": projects()[i].getFiles()[n].isReadOnly(),
          "color": projects()[i].getFiles()[n].getMarkColour()
        }
        thisProject.openScenes.push(thisScene);
      }
      config.openProjects.unshift(thisProject);
    }
    for (var e = 0; e < self.tabs().length; e++) {
      config.tabs[e] = self.tabs()[e].id;
    }
    for (var c = 0; c < recentFileColours().length; c++) {
      config.recentColours.push(recentFileColours()[c]);
    }
    __updateConfig();
  }
  self.updatePersistenceList = function() {
    __updatePersistenceList();
  }
  self.makeSortable = function(data) {
    __makeSortable(data);
  }

  window.addEventListener("message", (event) => {
    var eventProject = null;
    if (event.data.project)
      eventProject = getProject(event.data.project.path);
    switch (event.data.type) {
      case "handleLink":
        nw.Shell.openExternal(event.data.url);
        break;
      case "console":
        switch(event.data.action) {
          case "clear":
            eventProject.clearConsole();
            break;
          case "log":
            eventProject.logToConsole(event.data.msg, event.data.style, event.data.metadata);
            break;
        }
        break;
      case "focusLine":
        __openScene(event.data.project.path + event.data.file.name + ".txt", function(err, file) {
          if (!err) {
            try {
              var lineNum = parseInt(event.data.file.lineNum); file.focusLine(lineNum);
            } catch (e) {
              // no line number, but we can still show the file
              file.viewInEditor();
            }
          }
        });
        break;
      case "logIssue":
        var issueData = { project: eventProject, file: null, desc: event.data.error.message, lineNum: event.data.error.lineNumber };
        if (event.data.file) {
          __openScene(event.data.project.path + event.data.file.name + ".txt", function(err, file) {
            if (!err) {
              issueData.file = file;
              issueData.severity = monaco.MarkerSeverity.Error;
              issueData.canDismiss = true; // runtime errors should be dismissable
              file.logIssue(new CSIDEIssue(issueData));
            } else {
              var issue = new CSIDEIssue({ project: issueData.project, canDismiss: true, desc: "Failed to open '" + issueData.file + "' whilst handling another issue: " + issueData.desc});
              issueData.project.logIssue(issue);
            }
          });
        }
        else {
          issueData.canDismiss = true; // runtime errors should be dismissable
          var issue = new CSIDEIssue(issueData);
          issueData.project.logIssue(issue);
        }
        break;
      case "popOut":
        nw.Window.open("run_index.html?persistence=CSIDE", {focus: true, width: 500, height: 500, title: ""}, function(new_win) {
          cside.popout.window = new_win;
          // don't allow the popout window to overwrite the persistent store (allows popout testing of multiple choices etc)
          new_win.on("loaded", function() {
            new_win.window.storeName = null;
          });
          new_win.on("closed", function() {
            cside.popout.window.leaveFullscreen();
            cside.popout.window.hide();
            cside.popout.window.close(true);
            cside.popout.window = null;
          });
        });
        break;
      default:
        return;
    }
  }, false);

  /*
    arg.item - the actual item being moved
    arg.sourceIndex - the position of the item in the original observableArray
    arg.sourceParent - the original observableArray
    arg.sourceParentNode - the container node of the original list
    arg.targetIndex - the position of the item in the destination observableArray
    arg.targetParent - the destination observableArray
    arg.cancelDrop - this defaults to false and can be set to true to indicate that the drop should be cancelled.
  */
  function dragFileEvent(arg, event, ui) {
    if (arg.sourceParent == arg.targetParent)
      return;

    var targetProject = ko.dataFor(event.target);
    var movingFile = arg.item;
    arg.cancelDrop = true;

    function execute(action) {
      pathExists(targetProject + arg.item.getName(), function(exists) {
        if (exists) {
          $(ui.sender).sortable('cancel');
          arg.cancelDrop = true;
          bootbox.alert("This project already has a file by that name.");
        } else {
          action();
        }
      });
    }
    bootbox.dialog({
      message: "Would you like to <b>move</b> or <b>copy</b> this file to this project?",
      title: "What would you like to do?",
      buttons: {
        copy: {
          label: "Copy",
          className: "btn-primary",
          callback: function() {
            execute(function() {
              movingFile.copyTo(targetProject);
            });
          }
        },
        move: {
          label: "Move",
          callback: function() {
            execute(function() {
              movingFile.moveTo(targetProject);
            });
          }
        },
        cancel: {
          label: "Cancel",
          callback: function() {
          }
        }
      }
    });
  }

  self.dragFileEvent = dragFileEvent;

  ko.bindingHandlers.bindIframe = {
    init: function(element, valueAccessor) {
      function bindIframe() {
        try {
          var iframeInit = element.contentWindow.initChildFrame,
            iframedoc = element.contentDocument.body;
        } catch (e) {
          // ignored
        }
        if (iframeInit)
          iframeInit(ko, valueAccessor());
        else if (iframedoc) {
          ko.applyBindings(valueAccessor(), iframedoc);
        }
      };
      bindIframe();
      ko.utils.registerEventHandler(element, 'load', bindIframe);
    }
  };
  ko.bindingHandlers.enableTextInput = {
    init: function(element, valueAccessor) {
      // Initially set the element to be disabled
      $(element).prop("readOnly", true);
    },
    update: function(element, valueAccessor) {
      // Whenever the value subsequently changes, slowly fade the element in or out
      // var value = valueAccessor();
      //element.readOnly = ko.utils.unwrapObservable(valueAccessor());
      $(element).prop("readOnly", !ko.utils.unwrapObservable(valueAccessor()));
    }
  }
  ko.bindingHandlers.fadeVisible = {
    init: function(element, valueAccessor) {
      // Initially set the element to be instantly visible/hidden depending on the value
      var value = valueAccessor();
      $(element).toggle(ko.utils.unwrapObservable(value)); // Use "unwrapObservable" so we can handle values that may or may not be observable
    },
    update: function(element, valueAccessor) {
      // Whenever the value subsequently changes, slowly fade the element in or out
      var value = valueAccessor();
      ko.utils.unwrapObservable(value) ? $(element).show().animate({
        'opacity': 1
      }, 250) : $(element).animate({
        'opacity': 0
      }, 250, function() {
        $(this).hide();
      });
    }
  };
  ko.bindingHandlers.fadeAndSlideVisible = {
    init: function(element, valueAccessor) {
      // Initially set the element to be instantly visible/hidden depending on the value
      var value = valueAccessor();
      $(element).toggle(ko.unwrap(value)); // Use "unwrapObservable" so we can handle values that may or may not be observable
    },
    update: function(element, valueAccessor) {
      // Whenever the value subsequently changes, slowly fade the element in or out
      var value = valueAccessor();
      ko.unwrap(value) ? $(element).slideDown(500).animate({
        'opacity': 1
      }, {
        queue: false,
        duration: 350
      }) : $(element).slideUp(500).animate({
        'opacity': 0
      }, {
        queue: false,
        duration: 350
      });
    }
  };
  ko.bindingHandlers.autoScroll = {
    update: function (element, valueAccessor) {
      var value = valueAccessor();
      if (ko.unwrap(value) && !__elementIsInView(element)) {
        element.scrollIntoView({block: 'center'});
      }
    }
  };
  ko.bindingHandlers.initFiles = {
    init: function(element, valueAccessor) {
      $(element).draggable({
        cursor: "move",
        cursorAt: {
          left: 5,
          top: 5
        },
        scroll: true,
        start: function(event, ui) {
          //selection.push($(this));
          ui.helper.appendTo($('body'));
        },
        helper: function() {
          var newElement = $("<div></div>");
          newElement.addClass("helper");
          newElement.text($('folder.selected').length);
          return $(newElement);
        }
      });
    },
    update: function(element, valueAccessor, allBindings) {
      // Leave as before
    }
  };
  ko.bindingHandlers.initFolders = {
    init: function(element, valueAccessor) {
      $(element).droppable({
          accept: ".file, .folder-ul",
          over: function(event, ui) {
            $(this).css("background-color", "#F7F7E1");
          },
          out: function(event, ui) {
            $(this).css("background-color", "");
          },
          drop: function(event, ui) {
            $(this).delay(100).fadeOut().fadeIn('slow');
            var targetFolder = $(this);
            $('.folder-selected').each(function() {
              moveDropboxItem($(this), targetFolder);
            });
          }
        })
        .draggable({
          cursor: "move",
          cursorAt: {
            left: 5,
            top: 5
          },
          scroll: true,
          start: function(event, ui) {
            //selection.push($(this));
            ui.helper.appendTo($('body'));
          },
          helper: function() {
            var newElement = $("<div></div>");
            newElement.addClass("helper");
            return $(newElement);
          }
        });
    },
    update: function(element, valueAccessor, allBindings) {
      // Leave as before
    }
  }

  if (!usingNode) {
    function fileBrowser() {
      //key events
      var shiftPressed = false;
      var ctrlPressed = false;
      $(document).keydown(function(e) {
        if (e.keyCode == 17) {
          e.preventDefault();
          ctrlPressed = true;
        }
        if (e.keyCode == 16) {
          e.preventDefault();
          shiftPressed = true;
        }
      });
      $(document).keyup(function(e) {
        if (e.keyCode == 17) {
          e.preventDefault();
          ctrlPressed = false;
        }
        if (e.keyCode == 16) {
          e.preventDefault();
          shiftPressed = false;
        }
      });
      //end key events
      var self = this;
      var visible = ko.observable(false);
      var loading = ko.observable(false);
      var curPath = ko.observable("");
      var buttonText = ko.observable("Open");
      var browserTitle = ko.observable("Open files");
      var stateDesc = ko.observable("");
      var error = ko.observable(false);
      self.getButtonText = ko.computed(function() {
        return buttonText();
      }, this);
      self.getBrowserTitle = ko.computed(function() {
        return browserTitle() + ": " + curPath();
      }, this);
      self.isVisible = ko.computed(function() {
        return visible();
      }, this);
      self.isLoading = ko.computed(function() {
        return loading();
      }, this);
      self.getStateDesc = ko.computed(function() {
        return stateDesc();
      }, this);
      self.hasErrored = ko.computed(function() {
        return error();
      }, this);
      self.path = ko.computed(function() {
        return curPath();
      }, this);
      self.selectingFolder = false;
      self.filesAndFolders = ko.observableArray([]);
      self.selection = ko.observableArray([]);

      function fileFolderItem(data) {
        var thisFileFolder = this;
        thisFileFolder.is_folder = (data[".tag"] == "folder") || data.isFolder || data.is_folder;
        thisFileFolder.name = data.name;
        thisFileFolder.path = data.path;
        thisFileFolder.icon = data.icon ? data.icon : data.isFolder ? 'fa fa-folder-o fa-lg' : 'fa fa-file-o fa-lg';
        thisFileFolder.selected = ko.observable(false);
        thisFileFolder.index = data.listIndex;
        thisFileFolder.select = function(data, event, forcedValue, skipKeyCheck) {
          if (!skipKeyCheck) {
            var selectedList = self.selection();
            var fullList = self.filesAndFolders();
            if (!ctrlPressed && !shiftPressed && selectedList.length > 0) {
              for (var s in selectedList) {
                fullList[selectedList[s].index].selected(false);
              }
              self.selection([]);
            } else if (shiftPressed) {
              selectedList.sort(function(a, b) {
                return a.index - b.index
              }); //sort our selection array, so it's in sync with visual shift select
              var topToBottom = false;
              if (self.selection() < 1) {
                for (var i = 0; i < thisFileFolder.index; i++) {
                  fullList[i].select({}, {}, true, true);
                }
              } else {
                //are we top to bottom or bottom to top
                for (var i = 0; i < thisFileFolder.index; i++) {
                  if (fullList[i].selected()) { //bottom to top
                    topToBottom = true;
                    break;
                  }
                }
                if (topToBottom) {
                  for (var i = selectedList[0].index; i < thisFileFolder.index; i++) {
                    if (!fullList[i].selected()) fullList[i].select({}, {}, true, true);
                  }
                } else {
                  for (var i = selectedList[selectedList.length - 1].index; i > thisFileFolder.index; i--) {
                    if (!fullList[i].selected()) fullList[i].select({}, {}, true, true);
                  }
                }
              }
            }
          }
          forcedValue ? thisFileFolder.selected(forcedValue) : thisFileFolder.selected() ? thisFileFolder.selected(false) : thisFileFolder.selected(true);
          self.selection.push(thisFileFolder);
        }
        if (data.isFolder) {
          thisFileFolder.open = function() {
            self.redraw(thisFileFolder.path);
          }
        } else {
          thisFileFolder.open = function() {
            if (typeof self.callback == "function") {
              self.selection = ko.observableArray([thisFileFolder]);
              self.executeTask();
            } else {
              self.close();
            }
          }
        }
        thisFileFolder.dateModified = data.modifiedAt || "";
        if (thisFileFolder.dateModified != "") {
          var parsedDate = {};
          parsedDate.day = data.modifiedAt.getDate();
          parsedDate.month = data.modifiedAt.getMonth();
          parsedDate.year = data.modifiedAt.getFullYear();
          parsedDate.hours = data.modifiedAt.getHours();
          parsedDate.mins = data.modifiedAt.getMinutes();
          if (parsedDate.mins.toString().length < 2) {
            parsedDate.mins = '0' + parsedDate.mins.toString();
          }
          thisFileFolder.dateModified = " - last modified at " + parsedDate.day + '/' + parsedDate.month + '/' + parsedDate.year + ' at ' + parsedDate.hours + ':' + parsedDate.mins;
        }
        thisFileFolder.isFolder = function() {
          return thisFileFolder.is_folder;
        }
      }
      this.cancel = function() {
        if (typeof self.callback === "function") {
          self.callback([]);
        }
        self.close();
      }
      this.close = function() {
        var selectedList = self.selection();
        var fullList = self.filesAndFolders();
        for (var s in selectedList) {
          fullList[selectedList[s].index].selected(false);
        }
        self.selection([]);
        self.callback = null;
        self.selectingFolder = false;
        self.extensions = [".txt", ".log"];
        visible(false);
      }
      this.open = function(path, callback, options) {
        // bad way to do optional 'path' parameter
        // should really make it the last argument
        if (typeof path == "function") {
          options = callback;
          callback = path;
          path = "";
        }
        if (self.selectingFolder) {
          buttonText("Select");
          browserTitle("Select a Folder");
        } else {
          if (options && options.extensions) {
            self.extensions = options.extensions;
            buttonText("Open");
            browserTitle("Select " + self.extensions.join(", "));
          } else {
            self.extensions = [".txt", ".log"];
            buttonText("Open");
            browserTitle("Open files");
          }
        }
        self.callback = callback;
        path = path || curPath();
        self.redraw(path);
        visible(true);
      }
      this.redraw = function(path) {
        stateDesc('Connecting...');
        loading(true);
        error(false);
        curPath(path);
        self.filesAndFolders([]);
        self.selection([]);
        var position = 0;
        fh.readDir(path, function(err, listStats) {
          if (err) {
            error(true);
            stateDesc("Failed to connect. Please check your internet connection.");
          } else {
            if (curPath() != "/" && curPath() != "") {
              //backup option
              var array = curPath().split("/");
              array.pop(); //remove deepest folder
              var parentPath = array.join("/");
              self.filesAndFolders.push(new fileFolderItem({
                "name": "Up a level",
                "path": parentPath,
                "isFolder": true,
                "icon": 'fa fa-level-up fa-lg',
                'listIndex': position
              }));
              position++;
            }
            for (var i = 0; i < listStats.length; i++) {
              // ignore anything but folders and allowed extensions
              if (!listStats[i].isFolder && self.extensions.indexOf(getFileExtension(listStats[i].path)) < 0) continue;
              listStats[i].listIndex = position;
              if (!self.selectingFolder || listStats[i].isFolder) { //don't list files when mode is set to selecting a folder
                position++;
                self.filesAndFolders.push(new fileFolderItem(listStats[i]));
              }
            }
          }
          loading(false);
        }, true);
      }
      this.selectFolders = function(callback) {
        self.selectingFolder = true;
        self.open("", callback);
      }
      this.executeTask = function() {
        /* 				var fullList = self.filesAndFolders();
        				var selectedList = self.selection();
        				for (var s in selectedList) {
        					fullList[selectedList[s].index].open();
        				} */
        if (!self.selectingFolder && (self.selection().length == 1 && self.selection()[0].isFolder()))
          self.selection()[0].open(); //special case for opening folders with 'open' button
        else {
          self.callback(self.selection());
          self.close();
        }
      };
    }
  }
  if (!usingNode) {
    var fileBrowser = new fileBrowser();
    ko.applyBindings(fileBrowser, $('#file-browser-canvas')[0]);
    self.webFileBrowserClosed = ko.computed(function() {
      return !fileBrowser.isVisible();
    });
  }

  function contextMenu(newTarget, newOptions) {
    var self = this;
    var target = newTarget;
    var options = newOptions;
    self.getTitle = function() {
      return title;
    }
    self.getOptions = ko.computed(function() {
      return ko.unwrap(options);
    }, this);
    self.getTarget = function() {
      return target;
    }
  }

  function menuOption(newLabel, newAction, newSubMenu) {
    var self = this;
    var label = newLabel;
    var action = newAction;
    var subMenu = newSubMenu;

    self.getLabel = function() {
      return label;
    }
    self.getSubMenuOptions = function() {
      return subMenu;
    }
    self.doAction = action;
  }
  var fileBrowserSceneMenuOptions = ko.observableArray([
    new menuOption("Open Scene", function(menu) {
      menu.getTarget().open();
    })
  ]);
  var fileBrowserFolderMenuOptions = ko.observableArray([
    new menuOption("Open Folder", function(menu) {
      menu.getTarget().open();
    })
  ]);

  if (platform !== "mac_os") {
    function toolbarMenu(data) {
      var menu = this;
      var title = ko.observable(data.title || "");
      var expanded = ko.observable(false);
      menu.isActive = data.active || true;
      menu.getTarget = data.target;
      menu.doAction = function(option) {
        expanded(false);
        option.doAction(menu);
      }
      menu.isExpanded = ko.computed(function() {
        return expanded();
      }, this);
      menu.toggle = function(force) {
        if (typeof force === "boolean") {
          expanded(force)
        } else {
          expanded() ? expanded(false) : expanded(true);
        }
      }
      menu.getTitle = function() {
        return title();
      }();
      menu.getOptions = ko.computed(function() {
        return data.options();
      }, this);
    }

    var toolbarMenus = ko.observableArray(
      [
        new toolbarMenu({
          title: "<span title='Project' class='fa fa-folder-open-o '>",
          active: self.getActiveProject,
          options: ko.computed(function() {
            return (new contextMenu(activeProject(), projectMenuOptions).getOptions())
          }, this),
          target: ko.computed(function() {
            return activeProject()
          }, this)
        }),
        new toolbarMenu({
          title: "<span title='Scene' class='fa fa-file-text-o'>",
          active: self.getActiveFile,
          options: ko.computed(function() {
            return (new contextMenu(activeFile(), fileMenuOptions).getOptions())
          }, this),
          target: ko.computed(function() {
            return activeFile()
          }, this)
        })
      ]
    );
    self.getToolbarMenus = ko.computed(function() {
      return toolbarMenus();
    }, this);
  }

  //ACCESSOR METHODS
  var menu = ko.observable();
  function CSIDE_ContextMenu() {
    var self = this;
    self.isReady = function() {
      return true;
    }
    self.getContextMenu = ko.computed(function() {
      return menu();
    }, this);
    //project & file context menus
    $(function() {
      $('#sidebar').contextmenu({
        target: '#context-menu',
        scopes: '.project-header',
        before: function(event, element) {
          var project = ko.dataFor(element.parent().get(0));
          menu(new contextMenu(project, projectMenuOptions));
          return true;
        }
      });
      $('#main-project-wrap').contextmenu({
        target: '#context-menu',
        scopes: '.scene',
        before: function(event, element) {
          var file = ko.dataFor(element.get(0));
          if (file.getErrState() || !file.hasLoaded() || file.isSaving() || file.isLocked()) //disallow allow context-menus for unloaded files etc
            return false;
          menu(new contextMenu(file, fileMenuOptions));
          return true;
        }
      });
      // editor tags
      $('#editor-tab-list-event-wrapper').contextmenu({
        target: '#context-menu',
        scopes: '.editor-tag',
        before: function(event, element) {
          var editor = ko.dataFor(element.get(0));
          var pinOption =  new menuOption(editor.isPinned()? "Unpin" : "Pin" + " editor", function(menu) {
            if (editor.isPinned()) {
              editor.unpin();
            } else {
              editor.pin();
            }
          });
          menu(new contextMenu(editor, [pinOption].concat(EditorTagOptions())));
          return true;
        }
      });
      $('#file-browser-ul').contextmenu({
        target: '#context-menu',
        scopes: '.file',
        before: function(event, element) {
          var fileFolder = ko.dataFor(element.get(0));
          if (fileFolder.isFolder())
            menu(new contextMenu(fileFolder, fileBrowserFolderMenuOptions));
          else
            menu(new contextMenu(fileFolder, fileBrowserSceneMenuOptions));
          return true;
        }
      });
    });
  }

  var myContextMenuViewModel = new CSIDE_ContextMenu();
  ko.applyBindings(myContextMenuViewModel, $('#context-menu')[0]);

}

require = amdRequire; // restore for monaco's lazy loading
amdRequire(['vs/editor/editor.main'], function() {
  window.cside = new IDEViewModel();
  window.monaco = monaco;
  ko.applyBindings(cside, $('.main-wrap')[0]);
  cside.init();
});


;// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

// If we're in node require encoding-indexes and attach it to the global.
/**
 * @fileoverview Global |this| required for resolving indexes in node.
 * @suppress {globalThis}
 */
if (typeof module !== "undefined" && module.exports) {
  this["encoding-indexes"] =
    require("./encoding-indexes.js")["encoding-indexes"];
}

(function(global) {
  'use strict';

  //
  // Utilities
  //

  /**
   * @param {number} a The number to test.
   * @param {number} min The minimum value in the range, inclusive.
   * @param {number} max The maximum value in the range, inclusive.
   * @return {boolean} True if a >= min and a <= max.
   */
  function inRange(a, min, max) {
    return min <= a && a <= max;
  }

  /**
   * @param {!Array.<*>} array The array to check.
   * @param {*} item The item to look for in the array.
   * @return {boolean} True if the item appears in the array.
   */
  function includes(array, item) {
    return array.indexOf(item) !== -1;
  }

  var floor = Math.floor;

  /**
   * @param {*} o
   * @return {Object}
   */
  function ToDictionary(o) {
    if (o === undefined) return {};
    if (o === Object(o)) return o;
    throw TypeError('Could not convert argument to dictionary');
  }

  /**
   * @param {string} string Input string of UTF-16 code units.
   * @return {!Array.<number>} Code points.
   */
  function stringToCodePoints(string) {
    // https://heycam.github.io/webidl/#dfn-obtain-unicode

    // 1. Let S be the DOMString value.
    var s = String(string);

    // 2. Let n be the length of S.
    var n = s.length;

    // 3. Initialize i to 0.
    var i = 0;

    // 4. Initialize U to be an empty sequence of Unicode characters.
    var u = [];

    // 5. While i < n:
    while (i < n) {

      // 1. Let c be the code unit in S at index i.
      var c = s.charCodeAt(i);

      // 2. Depending on the value of c:

      // c < 0xD800 or c > 0xDFFF
      if (c < 0xD800 || c > 0xDFFF) {
        // Append to U the Unicode character with code point c.
        u.push(c);
      }

      // 0xDC00 ≤ c ≤ 0xDFFF
      else if (0xDC00 <= c && c <= 0xDFFF) {
        // Append to U a U+FFFD REPLACEMENT CHARACTER.
        u.push(0xFFFD);
      }

      // 0xD800 ≤ c ≤ 0xDBFF
      else if (0xD800 <= c && c <= 0xDBFF) {
        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT
        // CHARACTER.
        if (i === n - 1) {
          u.push(0xFFFD);
        }
        // 2. Otherwise, i < n−1:
        else {
          // 1. Let d be the code unit in S at index i+1.
          var d = s.charCodeAt(i + 1);

          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:
          if (0xDC00 <= d && d <= 0xDFFF) {
            // 1. Let a be c & 0x3FF.
            var a = c & 0x3FF;

            // 2. Let b be d & 0x3FF.
            var b = d & 0x3FF;

            // 3. Append to U the Unicode character with code point
            // 2^16+2^10*a+b.
            u.push(0x10000 + (a << 10) + b);

            // 4. Set i to i+1.
            i += 1;
          }

          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
          // U+FFFD REPLACEMENT CHARACTER.
          else  {
            u.push(0xFFFD);
          }
        }
      }

      // 3. Set i to i+1.
      i += 1;
    }

    // 6. Return U.
    return u;
  }

  /**
   * @param {!Array.<number>} code_points Array of code points.
   * @return {string} string String of UTF-16 code units.
   */
  function codePointsToString(code_points) {
    var s = '';
    for (var i = 0; i < code_points.length; ++i) {
      var cp = code_points[i];
      if (cp <= 0xFFFF) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 0x10000;
        s += String.fromCharCode((cp >> 10) + 0xD800,
                                 (cp & 0x3FF) + 0xDC00);
      }
    }
    return s;
  }


  //
  // Implementation of Encoding specification
  // https://encoding.spec.whatwg.org/
  //

  //
  // 4. Terminology
  //

  /**
   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.
   * @param {number} a The number to test.
   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.
   */
  function isASCIIByte(a) {
    return 0x00 <= a && a <= 0x7F;
  }

  /**
   * An ASCII code point is a code point in the range U+0000 to
   * U+007F, inclusive.
   */
  var isASCIICodePoint = isASCIIByte;


  /**
   * End-of-stream is a special token that signifies no more tokens
   * are in the stream.
   * @const
   */ var end_of_stream = -1;

  /**
   * A stream represents an ordered sequence of tokens.
   *
   * @constructor
   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide
   * the stream.
   */
  function Stream(tokens) {
    /** @type {!Array.<number>} */
    this.tokens = [].slice.call(tokens);
    // Reversed as push/pop is more efficient than shift/unshift.
    this.tokens.reverse();
  }

  Stream.prototype = {
    /**
     * @return {boolean} True if end-of-stream has been hit.
     */
    endOfStream: function() {
      return !this.tokens.length;
    },

    /**
     * When a token is read from a stream, the first token in the
     * stream must be returned and subsequently removed, and
     * end-of-stream must be returned otherwise.
     *
     * @return {number} Get the next token from the stream, or
     * end_of_stream.
     */
     read: function() {
      if (!this.tokens.length)
        return end_of_stream;
       return this.tokens.pop();
     },

    /**
     * When one or more tokens are prepended to a stream, those tokens
     * must be inserted, in given order, before the first token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The token(s) to prepend to the
     * stream.
     */
    prepend: function(token) {
      if (Array.isArray(token)) {
        var tokens = /**@type {!Array.<number>}*/(token);
        while (tokens.length)
          this.tokens.push(tokens.pop());
      } else {
        this.tokens.push(token);
      }
    },

    /**
     * When one or more tokens are pushed to a stream, those tokens
     * must be inserted, in given order, after the last token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The tokens(s) to push to the
     * stream.
     */
    push: function(token) {
      if (Array.isArray(token)) {
        var tokens = /**@type {!Array.<number>}*/(token);
        while (tokens.length)
          this.tokens.unshift(tokens.shift());
      } else {
        this.tokens.unshift(token);
      }
    }
  };

  //
  // 5. Encodings
  //

  // 5.1 Encoders and decoders

  /** @const */
  var finished = -1;

  /**
   * @param {boolean} fatal If true, decoding errors raise an exception.
   * @param {number=} opt_code_point Override the standard fallback code point.
   * @return {number} The code point to insert on a decoding error.
   */
  function decoderError(fatal, opt_code_point) {
    if (fatal)
      throw TypeError('Decoder error');
    return opt_code_point || 0xFFFD;
  }

  /**
   * @param {number} code_point The code point that could not be encoded.
   * @return {number} Always throws, no value is actually returned.
   */
  function encoderError(code_point) {
    throw TypeError('The code point ' + code_point + ' could not be encoded.');
  }

  /** @interface */
  function Decoder() {}
  Decoder.prototype = {
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point, or |finished|.
     */
    handler: function(stream, bite) {}
  };

  /** @interface */
  function Encoder() {}
  Encoder.prototype = {
    /**
     * @param {Stream} stream The stream of code points being encoded.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
     */
    handler: function(stream, code_point) {}
  };

  // 5.2 Names and labels

  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}
  // https://github.com/google/closure-compiler/issues/247

  /**
   * @param {string} label The encoding label.
   * @return {?{name:string,labels:Array.<string>}}
   */
  function getEncoding(label) {
    // 1. Remove any leading and trailing ASCII whitespace from label.
    label = String(label).trim().toLowerCase();

    // 2. If label is an ASCII case-insensitive match for any of the
    // labels listed in the table below, return the corresponding
    // encoding, and failure otherwise.
    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label];
    }
    return null;
  }

  /**
   * Encodings table: https://encoding.spec.whatwg.org/encodings.json
   * @const
   * @type {!Array.<{
   *          heading: string,
   *          encodings: Array.<{name:string,labels:Array.<string>}>
   *        }>}
   */
  var encodings = [
    {
      "encodings": [
        {
          "labels": [
            "unicode-1-1-utf-8",
            "utf-8",
            "utf8"
          ],
          "name": "UTF-8"
        }
      ],
      "heading": "The Encoding"
    },
    {
      "encodings": [
        {
          "labels": [
            "866",
            "cp866",
            "csibm866",
            "ibm866"
          ],
          "name": "IBM866"
        },
        {
          "labels": [
            "csisolatin2",
            "iso-8859-2",
            "iso-ir-101",
            "iso8859-2",
            "iso88592",
            "iso_8859-2",
            "iso_8859-2:1987",
            "l2",
            "latin2"
          ],
          "name": "ISO-8859-2"
        },
        {
          "labels": [
            "csisolatin3",
            "iso-8859-3",
            "iso-ir-109",
            "iso8859-3",
            "iso88593",
            "iso_8859-3",
            "iso_8859-3:1988",
            "l3",
            "latin3"
          ],
          "name": "ISO-8859-3"
        },
        {
          "labels": [
            "csisolatin4",
            "iso-8859-4",
            "iso-ir-110",
            "iso8859-4",
            "iso88594",
            "iso_8859-4",
            "iso_8859-4:1988",
            "l4",
            "latin4"
          ],
          "name": "ISO-8859-4"
        },
        {
          "labels": [
            "csisolatincyrillic",
            "cyrillic",
            "iso-8859-5",
            "iso-ir-144",
            "iso8859-5",
            "iso88595",
            "iso_8859-5",
            "iso_8859-5:1988"
          ],
          "name": "ISO-8859-5"
        },
        {
          "labels": [
            "arabic",
            "asmo-708",
            "csiso88596e",
            "csiso88596i",
            "csisolatinarabic",
            "ecma-114",
            "iso-8859-6",
            "iso-8859-6-e",
            "iso-8859-6-i",
            "iso-ir-127",
            "iso8859-6",
            "iso88596",
            "iso_8859-6",
            "iso_8859-6:1987"
          ],
          "name": "ISO-8859-6"
        },
        {
          "labels": [
            "csisolatingreek",
            "ecma-118",
            "elot_928",
            "greek",
            "greek8",
            "iso-8859-7",
            "iso-ir-126",
            "iso8859-7",
            "iso88597",
            "iso_8859-7",
            "iso_8859-7:1987",
            "sun_eu_greek"
          ],
          "name": "ISO-8859-7"
        },
        {
          "labels": [
            "csiso88598e",
            "csisolatinhebrew",
            "hebrew",
            "iso-8859-8",
            "iso-8859-8-e",
            "iso-ir-138",
            "iso8859-8",
            "iso88598",
            "iso_8859-8",
            "iso_8859-8:1988",
            "visual"
          ],
          "name": "ISO-8859-8"
        },
        {
          "labels": [
            "csiso88598i",
            "iso-8859-8-i",
            "logical"
          ],
          "name": "ISO-8859-8-I"
        },
        {
          "labels": [
            "csisolatin6",
            "iso-8859-10",
            "iso-ir-157",
            "iso8859-10",
            "iso885910",
            "l6",
            "latin6"
          ],
          "name": "ISO-8859-10"
        },
        {
          "labels": [
            "iso-8859-13",
            "iso8859-13",
            "iso885913"
          ],
          "name": "ISO-8859-13"
        },
        {
          "labels": [
            "iso-8859-14",
            "iso8859-14",
            "iso885914"
          ],
          "name": "ISO-8859-14"
        },
        {
          "labels": [
            "csisolatin9",
            "iso-8859-15",
            "iso8859-15",
            "iso885915",
            "iso_8859-15",
            "l9"
          ],
          "name": "ISO-8859-15"
        },
        {
          "labels": [
            "iso-8859-16"
          ],
          "name": "ISO-8859-16"
        },
        {
          "labels": [
            "cskoi8r",
            "koi",
            "koi8",
            "koi8-r",
            "koi8_r"
          ],
          "name": "KOI8-R"
        },
        {
          "labels": [
            "koi8-ru",
            "koi8-u"
          ],
          "name": "KOI8-U"
        },
        {
          "labels": [
            "csmacintosh",
            "mac",
            "macintosh",
            "x-mac-roman"
          ],
          "name": "macintosh"
        },
        {
          "labels": [
            "dos-874",
            "iso-8859-11",
            "iso8859-11",
            "iso885911",
            "tis-620",
            "windows-874"
          ],
          "name": "windows-874"
        },
        {
          "labels": [
            "cp1250",
            "windows-1250",
            "x-cp1250"
          ],
          "name": "windows-1250"
        },
        {
          "labels": [
            "cp1251",
            "windows-1251",
            "x-cp1251"
          ],
          "name": "windows-1251"
        },
        {
          "labels": [
            "ansi_x3.4-1968",
            "ascii",
            "cp1252",
            "cp819",
            "csisolatin1",
            "ibm819",
            "iso-8859-1",
            "iso-ir-100",
            "iso8859-1",
            "iso88591",
            "iso_8859-1",
            "iso_8859-1:1987",
            "l1",
            "latin1",
            "us-ascii",
            "windows-1252",
            "x-cp1252"
          ],
          "name": "windows-1252"
        },
        {
          "labels": [
            "cp1253",
            "windows-1253",
            "x-cp1253"
          ],
          "name": "windows-1253"
        },
        {
          "labels": [
            "cp1254",
            "csisolatin5",
            "iso-8859-9",
            "iso-ir-148",
            "iso8859-9",
            "iso88599",
            "iso_8859-9",
            "iso_8859-9:1989",
            "l5",
            "latin5",
            "windows-1254",
            "x-cp1254"
          ],
          "name": "windows-1254"
        },
        {
          "labels": [
            "cp1255",
            "windows-1255",
            "x-cp1255"
          ],
          "name": "windows-1255"
        },
        {
          "labels": [
            "cp1256",
            "windows-1256",
            "x-cp1256"
          ],
          "name": "windows-1256"
        },
        {
          "labels": [
            "cp1257",
            "windows-1257",
            "x-cp1257"
          ],
          "name": "windows-1257"
        },
        {
          "labels": [
            "cp1258",
            "windows-1258",
            "x-cp1258"
          ],
          "name": "windows-1258"
        },
        {
          "labels": [
            "x-mac-cyrillic",
            "x-mac-ukrainian"
          ],
          "name": "x-mac-cyrillic"
        }
      ],
      "heading": "Legacy single-byte encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "chinese",
            "csgb2312",
            "csiso58gb231280",
            "gb2312",
            "gb_2312",
            "gb_2312-80",
            "gbk",
            "iso-ir-58",
            "x-gbk"
          ],
          "name": "GBK"
        },
        {
          "labels": [
            "gb18030"
          ],
          "name": "gb18030"
        }
      ],
      "heading": "Legacy multi-byte Chinese (simplified) encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "big5",
            "big5-hkscs",
            "cn-big5",
            "csbig5",
            "x-x-big5"
          ],
          "name": "Big5"
        }
      ],
      "heading": "Legacy multi-byte Chinese (traditional) encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "cseucpkdfmtjapanese",
            "euc-jp",
            "x-euc-jp"
          ],
          "name": "EUC-JP"
        },
        {
          "labels": [
            "csiso2022jp",
            "iso-2022-jp"
          ],
          "name": "ISO-2022-JP"
        },
        {
          "labels": [
            "csshiftjis",
            "ms932",
            "ms_kanji",
            "shift-jis",
            "shift_jis",
            "sjis",
            "windows-31j",
            "x-sjis"
          ],
          "name": "Shift_JIS"
        }
      ],
      "heading": "Legacy multi-byte Japanese encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "cseuckr",
            "csksc56011987",
            "euc-kr",
            "iso-ir-149",
            "korean",
            "ks_c_5601-1987",
            "ks_c_5601-1989",
            "ksc5601",
            "ksc_5601",
            "windows-949"
          ],
          "name": "EUC-KR"
        }
      ],
      "heading": "Legacy multi-byte Korean encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "csiso2022kr",
            "hz-gb-2312",
            "iso-2022-cn",
            "iso-2022-cn-ext",
            "iso-2022-kr"
          ],
          "name": "replacement"
        },
        {
          "labels": [
            "utf-16be"
          ],
          "name": "UTF-16BE"
        },
        {
          "labels": [
            "utf-16",
            "utf-16le"
          ],
          "name": "UTF-16LE"
        },
        {
          "labels": [
            "x-user-defined"
          ],
          "name": "x-user-defined"
        }
      ],
      "heading": "Legacy miscellaneous encodings"
    }
  ];

  // Label to encoding registry.
  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */
  var label_to_encoding = {};
  encodings.forEach(function(category) {
    category.encodings.forEach(function(encoding) {
      encoding.labels.forEach(function(label) {
        label_to_encoding[label] = encoding;
      });
    });
  });

  // Registry of of encoder/decoder factories, by encoding name.
  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */
  var encoders = {};
  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */
  var decoders = {};

  //
  // 6. Indexes
  //

  /**
   * @param {number} pointer The |pointer| to search for.
   * @param {(!Array.<?number>|undefined)} index The |index| to search within.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in |index|.
   */
  function indexCodePointFor(pointer, index) {
    if (!index) return null;
    return index[pointer] || null;
  }

  /**
   * @param {number} code_point The |code point| to search for.
   * @param {!Array.<?number>} index The |index| to search within.
   * @return {?number} The first pointer corresponding to |code point| in
   *     |index|, or null if |code point| is not in |index|.
   */
  function indexPointerFor(code_point, index) {
    var pointer = index.indexOf(code_point);
    return pointer === -1 ? null : pointer;
  }

  /**
   * @param {string} name Name of the index.
   * @return {(!Array.<number>|!Array.<Array.<number>>)}
   *  */
  function index(name) {
    if (!('encoding-indexes' in global)) {
      throw Error("Indexes missing." +
                  " Did you forget to include encoding-indexes.js?");
    }
    return global['encoding-indexes'][name];
  }

  /**
   * @param {number} pointer The |pointer| to search for in the gb18030 index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the gb18030 index.
   */
  function indexGB18030RangesCodePointFor(pointer) {
    // 1. If pointer is greater than 39419 and less than 189000, or
    // pointer is greater than 1237575, return null.
    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))
      return null;

    // 2. If pointer is 7457, return code point U+E7C7.
    if (pointer === 7457) return 0xE7C7;

    // 3. Let offset be the last pointer in index gb18030 ranges that
    // is equal to or less than pointer and let code point offset be
    // its corresponding code point.
    var offset = 0;
    var code_point_offset = 0;
    var idx = index('gb18030-ranges');
    var i;
    for (i = 0; i < idx.length; ++i) {
      /** @type {!Array.<number>} */
      var entry = idx[i];
      if (entry[0] <= pointer) {
        offset = entry[0];
        code_point_offset = entry[1];
      } else {
        break;
      }
    }

    // 4. Return a code point whose value is code point offset +
    // pointer − offset.
    return code_point_offset + pointer - offset;
  }

  /**
   * @param {number} code_point The |code point| to locate in the gb18030 index.
   * @return {number} The first pointer corresponding to |code point| in the
   *     gb18030 index.
   */
  function indexGB18030RangesPointerFor(code_point) {
    // 1. If code point is U+E7C7, return pointer 7457.
    if (code_point === 0xE7C7) return 7457;

    // 2. Let offset be the last code point in index gb18030 ranges
    // that is equal to or less than code point and let pointer offset
    // be its corresponding pointer.
    var offset = 0;
    var pointer_offset = 0;
    var idx = index('gb18030-ranges');
    var i;
    for (i = 0; i < idx.length; ++i) {
      /** @type {!Array.<number>} */
      var entry = idx[i];
      if (entry[1] <= code_point) {
        offset = entry[1];
        pointer_offset = entry[0];
      } else {
        break;
      }
    }

    // 3. Return a pointer whose value is pointer offset + code point
    // − offset.
    return pointer_offset + code_point - offset;
  }

  /**
   * @param {number} code_point The |code_point| to search for in the Shift_JIS
   *     index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the Shift_JIS index.
   */
  function indexShiftJISPointerFor(code_point) {
    // 1. Let index be index jis0208 excluding all entries whose
    // pointer is in the range 8272 to 8835, inclusive.
    shift_jis_index = shift_jis_index ||
      index('jis0208').map(function(code_point, pointer) {
        return inRange(pointer, 8272, 8835) ? null : code_point;
      });
    var index_ = shift_jis_index;

    // 2. Return the index pointer for code point in index.
    return index_.indexOf(code_point);
  }
  var shift_jis_index;

  /**
   * @param {number} code_point The |code_point| to search for in the big5
   *     index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the big5 index.
   */
  function indexBig5PointerFor(code_point) {
    // 1. Let index be index Big5 excluding all entries whose pointer
    big5_index_no_hkscs = big5_index_no_hkscs ||
      index('big5').map(function(code_point, pointer) {
        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;
      });
    var index_ = big5_index_no_hkscs;

    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or
    // U+5345, return the last pointer corresponding to code point in
    // index.
    if (code_point === 0x2550 || code_point === 0x255E ||
        code_point === 0x2561 || code_point === 0x256A ||
        code_point === 0x5341 || code_point === 0x5345) {
      return index_.lastIndexOf(code_point);
    }

    // 3. Return the index pointer for code point in index.
    return indexPointerFor(code_point, index_);
  }
  var big5_index_no_hkscs;

  //
  // 8. API
  //

  /** @const */ var DEFAULT_ENCODING = 'utf-8';

  // 8.1 Interface TextDecoder

  /**
   * @constructor
   * @param {string=} label The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {Object=} options
   */
  function TextDecoder(label, options) {
    // Web IDL conventions
    if (!(this instanceof TextDecoder))
      throw TypeError('Called as a function. Did you forget \'new\'?');
    label = label !== undefined ? String(label) : DEFAULT_ENCODING;
    options = ToDictionary(options);

    // A TextDecoder object has an associated encoding, decoder,
    // stream, ignore BOM flag (initially unset), BOM seen flag
    // (initially unset), error mode (initially replacement), and do
    // not flush flag (initially unset).

    /** @private */
    this._encoding = null;
    /** @private @type {?Decoder} */
    this._decoder = null;
    /** @private @type {boolean} */
    this._ignoreBOM = false;
    /** @private @type {boolean} */
    this._BOMseen = false;
    /** @private @type {string} */
    this._error_mode = 'replacement';
    /** @private @type {boolean} */
    this._do_not_flush = false;


    // 1. Let encoding be the result of getting an encoding from
    // label.
    var encoding = getEncoding(label);

    // 2. If encoding is failure or replacement, throw a RangeError.
    if (encoding === null || encoding.name === 'replacement')
      throw RangeError('Unknown encoding: ' + label);
    if (!decoders[encoding.name]) {
      throw Error('Decoder not present.' +
                  ' Did you forget to include encoding-indexes.js?');
    }

    // 3. Let dec be a new TextDecoder object.
    var dec = this;

    // 4. Set dec's encoding to encoding.
    dec._encoding = encoding;

    // 5. If options's fatal member is true, set dec's error mode to
    // fatal.
    if (Boolean(options['fatal']))
      dec._error_mode = 'fatal';

    // 6. If options's ignoreBOM member is true, set dec's ignore BOM
    // flag.
    if (Boolean(options['ignoreBOM']))
      dec._ignoreBOM = true;

    // For pre-ES5 runtimes:
    if (!Object.defineProperty) {
      this.encoding = dec._encoding.name.toLowerCase();
      this.fatal = dec._error_mode === 'fatal';
      this.ignoreBOM = dec._ignoreBOM;
    }

    // 7. Return dec.
    return dec;
  }

  if (Object.defineProperty) {
    // The encoding attribute's getter must return encoding's name.
    Object.defineProperty(TextDecoder.prototype, 'encoding', {
      /** @this {TextDecoder} */
      get: function() { return this._encoding.name.toLowerCase(); }
    });

    // The fatal attribute's getter must return true if error mode
    // is fatal, and false otherwise.
    Object.defineProperty(TextDecoder.prototype, 'fatal', {
      /** @this {TextDecoder} */
      get: function() { return this._error_mode === 'fatal'; }
    });

    // The ignoreBOM attribute's getter must return true if ignore
    // BOM flag is set, and false otherwise.
    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {
      /** @this {TextDecoder} */
      get: function() { return this._ignoreBOM; }
    });
  }

  /**
   * @param {BufferSource=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  TextDecoder.prototype.decode = function decode(input, options) {
    var bytes;
    if (typeof input === 'object' && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === 'object' && 'buffer' in input &&
               input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(input.buffer,
                             input.byteOffset,
                             input.byteLength);
    } else {
      bytes = new Uint8Array(0);
    }

    options = ToDictionary(options);

    // 1. If the do not flush flag is unset, set decoder to a new
    // encoding's decoder, set stream to a new stream, and unset the
    // BOM seen flag.
    if (!this._do_not_flush) {
      this._decoder = decoders[this._encoding.name]({
        fatal: this._error_mode === 'fatal'});
      this._BOMseen = false;
    }

    // 2. If options's stream is true, set the do not flush flag, and
    // unset the do not flush flag otherwise.
    this._do_not_flush = Boolean(options['stream']);

    // 3. If input is given, push a copy of input to stream.
    // TODO: Align with spec algorithm - maintain stream on instance.
    var input_stream = new Stream(bytes);

    // 4. Let output be a new stream.
    var output = [];

    /** @type {?(number|!Array.<number>)} */
    var result;

    // 5. While true:
    while (true) {
      // 1. Let token be the result of reading from stream.
      var token = input_stream.read();

      // 2. If token is end-of-stream and the do not flush flag is
      // set, return output, serialized.
      // TODO: Align with spec algorithm.
      if (token === end_of_stream)
        break;

      // 3. Otherwise, run these subsubsteps:

      // 1. Let result be the result of processing token for decoder,
      // stream, output, and error mode.
      result = this._decoder.handler(input_stream, token);

      // 2. If result is finished, return output, serialized.
      if (result === finished)
        break;

      if (result !== null) {
        if (Array.isArray(result))
          output.push.apply(output, /**@type {!Array.<number>}*/(result));
        else
          output.push(result);
      }

      // 3. Otherwise, if result is error, throw a TypeError.
      // (Thrown in handler)

      // 4. Otherwise, do nothing.
    }
    // TODO: Align with spec algorithm.
    if (!this._do_not_flush) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          output.push.apply(output, /**@type {!Array.<number>}*/(result));
        else
          output.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }

    // A TextDecoder object also has an associated serialize stream
    // algorithm...
    /**
     * @param {!Array.<number>} stream
     * @return {string}
     * @this {TextDecoder}
     */
    function serializeStream(stream) {
      // 1. Let token be the result of reading from stream.
      // (Done in-place on array, rather than as a stream)

      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore
      // BOM flag and BOM seen flag are unset, run these subsubsteps:
      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&
          !this._ignoreBOM && !this._BOMseen) {
        if (stream.length > 0 && stream[0] === 0xFEFF) {
          // 1. If token is U+FEFF, set BOM seen flag.
          this._BOMseen = true;
          stream.shift();
        } else if (stream.length > 0) {
          // 2. Otherwise, if token is not end-of-stream, set BOM seen
          // flag and append token to stream.
          this._BOMseen = true;
        } else {
          // 3. Otherwise, if token is not end-of-stream, append token
          // to output.
          // (no-op)
        }
      }
      // 4. Otherwise, return output.
      return codePointsToString(stream);
    }

    return serializeStream.call(this, output);
  };

  // 8.2 Interface TextEncoder

  /**
   * @constructor
   * @param {string=} label The label of the encoding. NONSTANDARD.
   * @param {Object=} options NONSTANDARD.
   */
  function TextEncoder(label, options) {
    // Web IDL conventions
    if (!(this instanceof TextEncoder))
      throw TypeError('Called as a function. Did you forget \'new\'?');
    options = ToDictionary(options);

    // A TextEncoder object has an associated encoding and encoder.

    /** @private */
    this._encoding = null;
    /** @private @type {?Encoder} */
    this._encoder = null;

    // Non-standard
    /** @private @type {boolean} */
    this._do_not_flush = false;
    /** @private @type {string} */
    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';

    // 1. Let enc be a new TextEncoder object.
    var enc = this;

    // 2. Set enc's encoding to UTF-8's encoder.
    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {
      // NONSTANDARD behavior.
      label = label !== undefined ? String(label) : DEFAULT_ENCODING;
      var encoding = getEncoding(label);
      if (encoding === null || encoding.name === 'replacement')
        throw RangeError('Unknown encoding: ' + label);
      if (!encoders[encoding.name]) {
        throw Error('Encoder not present.' +
                    ' Did you forget to include encoding-indexes.js?');
      }
      enc._encoding = encoding;
    } else {
      // Standard behavior.
      enc._encoding = getEncoding('utf-8');

      if (label !== undefined && 'console' in global) {
        console.warn('TextEncoder constructor called with encoding label, '
                     + 'which is ignored.');
      }
    }

    // For pre-ES5 runtimes:
    if (!Object.defineProperty)
      this.encoding = enc._encoding.name.toLowerCase();

    // 3. Return enc.
    return enc;
  }

  if (Object.defineProperty) {
    // The encoding attribute's getter must return encoding's name.
    Object.defineProperty(TextEncoder.prototype, 'encoding', {
      /** @this {TextEncoder} */
      get: function() { return this._encoding.name.toLowerCase(); }
    });
  }

  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.
   */
  TextEncoder.prototype.encode = function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : '';
    options = ToDictionary(options);

    // NOTE: This option is nonstandard. None of the encodings
    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when
    // the input is a USVString so streaming is not necessary.
    if (!this._do_not_flush)
      this._encoder = encoders[this._encoding.name]({
        fatal: this._fatal === 'fatal'});
    this._do_not_flush = Boolean(options['stream']);

    // 1. Convert input to a stream.
    var input = new Stream(stringToCodePoints(opt_string));

    // 2. Let output be a new stream
    var output = [];

    /** @type {?(number|!Array.<number>)} */
    var result;
    // 3. While true, run these substeps:
    while (true) {
      // 1. Let token be the result of reading from input.
      var token = input.read();
      if (token === end_of_stream)
        break;
      // 2. Let result be the result of processing token for encoder,
      // input, output.
      result = this._encoder.handler(input, token);
      if (result === finished)
        break;
      if (Array.isArray(result))
        output.push.apply(output, /**@type {!Array.<number>}*/(result));
      else
        output.push(result);
    }
    // TODO: Align with spec algorithm.
    if (!this._do_not_flush) {
      while (true) {
        result = this._encoder.handler(input, input.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          output.push.apply(output, /**@type {!Array.<number>}*/(result));
        else
          output.push(result);
      }
      this._encoder = null;
    }
    // 3. If result is finished, convert output into a byte sequence,
    // and then return a Uint8Array object wrapping an ArrayBuffer
    // containing output.
    return new Uint8Array(output);
  };


  //
  // 9. The encoding
  //

  // 9.1 utf-8

  // 9.1.1 utf-8 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function UTF8Decoder(options) {
    var fatal = options.fatal;

    // utf-8's decoder's has an associated utf-8 code point, utf-8
    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
    // lower boundary (initially 0x80), and a utf-8 upper boundary
    // (initially 0xBF).
    var /** @type {number} */ utf8_code_point = 0,
        /** @type {number} */ utf8_bytes_seen = 0,
        /** @type {number} */ utf8_bytes_needed = 0,
        /** @type {number} */ utf8_lower_boundary = 0x80,
        /** @type {number} */ utf8_upper_boundary = 0xBF;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
      // set utf-8 bytes needed to 0 and return error.
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream, return finished.
      if (bite === end_of_stream)
        return finished;

      // 3. If utf-8 bytes needed is 0, based on byte:
      if (utf8_bytes_needed === 0) {

        // 0x00 to 0x7F
        if (inRange(bite, 0x00, 0x7F)) {
          // Return a code point whose value is byte.
          return bite;
        }

        // 0xC2 to 0xDF
        else if (inRange(bite, 0xC2, 0xDF)) {
          // 1. Set utf-8 bytes needed to 1.
          utf8_bytes_needed = 1;

          // 2. Set UTF-8 code point to byte & 0x1F.
          utf8_code_point = bite & 0x1F;
        }

        // 0xE0 to 0xEF
        else if (inRange(bite, 0xE0, 0xEF)) {
          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
          if (bite === 0xE0)
            utf8_lower_boundary = 0xA0;
          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
          if (bite === 0xED)
            utf8_upper_boundary = 0x9F;
          // 3. Set utf-8 bytes needed to 2.
          utf8_bytes_needed = 2;
          // 4. Set UTF-8 code point to byte & 0xF.
          utf8_code_point = bite & 0xF;
        }

        // 0xF0 to 0xF4
        else if (inRange(bite, 0xF0, 0xF4)) {
          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
          if (bite === 0xF0)
            utf8_lower_boundary = 0x90;
          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
          if (bite === 0xF4)
            utf8_upper_boundary = 0x8F;
          // 3. Set utf-8 bytes needed to 3.
          utf8_bytes_needed = 3;
          // 4. Set UTF-8 code point to byte & 0x7.
          utf8_code_point = bite & 0x7;
        }

        // Otherwise
        else {
          // Return error.
          return decoderError(fatal);
        }

        // Return continue.
        return null;
      }

      // 4. If byte is not in the range utf-8 lower boundary to utf-8
      // upper boundary, inclusive, run these substeps:
      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {

        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
        // utf-8 upper boundary to 0xBF.
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 0x80;
        utf8_upper_boundary = 0xBF;

        // 2. Prepend byte to stream.
        stream.prepend(bite);

        // 3. Return error.
        return decoderError(fatal);
      }

      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
      // to 0xBF.
      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF;

      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &
      // 0x3F)
      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);

      // 7. Increase utf-8 bytes seen by one.
      utf8_bytes_seen += 1;

      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,
      // continue.
      if (utf8_bytes_seen !== utf8_bytes_needed)
        return null;

      // 9. Let code point be utf-8 code point.
      var code_point = utf8_code_point;

      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
      // seen to 0.
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

      // 11. Return a code point whose value is code point.
      return code_point;
    };
  }

  // 9.1.2 utf-8 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function UTF8Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Set count and offset based on the range code point is in:
      var count, offset;
      // U+0080 to U+07FF, inclusive:
      if (inRange(code_point, 0x0080, 0x07FF)) {
        // 1 and 0xC0
        count = 1;
        offset = 0xC0;
      }
      // U+0800 to U+FFFF, inclusive:
      else if (inRange(code_point, 0x0800, 0xFFFF)) {
        // 2 and 0xE0
        count = 2;
        offset = 0xE0;
      }
      // U+10000 to U+10FFFF, inclusive:
      else if (inRange(code_point, 0x10000, 0x10FFFF)) {
        // 3 and 0xF0
        count = 3;
        offset = 0xF0;
      }

      // 4. Let bytes be a byte sequence whose first byte is (code
      // point >> (6 × count)) + offset.
      var bytes = [(code_point >> (6 * count)) + offset];

      // 5. Run these substeps while count is greater than 0:
      while (count > 0) {

        // 1. Set temp to code point >> (6 × (count − 1)).
        var temp = code_point >> (6 * (count - 1));

        // 2. Append to bytes 0x80 | (temp & 0x3F).
        bytes.push(0x80 | (temp & 0x3F));

        // 3. Decrease count by one.
        count -= 1;
      }

      // 6. Return bytes bytes, in order.
      return bytes;
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['UTF-8'] = function(options) {
    return new UTF8Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['UTF-8'] = function(options) {
    return new UTF8Decoder(options);
  };

  //
  // 10. Legacy single-byte encodings
  //

  // 10.1 single-byte decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {!Array.<number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteDecoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream, return finished.
      if (bite === end_of_stream)
        return finished;

      // 2. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 3. Let code point be the index code point for byte − 0x80 in
      // index single-byte.
      var code_point = index[bite - 0x80];

      // 4. If code point is null, return error.
      if (code_point === null)
        return decoderError(fatal);

      // 5. Return a code point whose value is code point.
      return code_point;
    };
  }

  // 10.2 single-byte encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {!Array.<?number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteEncoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Let pointer be the index pointer for code point in index
      // single-byte.
      var pointer = indexPointerFor(code_point, index);

      // 4. If pointer is null, return error with code point.
      if (pointer === null)
        encoderError(code_point);

      // 5. Return a byte whose value is pointer + 0x80.
      return pointer + 0x80;
    };
  }

  (function() {
    if (!('encoding-indexes' in global))
      return;
    encodings.forEach(function(category) {
      if (category.heading !== 'Legacy single-byte encodings')
        return;
      category.encodings.forEach(function(encoding) {
        var name = encoding.name;
        var idx = index(name.toLowerCase());
        /** @param {{fatal: boolean}} options */
        decoders[name] = function(options) {
          return new SingleByteDecoder(idx, options);
        };
        /** @param {{fatal: boolean}} options */
        encoders[name] = function(options) {
          return new SingleByteEncoder(idx, options);
        };
      });
    });
  }());

  //
  // 11. Legacy multi-byte Chinese (simplified) encodings
  //

  // 11.1 gbk

  // 11.1.1 gbk decoder
  // gbk's decoder is gb18030's decoder.
  /** @param {{fatal: boolean}} options */
  decoders['GBK'] = function(options) {
    return new GB18030Decoder(options);
  };

  // 11.1.2 gbk encoder
  // gbk's encoder is gb18030's encoder with its gbk flag set.
  /** @param {{fatal: boolean}} options */
  encoders['GBK'] = function(options) {
    return new GB18030Encoder(options, true);
  };

  // 11.2 gb18030

  // 11.2.1 gb18030 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function GB18030Decoder(options) {
    var fatal = options.fatal;
    // gb18030's decoder has an associated gb18030 first, gb18030
    // second, and gb18030 third (all initially 0x00).
    var /** @type {number} */ gb18030_first = 0x00,
        /** @type {number} */ gb18030_second = 0x00,
        /** @type {number} */ gb18030_third = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and gb18030 first, gb18030
      // second, and gb18030 third are 0x00, return finished.
      if (bite === end_of_stream && gb18030_first === 0x00 &&
          gb18030_second === 0x00 && gb18030_third === 0x00) {
        return finished;
      }
      // 2. If byte is end-of-stream, and gb18030 first, gb18030
      // second, or gb18030 third is not 0x00, set gb18030 first,
      // gb18030 second, and gb18030 third to 0x00, and return error.
      if (bite === end_of_stream &&
          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||
           gb18030_third !== 0x00)) {
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        gb18030_third = 0x00;
        decoderError(fatal);
      }
      var code_point;
      // 3. If gb18030 third is not 0x00, run these substeps:
      if (gb18030_third !== 0x00) {
        // 1. Let code point be null.
        code_point = null;
        // 2. If byte is in the range 0x30 to 0x39, inclusive, set
        // code point to the index gb18030 ranges code point for
        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×
        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.
        if (inRange(bite, 0x30, 0x39)) {
          code_point = indexGB18030RangesCodePointFor(
              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +
               gb18030_third - 0x81) * 10 + bite - 0x30);
        }

        // 3. Let buffer be a byte sequence consisting of gb18030
        // second, gb18030 third, and byte, in order.
        var buffer = [gb18030_second, gb18030_third, bite];

        // 4. Set gb18030 first, gb18030 second, and gb18030 third to
        // 0x00.
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        gb18030_third = 0x00;

        // 5. If code point is null, prepend buffer to stream and
        // return error.
        if (code_point === null) {
          stream.prepend(buffer);
          return decoderError(fatal);
        }

        // 6. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If gb18030 second is not 0x00, run these substeps:
      if (gb18030_second !== 0x00) {

        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set
        // gb18030 third to byte and return continue.
        if (inRange(bite, 0x81, 0xFE)) {
          gb18030_third = bite;
          return null;
        }

        // 2. Prepend gb18030 second followed by byte to stream, set
        // gb18030 first and gb18030 second to 0x00, and return error.
        stream.prepend([gb18030_second, bite]);
        gb18030_first = 0x00;
        gb18030_second = 0x00;
        return decoderError(fatal);
      }

      // 5. If gb18030 first is not 0x00, run these substeps:
      if (gb18030_first !== 0x00) {

        // 1. If byte is in the range 0x30 to 0x39, inclusive, set
        // gb18030 second to byte and return continue.
        if (inRange(bite, 0x30, 0x39)) {
          gb18030_second = bite;
          return null;
        }

        // 2. Let lead be gb18030 first, let pointer be null, and set
        // gb18030 first to 0x00.
        var lead = gb18030_first;
        var pointer = null;
        gb18030_first = 0x00;

        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x41;

        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +
        // (byte − offset).
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))
          pointer = (lead - 0x81) * 190 + (bite - offset);

        // 5. Let code point be null if pointer is null and the index
        // code point for pointer in index gb18030 otherwise.
        code_point = pointer === null ? null :
            indexCodePointFor(pointer, index('gb18030'));

        // 6. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 7. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 8. Return a code point whose value is code point.
        return code_point;
      }

      // 6. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 7. If byte is 0x80, return code point U+20AC.
      if (bite === 0x80)
        return 0x20AC;

      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set
      // gb18030 first to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        gb18030_first = bite;
        return null;
      }

      // 9. Return error.
      return decoderError(fatal);
    };
  }

  // 11.2.2 gb18030 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   * @param {boolean=} gbk_flag
   */
  function GB18030Encoder(options, gbk_flag) {
    var fatal = options.fatal;
    // gb18030's decoder has an associated gbk flag (initially unset).
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. If code point is U+E5E5, return error with code point.
      if (code_point === 0xE5E5)
        return encoderError(code_point);

      // 4. If the gbk flag is set and code point is U+20AC, return
      // byte 0x80.
      if (gbk_flag && code_point === 0x20AC)
        return 0x80;

      // 5. Let pointer be the index pointer for code point in index
      // gb18030.
      var pointer = indexPointerFor(code_point, index('gb18030'));

      // 6. If pointer is not null, run these substeps:
      if (pointer !== null) {

        // 1. Let lead be floor(pointer / 190) + 0x81.
        var lead = floor(pointer / 190) + 0x81;

        // 2. Let trail be pointer % 190.
        var trail = pointer % 190;

        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.
        var offset = trail < 0x3F ? 0x40 : 0x41;

        // 4. Return two bytes whose values are lead and trail + offset.
        return [lead, trail + offset];
      }

      // 7. If gbk flag is set, return error with code point.
      if (gbk_flag)
        return encoderError(code_point);

      // 8. Set pointer to the index gb18030 ranges pointer for code
      // point.
      pointer = indexGB18030RangesPointerFor(code_point);

      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).
      var byte1 = floor(pointer / 10 / 126 / 10);

      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.
      pointer = pointer - byte1 * 10 * 126 * 10;

      // 11. Let byte2 be floor(pointer / 10 / 126).
      var byte2 = floor(pointer / 10 / 126);

      // 12. Set pointer to pointer − byte2 × 10 × 126.
      pointer = pointer - byte2 * 10 * 126;

      // 13. Let byte3 be floor(pointer / 10).
      var byte3 = floor(pointer / 10);

      // 14. Let byte4 be pointer − byte3 × 10.
      var byte4 = pointer - byte3 * 10;

      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +
      // 0x30, byte3 + 0x81, byte4 + 0x30.
      return [byte1 + 0x81,
              byte2 + 0x30,
              byte3 + 0x81,
              byte4 + 0x30];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['gb18030'] = function(options) {
    return new GB18030Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['gb18030'] = function(options) {
    return new GB18030Decoder(options);
  };


  //
  // 12. Legacy multi-byte Chinese (traditional) encodings
  //

  // 12.1 Big5

  // 12.1.1 Big5 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function Big5Decoder(options) {
    var fatal = options.fatal;
    // Big5's decoder has an associated Big5 lead (initially 0x00).
    var /** @type {number} */ Big5_lead = 0x00;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set
      // Big5 lead to 0x00 and return error.
      if (bite === end_of_stream && Big5_lead !== 0x00) {
        Big5_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and Big5 lead is 0x00, return
      // finished.
      if (bite === end_of_stream && Big5_lead === 0x00)
        return finished;

      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let
      // pointer be null, set Big5 lead to 0x00, and then run these
      // substeps:
      if (Big5_lead !== 0x00) {
        var lead = Big5_lead;
        var pointer = null;
        Big5_lead = 0x00;

        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62
        // otherwise.
        var offset = bite < 0x7F ? 0x40 : 0x62;

        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1
        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +
        // (byte − offset).
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))
          pointer = (lead - 0x81) * 157 + (bite - offset);

        // 3. If there is a row in the table below whose first column
        // is pointer, return the two code points listed in its second
        // column
        // Pointer | Code points
        // --------+--------------
        // 1133    | U+00CA U+0304
        // 1135    | U+00CA U+030C
        // 1164    | U+00EA U+0304
        // 1166    | U+00EA U+030C
        switch (pointer) {
          case 1133: return [0x00CA, 0x0304];
          case 1135: return [0x00CA, 0x030C];
          case 1164: return [0x00EA, 0x0304];
          case 1166: return [0x00EA, 0x030C];
        }

        // 4. Let code point be null if pointer is null and the index
        // code point for pointer in index Big5 otherwise.
        var code_point = (pointer === null) ? null :
            indexCodePointFor(pointer, index('big5'));

        // 5. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 6. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 7. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5
      // lead to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        Big5_lead = bite;
        return null;
      }

      // 6. Return error.
      return decoderError(fatal);
    };
  }

  // 12.1.2 Big5 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function Big5Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Let pointer be the index Big5 pointer for code point.
      var pointer = indexBig5PointerFor(code_point);

      // 4. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 5. Let lead be floor(pointer / 157) + 0x81.
      var lead = floor(pointer / 157) + 0x81;

      // 6. If lead is less than 0xA1, return error with code point.
      if (lead < 0xA1)
        return encoderError(code_point);

      // 7. Let trail be pointer % 157.
      var trail = pointer % 157;

      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62
      // otherwise.
      var offset = trail < 0x3F ? 0x40 : 0x62;

      // Return two bytes whose values are lead and trail + offset.
      return [lead, trail + offset];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['Big5'] = function(options) {
    return new Big5Encoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['Big5'] = function(options) {
    return new Big5Decoder(options);
  };


  //
  // 13. Legacy multi-byte Japanese encodings
  //

  // 13.1 euc-jp

  // 13.1.1 euc-jp decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function EUCJPDecoder(options) {
    var fatal = options.fatal;

    // euc-jp's decoder has an associated euc-jp jis0212 flag
    // (initially unset) and euc-jp lead (initially 0x00).
    var /** @type {boolean} */ eucjp_jis0212_flag = false,
        /** @type {number} */ eucjp_lead = 0x00;

    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set
      // euc-jp lead to 0x00, and return error.
      if (bite === end_of_stream && eucjp_lead !== 0x00) {
        eucjp_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return
      // finished.
      if (bite === end_of_stream && eucjp_lead === 0x00)
        return finished;

      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to
      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code
      // point whose value is 0xFF61 − 0xA1 + byte.
      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {
        eucjp_lead = 0x00;
        return 0xFF61 - 0xA1 + bite;
      }

      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to
      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead
      // to byte, and return continue.
      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {
        eucjp_jis0212_flag = true;
        eucjp_lead = bite;
        return null;
      }

      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set
      // euc-jp lead to 0x00, and run these substeps:
      if (eucjp_lead !== 0x00) {
        var lead = eucjp_lead;
        eucjp_lead = 0x00;

        // 1. Let code point be null.
        var code_point = null;

        // 2. If lead and byte are both in the range 0xA1 to 0xFE,
        // inclusive, set code point to the index code point for (lead
        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp
        // jis0212 flag is unset and in index jis0212 otherwise.
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = indexCodePointFor(
            (lead - 0xA1) * 94 + (bite - 0xA1),
            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));
        }

        // 3. Unset the euc-jp jis0212 flag.
        eucjp_jis0212_flag = false;

        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,
        // prepend byte to stream.
        if (!inRange(bite, 0xA1, 0xFE))
          stream.prepend(bite);

        // 5. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 6. Return a code point whose value is code point.
        return code_point;
      }

      // 6. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,
      // inclusive, set euc-jp lead to byte and return continue.
      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {
        eucjp_lead = bite;
        return null;
      }

      // 8. Return error.
      return decoderError(fatal);
    };
  }

  // 13.1.2 euc-jp encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function EUCJPEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. If code point is U+00A5, return byte 0x5C.
      if (code_point === 0x00A5)
        return 0x5C;

      // 4. If code point is U+203E, return byte 0x7E.
      if (code_point === 0x203E)
        return 0x7E;

      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
      // return two bytes whose values are 0x8E and code point −
      // 0xFF61 + 0xA1.
      if (inRange(code_point, 0xFF61, 0xFF9F))
        return [0x8E, code_point - 0xFF61 + 0xA1];

      // 6. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212)
        code_point = 0xFF0D;

      // 7. Let pointer be the index pointer for code point in index
      // jis0208.
      var pointer = indexPointerFor(code_point, index('jis0208'));

      // 8. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 9. Let lead be floor(pointer / 94) + 0xA1.
      var lead = floor(pointer / 94) + 0xA1;

      // 10. Let trail be pointer % 94 + 0xA1.
      var trail = pointer % 94 + 0xA1;

      // 11. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['EUC-JP'] = function(options) {
    return new EUCJPEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['EUC-JP'] = function(options) {
    return new EUCJPDecoder(options);
  };

  // 13.2 iso-2022-jp

  // 13.2.1 iso-2022-jp decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var states = {
      ASCII: 0,
      Roman: 1,
      Katakana: 2,
      LeadByte: 3,
      TrailByte: 4,
      EscapeStart: 5,
      Escape: 6
    };
    // iso-2022-jp's decoder has an associated iso-2022-jp decoder
    // state (initially ASCII), iso-2022-jp decoder output state
    // (initially ASCII), iso-2022-jp lead (initially 0x00), and
    // iso-2022-jp output flag (initially unset).
    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,
        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,
        /** @type {number} */ iso2022jp_lead = 0x00,
        /** @type {boolean} */ iso2022jp_output_flag = false;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // switching on iso-2022-jp decoder state:
      switch (iso2022jp_decoder_state) {
      default:
      case states.ASCII:
        // ASCII
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B
        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E
            && bite !== 0x0F && bite !== 0x1B) {
          // Unset the iso-2022-jp output flag and return a code point
          // whose value is byte.
          iso2022jp_output_flag = false;
          return bite;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.Roman:
        // Roman
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x5C
        if (bite === 0x5C) {
          // Unset the iso-2022-jp output flag and return code point
          // U+00A5.
          iso2022jp_output_flag = false;
          return 0x00A5;
        }

        // 0x7E
        if (bite === 0x7E) {
          // Unset the iso-2022-jp output flag and return code point
          // U+203E.
          iso2022jp_output_flag = false;
          return 0x203E;
        }

        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E
        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F
            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {
          // Unset the iso-2022-jp output flag and return a code point
          // whose value is byte.
          iso2022jp_output_flag = false;
          return bite;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.Katakana:
        // Katakana
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x21 to 0x5F
        if (inRange(bite, 0x21, 0x5F)) {
          // Unset the iso-2022-jp output flag and return a code point
          // whose value is 0xFF61 − 0x21 + byte.
          iso2022jp_output_flag = false;
          return 0xFF61 - 0x21 + bite;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.LeadByte:
        // Lead byte
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return null;
        }

        // 0x21 to 0x7E
        if (inRange(bite, 0x21, 0x7E)) {
          // Unset the iso-2022-jp output flag, set iso-2022-jp lead
          // to byte, iso-2022-jp decoder state to trail byte, and
          // return continue.
          iso2022jp_output_flag = false;
          iso2022jp_lead = bite;
          iso2022jp_decoder_state = states.TrailByte;
          return null;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Return finished.
          return finished;
        }

        // Otherwise
        // Unset the iso-2022-jp output flag and return error.
        iso2022jp_output_flag = false;
        return decoderError(fatal);

      case states.TrailByte:
        // Trail byte
        // Based on byte:

        // 0x1B
        if (bite === 0x1B) {
          // Set iso-2022-jp decoder state to escape start and return
          // continue.
          iso2022jp_decoder_state = states.EscapeStart;
          return decoderError(fatal);
        }

        // 0x21 to 0x7E
        if (inRange(bite, 0x21, 0x7E)) {
          // 1. Set the iso-2022-jp decoder state to lead byte.
          iso2022jp_decoder_state = states.LeadByte;

          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.
          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;

          // 3. Let code point be the index code point for pointer in
          // index jis0208.
          var code_point = indexCodePointFor(pointer, index('jis0208'));

          // 4. If code point is null, return error.
          if (code_point === null)
            return decoderError(fatal);

          // 5. Return a code point whose value is code point.
          return code_point;
        }

        // end-of-stream
        if (bite === end_of_stream) {
          // Set the iso-2022-jp decoder state to lead byte, prepend
          // byte to stream, and return error.
          iso2022jp_decoder_state = states.LeadByte;
          stream.prepend(bite);
          return decoderError(fatal);
        }

        // Otherwise
        // Set iso-2022-jp decoder state to lead byte and return
        // error.
        iso2022jp_decoder_state = states.LeadByte;
        return decoderError(fatal);

      case states.EscapeStart:
        // Escape start

        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to
        // byte, iso-2022-jp decoder state to escape, and return
        // continue.
        if (bite === 0x24 || bite === 0x28) {
          iso2022jp_lead = bite;
          iso2022jp_decoder_state = states.Escape;
          return null;
        }

        // 2. Prepend byte to stream.
        stream.prepend(bite);

        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp
        // decoder state to iso-2022-jp decoder output state, and
        // return error.
        iso2022jp_output_flag = false;
        iso2022jp_decoder_state = iso2022jp_decoder_output_state;
        return decoderError(fatal);

      case states.Escape:
        // Escape

        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to
        // 0x00.
        var lead = iso2022jp_lead;
        iso2022jp_lead = 0x00;

        // 2. Let state be null.
        var state = null;

        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.
        if (lead === 0x28 && bite === 0x42)
          state = states.ASCII;

        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.
        if (lead === 0x28 && bite === 0x4A)
          state = states.Roman;

        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.
        if (lead === 0x28 && bite === 0x49)
          state = states.Katakana;

        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set
        // state to lead byte.
        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))
          state = states.LeadByte;

        // 7. If state is non-null, run these substeps:
        if (state !== null) {
          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder
          // output state to states.
          iso2022jp_decoder_state = iso2022jp_decoder_state = state;

          // 2. Let output flag be the iso-2022-jp output flag.
          var output_flag = iso2022jp_output_flag;

          // 3. Set the iso-2022-jp output flag.
          iso2022jp_output_flag = true;

          // 4. Return continue, if output flag is unset, and error
          // otherwise.
          return !output_flag ? null : decoderError(fatal);
        }

        // 8. Prepend lead and byte to stream.
        stream.prepend([lead, bite]);

        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp
        // decoder state to iso-2022-jp decoder output state and
        // return error.
        iso2022jp_output_flag = false;
        iso2022jp_decoder_state = iso2022jp_decoder_output_state;
        return decoderError(fatal);
      }
    };
  }

  // 13.2.2 iso-2022-jp encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPEncoder(options) {
    var fatal = options.fatal;
    // iso-2022-jp's encoder has an associated iso-2022-jp encoder
    // state which is one of ASCII, Roman, and jis0208 (initially
    // ASCII).
    /** @enum */
    var states = {
      ASCII: 0,
      Roman: 1,
      jis0208: 2
    };
    var /** @type {number} */ iso2022jp_state = states.ASCII;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream and iso-2022-jp encoder
      // state is not ASCII, prepend code point to stream, set
      // iso-2022-jp encoder state to ASCII, and return three bytes
      // 0x1B 0x28 0x42.
      if (code_point === end_of_stream &&
          iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [0x1B, 0x28, 0x42];
      }

      // 2. If code point is end-of-stream and iso-2022-jp encoder
      // state is ASCII, return finished.
      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)
        return finished;

      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code
      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.
      if ((iso2022jp_state === states.ASCII ||
           iso2022jp_state === states.Roman) &&
          (code_point === 0x000E || code_point === 0x000F ||
           code_point === 0x001B)) {
        return encoderError(0xFFFD);
      }

      // 4. If iso-2022-jp encoder state is ASCII and code point is an
      // ASCII code point, return a byte whose value is code point.
      if (iso2022jp_state === states.ASCII &&
          isASCIICodePoint(code_point))
        return code_point;

      // 5. If iso-2022-jp encoder state is Roman and code point is an
      // ASCII code point, excluding U+005C and U+007E, or is U+00A5
      // or U+203E, run these substeps:
      if (iso2022jp_state === states.Roman &&
          ((isASCIICodePoint(code_point) &&
           code_point !== 0x005C && code_point !== 0x007E) ||
          (code_point == 0x00A5 || code_point == 0x203E))) {

        // 1. If code point is an ASCII code point, return a byte
        // whose value is code point.
        if (isASCIICodePoint(code_point))
          return code_point;

        // 2. If code point is U+00A5, return byte 0x5C.
        if (code_point === 0x00A5)
          return 0x5C;

        // 3. If code point is U+203E, return byte 0x7E.
        if (code_point === 0x203E)
          return 0x7E;
      }

      // 6. If code point is an ASCII code point, and iso-2022-jp
      // encoder state is not ASCII, prepend code point to stream, set
      // iso-2022-jp encoder state to ASCII, and return three bytes
      // 0x1B 0x28 0x42.
      if (isASCIICodePoint(code_point) &&
          iso2022jp_state !== states.ASCII) {
        stream.prepend(code_point);
        iso2022jp_state = states.ASCII;
        return [0x1B, 0x28, 0x42];
      }

      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp
      // encoder state is not Roman, prepend code point to stream, set
      // iso-2022-jp encoder state to Roman, and return three bytes
      // 0x1B 0x28 0x4A.
      if ((code_point === 0x00A5 || code_point === 0x203E) &&
          iso2022jp_state !== states.Roman) {
        stream.prepend(code_point);
        iso2022jp_state = states.Roman;
        return [0x1B, 0x28, 0x4A];
      }

      // 8. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212)
        code_point = 0xFF0D;

      // 9. Let pointer be the index pointer for code point in index
      // jis0208.
      var pointer = indexPointerFor(code_point, index('jis0208'));

      // 10. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 11. If iso-2022-jp encoder state is not jis0208, prepend code
      // point to stream, set iso-2022-jp encoder state to jis0208,
      // and return three bytes 0x1B 0x24 0x42.
      if (iso2022jp_state !== states.jis0208) {
        stream.prepend(code_point);
        iso2022jp_state = states.jis0208;
        return [0x1B, 0x24, 0x42];
      }

      // 12. Let lead be floor(pointer / 94) + 0x21.
      var lead = floor(pointer / 94) + 0x21;

      // 13. Let trail be pointer % 94 + 0x21.
      var trail = pointer % 94 + 0x21;

      // 14. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['ISO-2022-JP'] = function(options) {
    return new ISO2022JPEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['ISO-2022-JP'] = function(options) {
    return new ISO2022JPDecoder(options);
  };

  // 13.3 Shift_JIS

  // 13.3.1 Shift_JIS decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function ShiftJISDecoder(options) {
    var fatal = options.fatal;
    // Shift_JIS's decoder has an associated Shift_JIS lead (initially
    // 0x00).
    var /** @type {number} */ Shift_JIS_lead = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,
      // set Shift_JIS lead to 0x00 and return error.
      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {
        Shift_JIS_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,
      // return finished.
      if (bite === end_of_stream && Shift_JIS_lead === 0x00)
        return finished;

      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,
      // let pointer be null, set Shift_JIS lead to 0x00, and then run
      // these substeps:
      if (Shift_JIS_lead !== 0x00) {
        var lead = Shift_JIS_lead;
        var pointer = null;
        Shift_JIS_lead = 0x00;

        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41
        // otherwise.
        var offset = (bite < 0x7F) ? 0x40 : 0x41;

        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and
        // 0xC1 otherwise.
        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;

        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80
        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×
        // 188 + byte − offset.
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))
          pointer = (lead - lead_offset) * 188 + bite - offset;

        // 4. If pointer is in the range 8836 to 10715, inclusive,
        // return a code point whose value is 0xE000 − 8836 + pointer.
        if (inRange(pointer, 8836, 10715))
          return 0xE000 - 8836 + pointer;

        // 5. Let code point be null, if pointer is null, and the
        // index code point for pointer in index jis0208 otherwise.
        var code_point = (pointer === null) ? null :
              indexCodePointFor(pointer, index('jis0208'));

        // 6. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (code_point === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 7. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 8. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte or 0x80, return a code point
      // whose value is byte.
      if (isASCIIByte(bite) || bite === 0x80)
        return bite;

      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a
      // code point whose value is 0xFF61 − 0xA1 + byte.
      if (inRange(bite, 0xA1, 0xDF))
        return 0xFF61 - 0xA1 + bite;

      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0
      // to 0xFC, inclusive, set Shift_JIS lead to byte and return
      // continue.
      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {
        Shift_JIS_lead = bite;
        return null;
      }

      // 7. Return error.
      return decoderError(fatal);
    };
  }

  // 13.3.2 Shift_JIS encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function ShiftJISEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point or U+0080, return a
      // byte whose value is code point.
      if (isASCIICodePoint(code_point) || code_point === 0x0080)
        return code_point;

      // 3. If code point is U+00A5, return byte 0x5C.
      if (code_point === 0x00A5)
        return 0x5C;

      // 4. If code point is U+203E, return byte 0x7E.
      if (code_point === 0x203E)
        return 0x7E;

      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,
      // return a byte whose value is code point − 0xFF61 + 0xA1.
      if (inRange(code_point, 0xFF61, 0xFF9F))
        return code_point - 0xFF61 + 0xA1;

      // 6. If code point is U+2212, set it to U+FF0D.
      if (code_point === 0x2212)
        code_point = 0xFF0D;

      // 7. Let pointer be the index Shift_JIS pointer for code point.
      var pointer = indexShiftJISPointerFor(code_point);

      // 8. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 9. Let lead be floor(pointer / 188).
      var lead = floor(pointer / 188);

      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and
      // 0xC1 otherwise.
      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;

      // 11. Let trail be pointer % 188.
      var trail = pointer % 188;

      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41
      // otherwise.
      var offset = (trail < 0x3F) ? 0x40 : 0x41;

      // 13. Return two bytes whose values are lead + lead offset and
      // trail + offset.
      return [lead + lead_offset, trail + offset];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['Shift_JIS'] = function(options) {
    return new ShiftJISEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['Shift_JIS'] = function(options) {
    return new ShiftJISDecoder(options);
  };

  //
  // 14. Legacy multi-byte Korean encodings
  //

  // 14.1 euc-kr

  // 14.1.1 euc-kr decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function EUCKRDecoder(options) {
    var fatal = options.fatal;

    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).
    var /** @type {number} */ euckr_lead = 0x00;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set
      // euc-kr lead to 0x00 and return error.
      if (bite === end_of_stream && euckr_lead !== 0) {
        euckr_lead = 0x00;
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return
      // finished.
      if (bite === end_of_stream && euckr_lead === 0)
        return finished;

      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let
      // pointer be null, set euc-kr lead to 0x00, and then run these
      // substeps:
      if (euckr_lead !== 0x00) {
        var lead = euckr_lead;
        var pointer = null;
        euckr_lead = 0x00;

        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set
        // pointer to (lead − 0x81) × 190 + (byte − 0x41).
        if (inRange(bite, 0x41, 0xFE))
          pointer = (lead - 0x81) * 190 + (bite - 0x41);

        // 2. Let code point be null, if pointer is null, and the
        // index code point for pointer in index euc-kr otherwise.
        var code_point = (pointer === null)
              ? null : indexCodePointFor(pointer, index('euc-kr'));

        // 3. If code point is null and byte is an ASCII byte, prepend
        // byte to stream.
        if (pointer === null && isASCIIByte(bite))
          stream.prepend(bite);

        // 4. If code point is null, return error.
        if (code_point === null)
          return decoderError(fatal);

        // 5. Return a code point whose value is code point.
        return code_point;
      }

      // 4. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set
      // euc-kr lead to byte and return continue.
      if (inRange(bite, 0x81, 0xFE)) {
        euckr_lead = bite;
        return null;
      }

      // 6. Return error.
      return decoderError(fatal);
    };
  }

  // 14.1.2 euc-kr encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function EUCKREncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. Let pointer be the index pointer for code point in index
      // euc-kr.
      var pointer = indexPointerFor(code_point, index('euc-kr'));

      // 4. If pointer is null, return error with code point.
      if (pointer === null)
        return encoderError(code_point);

      // 5. Let lead be floor(pointer / 190) + 0x81.
      var lead = floor(pointer / 190) + 0x81;

      // 6. Let trail be pointer % 190 + 0x41.
      var trail = (pointer % 190) + 0x41;

      // 7. Return two bytes whose values are lead and trail.
      return [lead, trail];
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['EUC-KR'] = function(options) {
    return new EUCKREncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['EUC-KR'] = function(options) {
    return new EUCKRDecoder(options);
  };


  //
  // 15. Legacy miscellaneous encodings
  //

  // 15.1 replacement

  // Not needed - API throws RangeError

  // 15.2 Common infrastructure for utf-16be and utf-16le

  /**
   * @param {number} code_unit
   * @param {boolean} utf16be
   * @return {!Array.<number>} bytes
   */
  function convertCodeUnitToBytes(code_unit, utf16be) {
    // 1. Let byte1 be code unit >> 8.
    var byte1 = code_unit >> 8;

    // 2. Let byte2 be code unit & 0x00FF.
    var byte2 = code_unit & 0x00FF;

    // 3. Then return the bytes in order:
        // utf-16be flag is set: byte1, then byte2.
    if (utf16be)
      return [byte1, byte2];
    // utf-16be flag is unset: byte2, then byte1.
    return [byte2, byte1];
  }

  // 15.2.1 shared utf-16 decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.fatal;
    var /** @type {?number} */ utf16_lead_byte = null,
        /** @type {?number} */ utf16_lead_surrogate = null;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream and either utf-16 lead byte or
      // utf-16 lead surrogate is not null, set utf-16 lead byte and
      // utf-16 lead surrogate to null, and return error.
      if (bite === end_of_stream && (utf16_lead_byte !== null ||
                                utf16_lead_surrogate !== null)) {
        return decoderError(fatal);
      }

      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16
      // lead surrogate are null, return finished.
      if (bite === end_of_stream && utf16_lead_byte === null &&
          utf16_lead_surrogate === null) {
        return finished;
      }

      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte
      // and return continue.
      if (utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null;
      }

      // 4. Let code unit be the result of:
      var code_unit;
      if (utf16_be) {
        // utf-16be decoder flag is set
        //   (utf-16 lead byte << 8) + byte.
        code_unit = (utf16_lead_byte << 8) + bite;
      } else {
        // utf-16be decoder flag is unset
        //   (byte << 8) + utf-16 lead byte.
        code_unit = (bite << 8) + utf16_lead_byte;
      }
      // Then set utf-16 lead byte to null.
      utf16_lead_byte = null;

      // 5. If utf-16 lead surrogate is not null, let lead surrogate
      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,
      // and then run these substeps:
      if (utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;

        // 1. If code unit is in the range U+DC00 to U+DFFF,
        // inclusive, return a code point whose value is 0x10000 +
        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).
        if (inRange(code_unit, 0xDC00, 0xDFFF)) {
          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +
              (code_unit - 0xDC00);
        }

        // 2. Prepend the sequence resulting of converting code unit
        // to bytes using utf-16be decoder flag to stream and return
        // error.
        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));
        return decoderError(fatal);
      }

      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,
      // set utf-16 lead surrogate to code unit and return continue.
      if (inRange(code_unit, 0xD800, 0xDBFF)) {
        utf16_lead_surrogate = code_unit;
        return null;
      }

      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,
      // return error.
      if (inRange(code_unit, 0xDC00, 0xDFFF))
        return decoderError(fatal);

      // 8. Return code point code unit.
      return code_unit;
    };
  }

  // 15.2.2 shared utf-16 encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,
      // return the sequence resulting of converting code point to
      // bytes using utf-16be encoder flag.
      if (inRange(code_point, 0x0000, 0xFFFF))
        return convertCodeUnitToBytes(code_point, utf16_be);

      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,
      // converted to bytes using utf-16be encoder flag.
      var lead = convertCodeUnitToBytes(
        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);

      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,
      // converted to bytes using utf-16be encoder flag.
      var trail = convertCodeUnitToBytes(
        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);

      // 5. Return a byte sequence of lead followed by trail.
      return lead.concat(trail);
    };
  }

  // 15.3 utf-16be
  // 15.3.1 utf-16be decoder
  /** @param {{fatal: boolean}} options */
  encoders['UTF-16BE'] = function(options) {
    return new UTF16Encoder(true, options);
  };
  // 15.3.2 utf-16be encoder
  /** @param {{fatal: boolean}} options */
  decoders['UTF-16BE'] = function(options) {
    return new UTF16Decoder(true, options);
  };

  // 15.4 utf-16le
  // 15.4.1 utf-16le decoder
  /** @param {{fatal: boolean}} options */
  encoders['UTF-16LE'] = function(options) {
    return new UTF16Encoder(false, options);
  };
  // 15.4.2 utf-16le encoder
  /** @param {{fatal: boolean}} options */
  decoders['UTF-16LE'] = function(options) {
    return new UTF16Decoder(false, options);
  };

  // 15.5 x-user-defined

  // 15.5.1 x-user-defined decoder
  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */
  function XUserDefinedDecoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */
    this.handler = function(stream, bite) {
      // 1. If byte is end-of-stream, return finished.
      if (bite === end_of_stream)
        return finished;

      // 2. If byte is an ASCII byte, return a code point whose value
      // is byte.
      if (isASCIIByte(bite))
        return bite;

      // 3. Return a code point whose value is 0xF780 + byte − 0x80.
      return 0xF780 + bite - 0x80;
    };
  }

  // 15.5.2 x-user-defined encoder
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */
  function XUserDefinedEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */
    this.handler = function(stream, code_point) {
      // 1.If code point is end-of-stream, return finished.
      if (code_point === end_of_stream)
        return finished;

      // 2. If code point is an ASCII code point, return a byte whose
      // value is code point.
      if (isASCIICodePoint(code_point))
        return code_point;

      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,
      // return a byte whose value is code point − 0xF780 + 0x80.
      if (inRange(code_point, 0xF780, 0xF7FF))
        return code_point - 0xF780 + 0x80;

      // 4. Return error with code point.
      return encoderError(code_point);
    };
  }

  /** @param {{fatal: boolean}} options */
  encoders['x-user-defined'] = function(options) {
    return new XUserDefinedEncoder(options);
  };
  /** @param {{fatal: boolean}} options */
  decoders['x-user-defined'] = function(options) {
    return new XUserDefinedDecoder(options);
  };

  if (!global['TextEncoder'])
    global['TextEncoder'] = TextEncoder;
  if (!global['TextDecoder'])
    global['TextDecoder'] = TextDecoder;

  if (typeof module !== "undefined" && module.exports) {
    module.exports = {
      TextEncoder: global['TextEncoder'],
      TextDecoder: global['TextDecoder'],
      EncodingIndexes: global["encoding-indexes"]
    };
  }
}(this));


;/*
 * Copyright 2010 by Dan Fabulich.
 *
 * Dan Fabulich licenses this file to you under the
 * ChoiceScript License, Version 1.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.choiceofgames.com/LICENSE-1.0.txt
 *
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 */
function Scene(name, stats, nav, options) {
    if (!name) name = "";
    if (!stats) stats = {implicit_control_flow:false};
    if (stats["implicit_control_flow"] === undefined) stats["implicit_control_flow"] = false;
    // the name of the scene
    this.name = name;

    // the permanent statistics and the temporary values
    this.stats = stats;
    // implicit_control_flow controls whether goto is necessary to leave options (true means no)
    // _choiceEnds stores the line numbers to jump to when choice #options end.
    this.temps = {choice_reuse:"allow", choice_user_restored:false, _choiceEnds:{}};

    // the navigator determines which scene comes next
    this.nav = nav;

    options = options || {};

    // should we print debugging information?
    this.debugMode = options.debugMode || false;

    // used for stats screen, and maybe other secondary views someday
    this.secondaryMode = options.secondaryMode;

    this.saveSlot = options.saveSlot || "";

    // the array of lines in the scene file
    this.lines = [];

    // the current line number (WARNING 0-based!)
    this.lineNum = 0;
    this.rollbackLineCoverage();

    // when this is true, the main printLoop will halt
    this.finished = false;

    // map of label names to line numbers
    this.labels = {};

    // the current amount of indentation
    this.indent = 0;

    // Did the previous line contain text?
    this.prevLine = "empty";

    // Have we ever printed any text?
    this.screenEmpty = true;

    // Have we run any commands (except for create and scene_list) yet?
    this.initialCommands = true;

    this.stats.sceneName = name;

    // for easy reachability from the window
    this.stats.scene = this;

    // where should we print text?
    this.target = null;

    this.accumulatedParagraph = [];
}

Scene.prototype.reexecute = function reexecute() {
  this.lineNum = this.stats.testEntryPoint || 0;
  this.finished = 0;
  this.indent = this.getIndent(this.lines[this.lineNum]);
  this.prevLine = "empty";
  this.screenEmpty = true;
  this.execute();
};

// the main loop of the scene
Scene.prototype.printLoop = function printLoop() {
    var line;
    for (;!this.finished && this.lineNum < this.lines.length; this.lineNum++) {
        line = this.lines[this.lineNum];
        if (!trim(line)) {
            this.paragraph();
            continue;
        }
        var indent = this.getIndent(line);
        if (indent > this.indent) {
            // ignore indentation level of *comments
            if (/\s*\*comment\b/.test(line)) continue;
            throw new Error(this.lineMsg() + "increasing indent not allowed, expected " + this.indent + " was " + indent);
        } else if (indent < this.indent) {
            this.dedent(indent);
        }
        // Ability to end a choice #option without goto is guarded by implicit_control_flow variable
        if (this.temps._choiceEnds[this.lineNum] &&
                (this.stats["implicit_control_flow"] || this.temps._fakeChoiceDepth > 0)) {
            // Skip to the end of the choice if we hit the end of an #option
            this.rollbackLineCoverage();
            this.lineNum = this.temps._choiceEnds[this.lineNum];
            this.rollbackLineCoverage();
            if (this.temps._fakeChoiceDepth > 0) {
                this.temps._fakeChoiceDepth--;
            }
            continue;
        }
        this.indent = indent;
        if (/^\s*#/.test(line)) {
            throw new Error(this.lineMsg() + "It is illegal to fall out of a *choice statement; you must *goto or *finish before the end of the indented block.");
        }
        if (!this.runCommand(line)) {
            this.prevLine = "text";
            this.screenEmpty = false;
            this.initialCommands = false;
            this.printLine(line);
        }
    }
    this.rollbackLineCoverage();
    if (!this.finished) {
        this.autofinish();
    }
    this.save("temp");
    if (this.skipFooter) {
        this.skipFooter = false;
    } else {
        printFooter();
    }
};

Scene.prototype.dedent = function dedent(newDent) {};

Scene.prototype.printLine = function printLine(line) {
    if (!line) return null;
    line = this.replaceVariables(line.replace(/^\s*/, ""));
    this.accumulatedParagraph.push(line);
    // insert extra space unless the line ends with hyphen or dash
    if (!/([-\u2011-\u2014]|\[c\/\])$/.test(line)) this.accumulatedParagraph.push(' ');
};

Scene.prototype.replaceVariables = function (line) {
  line = String(line);
  var replacer = /([$@](\!?\!?)\{)/;
  var index = 0;
  var output = [];
  for (var result = replacer.exec(line); result; result = replacer.exec(line.substring(index))) {
    output.push(line.substring(index, index + result.index));
    var curlies = 0;
    var closingCurly = -1;
    var exprStart = index + result.index + result[1].length;
    for (var i = exprStart; i < line.length; i++) {
      var c = line.charAt(i);
      if (c === "{") {
        curlies++;
      } else if (c === "}") {
        if (curlies) {
          curlies--;
        } else {
          closingCurly = i;
          break;
        }
      }
    }
    if (closingCurly == -1) {
      throw new Error(this.lineMsg() + "invalid "+result[0]+"} variable substitution at letter " + (index + result.index + 1));
    }
    var body = line.substring(exprStart, closingCurly);
    var stack, value;
    if (result[0].charAt(0) === "$") {
      stack = this.tokenizeExpr(body);
      value = this.evaluateExpr(stack);
    } else {
      var expr;
      var options;
      if (/^\s*\(/.test(body)) {
        var parens = 0;
        var closingParen = -1;
        for (var i = 1; i < body.length; i++) {
          var c = body.charAt(i);
          if (c === "(") {
            parens++;
          } else if (c === ")") {
            if (parens) {
              parens--;
            } else {
              closingParen = i;
              break;
            }
          }
        }
        if (closingParen == -1) {
          throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; missing closing parenthesis )");
        }
        if (body.charAt(closingParen+1) != " ") {
          throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; there should be a space after the closing parenthesis )");
        }
        expr = body.substring(1, closingParen);
        options = body.substring(closingParen+2).split("|");
      } else {
        if (!/^\S+ /.test(body)) {
          throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; there should be a space after the first word");
        }
        var spaceIndex = body.indexOf(' ');
        expr = body.substring(0, spaceIndex);
        options = body.substring(spaceIndex+1).split("|");
      }
      if (options.length < 2) {
        throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; there should be at least one pipe | to separate options");
      }
      stack = this.tokenizeExpr(expr);
      value = this.evaluateExpr(stack);
      if (typeof value === "boolean" || /^(true|false)$/i.test(value)) {
        value = bool(value) ? 1 : 2;
      }
      value = num(value, this.lineNum+1, this.name);
      if ((value | 0) !== value) {
        throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; '"+expr+"' is equal to " + value + " which is not a whole integer number");
      } else if (value < 1) {
        throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; '"+expr+"' is equal to " + value + " which is not a positive number");
      } else if (value > options.length) {
        throw new Error(this.lineMsg() + "invalid "+result[0]+"} at letter " + (index + result.index + 1) + "; '"+expr+"' is equal to " + value + " but there are only " + options.length + " options");
      }
      value = options[value-1];
      value = this.replaceVariables(value);
    }
    var capitalize = result[2];
    if (capitalize) value = String(value);
    if (capitalize == "!") {
      value = value.charAt(0).toUpperCase() + value.slice(1);
    } else if (capitalize == "!!") {
      value = value.toUpperCase();
    }
    if (typeof highlightGenderPronouns != "undefined" && highlightGenderPronouns && /\b(he|him|his|she|her|hers)\b/gi.test(value)) {
      // this zero-width space will give us a hint for highlighting
      output.push("\u200b");
    }
    output.push(value);
    index = closingCurly+1;
  }
  if (index === 0) return line;
  output.push(line.substring(index));
  return output.join("");
};

Scene.prototype.paragraph = function paragraph() {
    printParagraph(this.accumulatedParagraph.join(""));
    this.accumulatedParagraph = [];
    this.prevLine = "empty";
};

Scene.prototype.loadSceneFast = function loadSceneFast(url) {
    if (this.loading) return;
    this.loading = true;
    var result;
    var self = this;
    if (typeof cachedResults != "undefined" && cachedResults && cachedResults[this.name]) {
      result = window.cachedResults[this.name];
      return safeTimeout(function() {self.loadLinesFast(result.crc, result.lines, result.labels);}, 0);
    } else if (typeof allScenes != "undefined") {
      result = allScenes[this.name];
      if (!result) throw new Error("Couldn't load scene '" + this.name + "'\nThe file doesn't exist.");
      return safeTimeout(function() {self.loadLinesFast(result.crc, result.lines, result.labels);}, 0);
    } else if (typeof window != "undefined" && window.isIosApp && window.isFile && !window.isOmnibusApp) {
      startLoading();
      var startedWaiting = new Date().getTime();

      function retryScenes(event, command) {
        if (!command) command = "retryscenes";
        clearScreen(function() {
          startLoading();
          if (command == "retryscenes") curl();
          window.downloadState = null;
          callIos(command);
          startedWaiting = new Date().getTime();
          awaitAllScenes();
        });
      }

      function awaitAllScenes() {
        if (typeof allScenes != "undefined") {
          result = allScenes[self.name];
          if (!result) throw new Error("Couldn't load scene '" + self.name + "'\nThe file doesn't exist.");
          self.loadLinesFast(result.crc, result.lines, result.labels);
        } else if (window.downloadState == "failed" || (new Date().getTime() - startedWaiting) > 5000) {
          doneLoading();
          if (window.downloadRequired) {
            self.printLine("We weren't able to download the latest version of the game.");
            self.paragraph();
            printButton("Try Again", main, false, retryScenes);
          } else {
            self.printLine("We weren't able to download the latest version of the game. Please try downloading again. The latest version may contain important fixes.");
            self.paragraph();
            var retry = {name: "Try downloading again."};
            var ignore = {name: "Continue playing without the latest version."}
            printOptions([""], [retry, ignore], function(option) {
              if (option == retry) {
                retryScenes();
              } else {
                retryScenes(null, "requestscenesforce");
              }
            });
          }
        } else {
          setTimeout(awaitAllScenes, 0);
        }
      }
      return awaitAllScenes();
    } else if (window.purchases[self.name] && isStoreSceneCacheRequired()) {
      var sceneName = this.name.replace(/ /g, "_");
      return window.store.get("cache_scene_hash_"+sceneName, function(ok, hash) {
        function keepScene(result) {
          if (!window.cachedResults) window.cachedResults = {};
          cachedResults[self.name] = result;
          self.loadLinesFast(result.crc, result.lines, result.labels);
        }
        function loadPaidScene() {
          startLoading();
          updateSinglePaidSceneCache(self.name, function(err, result) {
            doneLoading();
            if (err) {
              if (err === "not registered") {
                logout();
                loginDiv();
                return clearScreen(function() {
                  loginForm(main, 0/*optional*/,
                    "Please sign in to access this part of the game.", function() {
                      clearScreen(loadAndRestoreGame);
                    });
                });
              } else if (err === "not purchased") {
                window.rerestore = function () {
                  restorePurchases(window.purchases[self.name], function (purchased) {
                    window.location.reload(); 
                  });
                };
                main.innerHTML = "<div id='text'><p>Our apologies; we were unable to access your purchase while loading game data. (Error 403x)" +
                  "  Please restore purchases now; if that doesn't work, please email " + getSupportEmail() + " with details, including the error number 403x.</p>" +
                  " <p><button class='next' onclick='window.rerestore();'>Restore Now</button></p></div>";
                curl();
                return;
              }
              main.innerHTML = "<div id='text'><p>Our apologies; there was a " + err + " error while loading game data."+
              "  Please refresh now; if that doesn't work, please click the Restart button and email "+getSupportEmail()+" with details, including the error number.</p>"+
              " <p><button class='next' onclick='window.location.reload();'>Refresh Now</button></p></div>";
              curl();
            } else {
              keepScene(result);
            }
          })
        }
        if (ok && hash == hashes.scenes[sceneName + ".txt.json"]) {
          window.store.get("cache_scene_"+sceneName, function(ok, text) {
            if (ok && text) {
              var parsed;
              try {
                parsed = jsonParse(text);
              } catch (e) {
                if (window.console) console.error(e, e.stack);
              }
              if (parsed && parsed.crc && parsed.lines && parsed.labels) return keepScene(parsed);
              loadPaidScene();
            } else {
              loadPaidScene();
            }
          })
        } else {
          loadPaidScene();
        }
      });
    }
    startLoading();
    if (!url) {
        var fileName = this.name.replace(/ /g, "_") + ".txt.json";
        url = Scene.baseUrl + "/" + fileName;
        if (window.location.protocol == "https:" && window.hashes && window.hashes.scenes[fileName]) {
          url += "?hash="+hashes.scenes[fileName];
        }
    }
    var xhr = findXhr();
    xhr.open("GET", url, true);
    var self = this;
    var done = false;
    xhr.onreadystatechange = function() {
        if (done) return;
        if (xhr.readyState != 4) return;
        if (xhr.status == 403) {
          try {
            var err = JSON.parse(xhr.responseText);
            if (err.error == "not registered") {
              return isRegistered(function(registered) {
                if (registered) {
                  logout();
                  loginDiv();
                }
                return clearScreen(function() {
                  loginForm(main, 0/*optional*/,
                    "Please sign in to access this part of the game.", function() {
                      clearScreen(loadAndRestoreGame);
                    });
                });
              });
            }
          } catch (e) {} // JSON parse failure? must not be a login prompt
        }
        done = true;

        var result;
        try {
          result = jsonParse(xhr.responseText);
        } catch (e) {
          if (window.console) console.error(e, e.stack);
        }
        if (window.isWeb && (xhr.status != 200 || !result)) {
          doneLoading();
          var status = xhr.status;
          if (status == 200 || !status) status = "network";
          main.innerHTML = "<div id='text'><p>Our apologies; there was a " + status + " error while loading game data."+
          "  Please refresh your browser now; if that doesn't work, please click the Restart button and email "+getSupportEmail()+" with details.</p>"+
          " <p><button onclick='window.location.reload();'>Refresh Now</button></p></div>";
          curl();
          return;
        } else if (xhr.responseText === "") {
          throw new Error("Couldn't load " + url + "\nThe file is probably missing or empty.");
        }

        if (!window.cachedResults) window.cachedResults = {};
        cachedResults[self.name] = result;
        self.loadLinesFast(result.crc, result.lines, result.labels);
    };
    if (isIE) {
      // IE8 swallows errors in onreadystatechange if xhr.send is in a try block
      xhr.send(null);
    } else {
      try {
        xhr.send(null);
      } catch (e) {
        if (window.location.protocol == "file:" && !window.isMobile) {
          if (/Chrome/.test(navigator.userAgent)) {
            window.onerror("We're sorry, Google Chrome has blocked ChoiceScript from functioning.  (\"file:\" URLs cannot "+
            "load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like "+
            "choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.");
            return;
          }
        }
        window.onerror("Couldn't load URL: " + url + "\n" + e);
      }
    }
};

Scene.prototype.loadLinesFast = function loadLinesFast(crc, lines, labels) {
  this.crc = crc;
  this.lines = lines;
  this.labels = labels;
  this.loading = false;
  this.loaded = true;
  var self = this;
  if (this.executing) {
    safeCall(this, function() {
      doneLoading();
      self.execute();
    });
  }
};

// load the scene file from the specified URL (or from default URL by name)
Scene.prototype.loadScene = function loadScene() {
    if (this.loading) return;
    this.loading = true;
    if (window.isFile) return this.loadFile();
    startLoading();
    var url = Scene.baseUrl + "/" + this.name + ".txt";
    var xhr = findXhr();
    xhr.open("GET", url, true);
    var self = this;
    var done = false;
    xhr.onreadystatechange = function() {
        if (done) return;
        if (xhr.readyState != 4) return;
        done = true;
        if (xhr.status == 403) {
          try {
            var err = JSON.parse(xhr.responseText);
            if (err.error == "not registered") {
              return isRegistered(function(registered) {
                if (registered) {
                  logout();
                  loginDiv();
                }
                return clearScreen(function() {
                  loginForm(main, 0/*optional*/,
                    "Please sign in to access this part of the game.", function() {
                      clearScreen(loadAndRestoreGame);
                    });
                });
              });
            }
          } catch (e) {} // JSON parse failure? must not be a login prompt
        }
        if (window.isWeb && xhr.status != 200) {
            var status = xhr.status || "network";
            main.innerHTML = "<p>Our apologies; there was a " + status + " error while loading game data."+
            "  Please refresh your browser now; if that doesn't work, please email "+getSupportEmail()+" with details.</p>"+
            " <p><button onclick='window.location.reload();'>Refresh Now</button></p>";
            return;
        } else if (xhr.responseText === "") {
          if (window.location.protocol == "file:" && !window.isMobile && /Chrome/.test(navigator.userAgent)) {
            window.onerror("We're sorry, Google Chrome has blocked ChoiceScript from functioning.  (\"file:\" URLs cannot "+
            "load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like "+
            "choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.");
            return;
          } else {
            window.onerror("Couldn't load " + url + "\nThe file is probably missing or empty.");
            return;
          }
        }
        var result = xhr.responseText;
        scene = result;
        scene = scene.replace(/\r/g, "");
        this.loading = false;
        self.loadLines(scene);
        if (self.executing) {
            safeCall(self, function () {
              doneLoading();
              self.execute();
            });
        }
    };
    if (isIE) {
      // IE8 swallows errors in onreadystatechange if xhr.send is in a try block
      xhr.send(null);
    } else {
      try {
        xhr.send(null);
      } catch (e) {
        if (window.location.protocol == "file:" && !window.isMobile) {
          if (/Chrome/.test(navigator.userAgent)) {
            window.onerror("We're sorry, Google Chrome has blocked ChoiceScript from functioning.  (\"file:\" URLs cannot "+
            "load files in Chrome.)  ChoiceScript works just fine in Chrome, but only on a published website like "+
            "choiceofgames.com.  For the time being, please try another browser like Mozilla Firefox.");
            return;
          } else if (e.code === 1012 /*NS_ERROR_DOM_BAD_URI*/) {
            window.onerror("Couldn't load scene file: " + url + "\nThe file is probably missing.");
            return;
          }
        }
        window.onerror("Couldn't load URL: " + url + "\n" + e);
      }
    }
};

Scene.prototype.loadFile = function loadFile() {
  var _this = this;
  if (typeof uploadedFiles !== "object") {
    clearScreen(function() {
      var header = document.getElementById('header');
      if (header) header.style.display = "none";
      var makeYourOwnGames = document.getElementById('makeyourowngames');
      if (makeYourOwnGames) makeYourOwnGames.style.display = "none";
      _this.printLine("[b]Please \"Upload\" ChoiceScript[/b]");
      _this.paragraph();
      _this.printLine("To begin, you'll need to grant permission to \"upload\" your choicescript folder containing index.html.")
      _this.paragraph();
      _this.printLine("Use the button below to select your choicescript folder.");
      _this.paragraph();
      var text = document.getElementById('text');
      var input = document.createElement('input');
      input.type = 'file';
      input.webkitdirectory = true;
      input.multiple = true;
      input.addEventListener('change', function searchForStartup(e) {
        var numFiles = input.files.length;
        var startupCandidates = [];
        for (var i = 0; i < numFiles; i++) {
          var file = input.files[i];
          if (file.name === "startup.txt") {
            startupCandidates.push(file);
          }
        }
        if (!startupCandidates.length) {
          return clearScreen(function() {
            _this.printLine("We couldn't find startup.txt in the folder you chose. Please try again.")
            _this.paragraph();
            document.getElementById('text').appendChild(input);
            curl();
          });
        }

        if (startupCandidates.length > 1) {
          return clearScreen(function() {
            _this.printLine("There were multiple files called startup.txt in the folder you chose. Please try again.");
            _this.paragraph();
            for (var i = 0; i < startupCandidates.length; i++) {
              _this.printLine("\u2022 " + startupCandidates[i].webkitRelativePath);
            }
            _this.paragraph();
            document.getElementById('text').appendChild(input);
            curl();
          });
        }

        var startup = startupCandidates[0];
        var rootDirTest = new RegExp("^" + startup.webkitRelativePath.replace(/\/startup.txt$/, "/[^/]+$"));
        var sceneFiles = {};
        for (var i = 0; i < numFiles; i++) {
          var file = input.files[i];
          if (rootDirTest.test(file.webkitRelativePath)) {
            sceneFiles[file.name] = file;
          }
        }
        window.uploadedFiles = sceneFiles;
        if (header) header.style.display = "";
        if (makeYourOwnGames) makeYourOwnGames.style.display = "";
        clearScreen(function() {
          _this.loadFile();
        });
      });
      text.appendChild(input);
      _this.paragraph();
      _this.printLine("(We're not actually going to transfer your code over the Internet, " +
        "but this web page needs permission to upload your choicescript folder in order to access " +
        "your code and run it. The power to access your code would also grant us the power to " +
        "transfer your code elsewhere, but we're not going to do that. JavaScript programmers " +
        "can read our JavaScript to verify that this is true.)");
      _this.paragraph();
      curl();
    });
  } else {
    var fileName = this.name + ".txt";
    if (uploadedFiles[fileName]) {
      startLoading();
      new Response(uploadedFiles[fileName]).text().then(function(result) {
        scene = result;
        scene = scene.replace(/\r/g, "");
        _this.loading = false;
        safeCall(_this, function() {
          _this.loadLines(scene);
          doneLoading();
          _this.execute();
        });
      });
    } else {
      for (var otherFileName in uploadedFiles) {
        if (fileName.toLowerCase() === otherFileName.toLowerCase()) {
          main.innerHTML = "<p>Couldn't find "+fileName+" in the uploaded folder, but we did find "+otherFileName+". Scene file names must match exactly, including capitalization.</p>"+
          " <p><button onclick='window.location.reload();'>Refresh Now</button></p>";
          curl();
          return;
        }
      }
      main.innerHTML = "<p>Couldn't find "+fileName+" in the uploaded folder.</p>"+
        " <p><button onclick='window.location.reload();'>Refresh Now</button></p>";
      curl();
    }
  }
}

Scene.prototype.checkSum = function checkSum() {
  if (this.temps.choice_crc) {
    if (!this.randomtest && !this.quicktest && this.temps.choice_crc != this.crc && this.lineNum) {
      // The scene has changed; restart the scene from backup
      if (typeof alertify !== 'undefined') {
        if (!initStore()) {
          alertify.log(this.name + ".txt has updated. Restarting chapter.");
        } else {
          alertify.log("The game has updated. Restarting chapter.");
        }
      }
      var self = this;
      safeTimeout(function () {
        clearScreen(function () {
          loadAndRestoreGame("backup");
        });
      }, 0);
      return false;
    }
  }
  this.temps.choice_crc = this.crc;
  return true;
};

Scene.prototype.loadLines = function loadLines(str) {
    this.crc = crc32(str);
    this.lines = str.split(/\r?\n/);
    this.parseLabels();
    this.loaded = true;
};

// launch the vignette as soon as it's available
Scene.prototype.execute = function execute() {
    if (!this.loaded) {
        this.executing = true;
        if (Scene.generatedFast || (typeof generatedFast != "undefined" && generatedFast) || typeof allScenes != 'undefined') {
          this.loadSceneFast();
        } else {
          this.loadScene();
        }
        return;
    }
    if (!this.checkSum()) {
      return;
    }
    if (this.nav) this.nav.repairStats(stats);
    if (!this.temps._choiceEnds) this.temps._choiceEnds = {};
    doneLoading();
    if (typeof this.targetLabel != "undefined") {
      var label = this.targetLabel.label.toLowerCase();
      if (typeof(this.labels[label]) != "undefined") {
          this.lineNum = this.labels[label];
          this.indent = this.getIndent(this.lines[this.lineNum]);
          delete this.targetLabel;
      } else {
          throw new Error(this.targetLabel.origin + " line " + (this.targetLabel.originLine+1) + ": "+this.name+" doesn't contain label " + label);
      }
    }
    // this backup slot will only be used when the scene crc changes during upgrades
    if (!this.lineNum) {
      var subsceneStack = this.stats.choice_subscene_stack || [];
      if (!subsceneStack.length) this.save("backup");
    }
    if (this.redirectingFromStats) {
      this.save("");
      delete this.redirectingFromStats;
    }
    this.printLoop();
};

// loop through the file looking for *label commands
Scene.prototype.parseLabels = function parseLabels() {
    var lineLength = this.lines.length;
    var oldLineNum = this.lineNum;
    var screenshots = ("choicescript_screenshots" == this.name);
    var seenChoiceWithoutSet = 0;
    for (this.lineNum = 0; this.lineNum < lineLength; this.lineNum++) {
        this.rollbackLineCoverage();
        var line = this.lines[this.lineNum];
        // strip byte order mark
        if (this.lineNum == 0 && line.charCodeAt(0) == 65279) lines[0] = line.substring(1);
        var invalidCharacter = line.match(/^(.*)\ufffd/);
        if (invalidCharacter) throw new Error(this.lineMsg() + "invalid character. (ChoiceScript text should be saved in the UTF-8 encoding.) " + invalidCharacter[0]);
        var result = /^(\s*)\*(\w+)(.*)/.exec(line);
        if (!result) continue;
        var indentation = result[1];
        var indent = indentation.length;
        var command = result[2].toLowerCase();
        var data = trim(result[3]);
        if ("label" == command) {
            data = data.toLowerCase();
            if (/\s/.test(data)) throw new Error(this.lineMsg() + "label '"+data+"' is not allowed to contain spaces");
            if (this.labels.hasOwnProperty(data)) {
              throw new Error(this.lineMsg() + "label '"+data+"' already defined on line " + (this.labels[data]*1+1));
            }
            this.labels[data] = this.lineNum;
        } else if (screenshots) {
          if ("fake_choice" == command) {
            if (seenChoiceWithoutSet) throw new Error(this.lineMsg() +
              "In choicescript_screenshots, you need to *set at least one variable between *fake_choice commands, so the stat screen looks interesting. " +
              "There was no *set since the last *fake_choice on line " + seenChoiceWithoutSet + ".");
            seenChoiceWithoutSet = this.lineNum+1;
          } else if ("set" == command) {
            seenChoiceWithoutSet = 0;
          }
        }
    }
    this.rollbackLineCoverage();
    this.lineNum = oldLineNum;
};

// if this is a command line, run it
Scene.prototype.runCommand = function runCommand(line) {
    var result = /^\s*\*(\w+)(.*)/.exec(line);
    if (!result) {
      if (this.secondaryMode == "startup" && this.startupCallback) {
        this.finished = true;
        this.skipFooter = true;
        this.startupCallback();
        return true;
      }
      return false;
    }
    var command = result[1].toLowerCase();
    var data = trim(result[2]);
    if (Scene.validCommands[command]) {
        if ("comment" == command) return true;
        if (Scene.initialCommands[command]) {
          if ("startup" != String(this.name).toLowerCase() || !this.initialCommands) {
            throw new Error(this.lineMsg() + "Invalid "+command+" instruction, only allowed at the top of startup.txt");
          }
        } else {
          if (this.secondaryMode == "startup" && this.startupCallback) {
            this.finished = true;
            this.skipFooter = true;
            this.startupCallback();
            return true;
          }
          this.initialCommands = false;
        }
        if (command == "choice" && String(this.name).toLowerCase() == "choicescript_screenshots") {
          throw new Error(this.lineMsg() + "choicescript_screenshots files should only contain *fake_choice commands, not real *choice commands");
        }
        this[command](data);
    } else {
        throw new Error(this.lineMsg() + "Non-existent command '"+command+"'");
    }
    return true;
};

// *choice [group1] [group2] ...
// prompt the user with a multiple choice question.
// nested lines are options to be presented to the user
//
// Examples:
// *choice
//    good
//      Good choice
//      *finish
//    bad
//      Bad choice
//      *finish
//
// *choice toy
//    spaceship
//      Nice spaceship
//      *finish
//    train
//      Nice train
//      *finish
//    doll
//      Nice doll
//      *finish
//
// *choice color toy
//    red
//      spaceship
//        Nice red spaceship
//        *finish
//      train
//        Nice red train
//        *finish
//    blue
//       spaceship
//         Nice blue spaceship
//        *finish
//       train
//         Nice red train
//        *finish

// If a group is specified, generate a prompt message, e.g. "*choice toy" -> "Select a toy:"
// If no group is specified, don't generate a prompt message
// if multiple groups are specified, allow the user to make multiple choices simultaneously
//   all multi-dimensional choices must be valid (otherwise throw a parse error)
Scene.prototype.choice = function choice(data) {
    var startLineNum = this.lineNum;
    var groups = data.split(/ /);
    for (var i = 0; i < groups.length; i++) {
      if (!/^\w*$/.test(groups[i])) {
        throw new Error(this.lineMsg() + "invalid choice group name: " + groups[i]);
      }
    }
    var options = this.parseOptions(this.indent, groups);
    var self = this;
    this.renderOptions(groups, options, function(option) {
      self.standardResolution(option);
    });
    this.finished = true;
    if (this.temps._fakeChoiceDepth > 0 || this.stats["implicit_control_flow"]) {
      if (!this.temps._choiceEnds) {
        this.temps._choiceEnds = {};
      }
      for (i = 0; i < options.length; i++) {
        this.temps._choiceEnds[options[i].line-1] = this.lineNum;
      }
    }
    this.lineNum = startLineNum;
};

Scene.prototype.fake_choice = function fake_choice(data) {
    if (this.temps._fakeChoiceDepth === undefined) {
        this.temps._fakeChoiceDepth = 0;
    }
    this.temps._fakeChoiceDepth++;
    this.choice(data);
};

Scene.prototype.standardResolution = function(option) {
  var self = this;
  self.lineNum = option.line;
  self.indent = self.getIndent(self.nextNonBlankLine(true/*includingThisOne*/));
  if (option.reuse && option.reuse != "allow") self.temps.choice_used[option.line-1] = 1;
  if (this.nav) this.nav.bugLog.push("#"+(option.line+1) + " " + option.name);

  self.finished = false;
  self.resetPage();
};

Scene.prototype.nextNonBlankLine = function nextNonBlankLine(includingThisOne) {
    var line;
    var i = this.lineNum;
    if (!includingThisOne) i++;
    while(isDefined(line = this.lines[i]) && !trim(line)) {
      i++;
    }
    return line;
};

Scene.prototype.previousNonBlankLineNum = function previousNonBlankLineNum() {
  var line;
  var i = this.lineNum - 1;
  while(isDefined(line = this.lines[i]) && !trim(line)) {
    i--;
  }
  return i;
};


Scene.prototype.resetCheckedPurchases = function resetCheckedPurchases() {
  for (var temp in this.temps) {
    if (/^choice_purchased/.test(temp)) {
      delete this.temps[temp];
    }
  }
};

// reset the page and invoke code after clearing the screen
Scene.prototype.resetPage = function resetPage() {
    var self = this;
    this.resetCheckedPurchases();
    clearScreen(function() {
      // save in the background, eventually
      self.save("");
      self.prevLine = "empty";
      self.screenEmpty = true;
      self.execute();
    });
};

/* The function needs some explaining.
We want the game to be "refreshable," e.g. on the web.
So we only make a "real" autosave as you click "Next"
But if we do it that way, when we visit the stat screen, it's out of date
So we make a "temp" autosave slot, right as the page finishes redrawing,
and the stat screen uses the "temp" autosave to display your current data.
When you refresh the page, the "temp" autosave is rewritten.

If you save stats on the stat screen, they're written into tempStatWrites;
when the stat screen saves, we transfer tempStatWrites back to the main
game (if the main game is running in a separate iframe, e.g. iOS).

If the main game is about to write the main "" slot, we merge the temp
stat writes into the main stats (and clear the stat writes) before
saving.

Thus, stat changes on the stat screen will only be permanently saved when
the player clicks "Next" in the main game, ensuring that the game is still
refreshable.
*/
Scene.prototype.save = function save(slot) {
    if (this.saveSlot) {
      transferTempStatWrites();
    } else {
      if (!slot) {
        slot = "";
        for (var key in tempStatWrites) {
          if (tempStatWrites.hasOwnProperty(key)) {
            this.stats[key] = tempStatWrites[key];
          }
        }
        tempStatWrites = {};
      }

      saveCookie(function() {}, slot, this.stats, this.temps, this.lineNum, this.indent, this.debugMode, this.nav);
    }
};

// *goto labelName
// Go to the line labeled with the label command *label labelName
//
// goto by reference
//   *create foo "labelName"
//   *goto {foo}
Scene.prototype["goto"] = function scene_goto(line) {
    var label;
    if (/[\[\{]/.test(line)) {
      label = this.evaluateReference(this.tokenizeExpr(line));
    } else {
      label = String(line).toLowerCase();
    }
    if (typeof(this.labels[label]) != "undefined") {
        this.lineNum = this.labels[label];
        this.indent = this.getIndent(this.lines[this.lineNum]);
    } else {
        throw new Error(this.lineMsg() + "bad label " + label);
    }
    if (!this.localCoverage) this.localCoverage = {};
    if (this.localCoverage[this.lineNum]) {
        this.localCoverage[this.lineNum]++;
        if (this.looplimit_count && this.localCoverage[this.lineNum] > this.looplimit_count) {
            throw new Error(this.lineMsg() + "visited this line too many times (" + this.looplimit_count + ")");
        }
    } else {
        this.localCoverage[this.lineNum] = 1;
    }
};

Scene.prototype.gosub = function scene_gosub(data) {
    var label = /\S+/.exec(data)[0];
    var rest = data.substring(label.length+1);
    var args = [];
    var stack = this.tokenizeExpr(rest);
    while (stack.length) {
      args.push(this.evaluateValueToken(stack.shift(), stack));
    }
    if (!this.temps.choice_substack) {
      this.temps.choice_substack = [];
    }
    this.temps.choice_substack.push({lineNum: this.lineNum, indent: this.indent});
    // Works exactly the same as gosub_scene, putting args in this.temps.param.
    // This means there's no notion of scope - param acts more like "registers" that
    // get clobbered the next time a sub is called.
    // This may be more intuitive to non-programmers than idea of scope?  Especially
    // if temp normally doesn't follow scoping rules.  gosub_scene can serve this function anyway.
    // The params can be retrieved and put in named temps with "params" command.
    this.temps.param = args;
    this["goto"](label);
};

Scene.prototype.gosub_scene = function scene_gosub_scene(data) {
    if (!this.stats.choice_subscene_stack) {
      this.stats.choice_subscene_stack = [];
    }
    this.stats.choice_subscene_stack.push({name:this.name, lineNum: this.lineNum + 1, indent: this.indent, temps: this.temps});
    this.goto_scene(data);
};

Scene.prototype.params = function scene_params(data) {
    // Name the parameters passed by gosub/gosub_scene.
    // Rules should be the same as for "create."
    // All parameters, even those not named, exposed as param_1, param_2 etc.
    var words = /\w+/.exec(data);
    var nextParamNum = 1;
    this.temps.param_count = this.temps.param.length;
    while (words) {
        var varName = words[0];
        this.validateVariable(varName);
        if (this.temps.param.length < 1) {
            throw new Error(this.lineMsg() + "No parameter passed for " + varName);
        }
        var paramVal = this.temps.param.shift();
        this.temps[varName] = paramVal;
        this.temps["param_" + nextParamNum] = paramVal;
        nextParamNum++;
        data = data.substring(varName.length+1);
        words = /\w+/.exec(data);
    }
    // All remaining params are anonymous, but you still have to say "params"
    // if you want any of them.
    while (this.temps.param.length > 0) {
        var paramVal = this.temps.param.shift();
        this.temps["param_" + nextParamNum] = paramVal;
        nextParamNum++;
    }
};

Scene.prototype["return"] = function scene_return() {
    var stackFrame;
    if (this.temps.choice_substack && this.temps.choice_substack.length) {
      stackFrame = this.temps.choice_substack.pop();
      this.lineNum = stackFrame.lineNum;
      this.indent = stackFrame.indent;
    } else if (this.stats.choice_subscene_stack && this.stats.choice_subscene_stack.length) {
      stackFrame = this.stats.choice_subscene_stack.pop();
      if (stackFrame.name == this.name) {
        this.temps = stackFrame.temps;
        this.lineNum = stackFrame.lineNum-1;
        this.indent = stackFrame.indent;
        return;
      }
      this.finished = true;
      this.skipFooter = true;
      var scene = new Scene(stackFrame.name, this.stats, this.nav, {debugMode:this.debugMode, secondaryMode:this.secondaryMode, saveSlot:this.saveSlot});
      scene.temps = stackFrame.temps;
      scene.screenEmpty = this.screenEmpty;
      scene.prevLine = this.prevLine;
      scene.lineNum = stackFrame.lineNum;
      scene.indent = stackFrame.indent;
      scene.accumulatedParagraph = this.accumulatedParagraph;
      if (this.randomtest) {
        // pop the stack in randomtest to avoid overflow
        clearScreen(function() {scene.execute()});
      } else {
        scene.execute();
      }
    } else if (!this.temps.choice_substack && !this.stats.choice_subscene_stack) {
      throw new Error(this.lineMsg() + "invalid return; gosub has not yet been called");
    } else {
      throw new Error(this.lineMsg() + "invalid return; we've already returned from the last gosub");
    }

};

// *gotoref expression
// Go to the label identified by the expression
//
// *temp foo
// *set foo "bar"
// *gotoref foo
// Skipped!
// *label bar
Scene.prototype["gotoref"] = function scene_gotoref(expression) {
    var stack = this.tokenizeExpr(expression);
    var value = this.evaluateExpr(stack);
    this["goto"](value);
};


// *finish
// halt the scene
Scene.prototype.finish = function finish(buttonName) {
    this.paragraph();
    this.finished = true;
    var self = this;
    if (this.secondaryMode == "stats") {
      if (typeof window == "undefined") return;
      if (window.forcedScene == "choicescript_stats") return;
      if (window.isAndroidApp && window.statsMode.get()) return;

      if (this.screenEmpty) {
        clearScreen(loadAndRestoreGame);
        return;
      }
      if (!buttonName) buttonName = "Next";
      buttonName = this.replaceVariables(buttonName);
      printButton(buttonName, main, false,
        function() {
          clearScreen(loadAndRestoreGame);
        }
      );
      return;
    }
    var nextSceneName = this.nav && nav.nextSceneName(this.name);
    // if there are no more scenes, then just halt
    if (!nextSceneName) {
        if (!this.secondaryMode) this.ending();
        return;
    }
    if (this.screenEmpty) {
      this.goto_scene(nextSceneName);
      return;
    }
    if (!buttonName) buttonName = "Next Chapter";
    buttonName = this.replaceVariables(buttonName);


    printButton(buttonName, main, false,
      function() {
        safeCall(self, function() {
            var scene = new Scene(nextSceneName, self.stats, self.nav, {debugMode:self.debugMode, secondaryMode:self.secondaryMode});
            scene.resetPage();
        });
      }
    );
    if (this.debugMode) println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));
};

Scene.prototype.autofinish = function autofinish(buttonName) {
  this.finish(buttonName);
};

// *reset
// clear all stats
Scene.prototype.reset = function reset() {
    this.nav.resetStats(this.stats);
    this.stats.scene = this;
};

Scene.prototype.parseGotoScene = function parseGotoScene(data) {
  var sceneName, label, param = [], stack;

  if (/[\[\{]/.test(data)) {
    stack = this.tokenizeExpr(data);
    sceneName = this.evaluateReference(stack, {toLowerCase: false});
    // Labels are required for arguments to avoid ambiguity
    if (stack.length) {
      label = this.evaluateReference(stack);
    }
    while (stack.length) {
      // Arguments when treating gosub_scene like a function call
      param.push(this.evaluateValueToken(stack.shift(), stack));
    }
  } else {
    // scenes and labels can contain hyphens and other non-expression punctuation
    // so we'll try to extract the first two words as the scene and label
    var match = /(\S+)\s+(\S+)\s*(.*)/.exec(data);
    if (match) {
      sceneName = match[1];
      label = match[2];
      stack = this.tokenizeExpr(match[3]);
      while (stack.length) {
        // Arguments when treating gosub_scene like a function call
        param.push(this.evaluateValueToken(stack.shift(), stack));
      }
    } else {
      if (data === "") throw new Error(this.lineMsg() + "missing scene name");
      sceneName = data;
    }
  }
  return {sceneName:sceneName, label:label, param:param};
};

// *goto_scene foo
//
Scene.prototype.goto_scene = function gotoScene(data) {
    var result = this.parseGotoScene(data);

    if (result.sceneName == this.name) {
      if (typeof result.label === "undefined") {
        this.lineNum = -1; // the printLoop will increment the line number to 0
      } else {
        this["goto"](result.label);
      }
      this.temps = {choice_reuse:"allow", choice_user_restored:false, _choiceEnds:{}};
      this.temps.param = result.param;
      this.initialCommands = true;
      return;
    }

    this.finished = true;
    this.skipFooter = true;
    var scene = new Scene(result.sceneName, this.stats, this.nav, {debugMode:this.debugMode, secondaryMode:this.secondaryMode, saveSlot:this.saveSlot});
    scene.screenEmpty = this.screenEmpty;
    scene.prevLine = this.prevLine;
    scene.accumulatedParagraph = this.accumulatedParagraph;
    if (typeof result.label != "undefined") scene.targetLabel = {label:result.label, origin:this.name, originLine:this.lineNum};
    if (typeof result.param != "undefined") scene.temps.param = result.param;
    if (this.redirectingFromStats) scene.redirectingFromStats = true;
    scene.execute();
};

// *redirect_scene foo
Scene.prototype.redirect_scene = function redirectScene(data) {
  if (this.secondaryMode != "stats") throw new Error(this.lineMsg() + "The *redirect_scene command can only be used from the stats screen.");
  var result = this.parseGotoScene(data);
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  redirectFromStats(result.sceneName, result.label, this.lineNum, function() {
    delete self.secondaryMode;
    delete self.saveSlot;
    self.redirectingFromStats = true;
    self.goto_scene(data);
  });
};

Scene.prototype.product = function product(productId) {
  if (!/^[a-z]+$/.test(productId)) throw new Error(this.lineMsg()+"Invalid product id: " +productId);
  if (this.nav) this.nav.products[productId] = {};
}

Scene.prototype.restore_purchases = function scene_restorePurchases(data) {
  var self = this;
  var target = this.target;
  if (!target) target = document.getElementById('text');
  var button = printButton("Restore Purchases", target, false,
    function() {
      safeCall(self, function() {
          restorePurchases(null, function() {
            self["goto"](data);
            self.finished = false;
            self.resetPage();
          });
      });
    }
  );

  setClass(button, "");
  this.prevLine = "block";
};

Scene.prototype.check_purchase = function scene_checkPurchase(data) {
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  var productList = data.split(/ /);
  for (var i = 0; i < productList.length; i++) {
    var product = productList[i];
    if (!this.nav.products[product] && product != "adfree") {
      throw new Error(this.lineMsg() + "The product " + product + " wasn't declared in a *product command");
    }
  }
  checkPurchase(data, function(ok, result) {
    self.finished = false;
    self.skipFooter = false;
    if (!ok) {
      result = {billingSupported:true};
      self.temps.choice_purchase_error = true;
    }
    result = result || {};
    var products = data.split(/ /);
    var everything = true;
    for (var i = 0; i < products.length; i++) {
      var purchasedProduct = result[products[i]] || false;
      self.temps["choice_purchased_"+products[i]] = purchasedProduct;
      if (!purchasedProduct) everything = false;
    }
    self.temps.choice_purchased_everything = everything;
    self.temps.choice_purchase_supported = !!result.billingSupported;
    self.execute();
  });
};

Scene.prototype.parsePurchase = function parsePurchase(data) {
  var result;
  if (/^\{/.test(data)) {
    try {
      result = JSON.parse(data);
    } catch (e) {
      throw new Error(this.lineMsg() + "Couldn't parse purchase JSON: " + e)
    }
    if (!result.product) {
      throw new Error(this.lineMsg() + "JSON missing product");
    }
    if (!result['goto']) {
      throw new Error(this.lineMsg() + "JSON missing goto");
    }
    if (result.priceGuess && result.discount) {
      throw new Error(this.lineMsg() + "JSON has both top-level priceGuess and discount; there should be one or the other");
    }
    if (!(result.priceGuess || result.discount)) {
      throw new Error(this.lineMsg() + "JSON has neither top-level priceGuess nor discount; there should be one or the other");
    }
    if (result.discount) {
      if (!result.discount.end) throw new Error(this.lineMsg() + "JSON discount doesn't include end");
      result.discount.end = parseDateStringInCurrentTimezone(result.discount.end, this.lineNum + 1);
      if (!result.discount.lowPrice) throw new Error(this.lineMsg() + "JSON discount doesn't include lowPrice");
      if (!/^\$/.test(result.discount.lowPrice)) throw new Error(this.lineMsg() + "lowPrice " + fullPriceGuess + "doesn't start with dollar");
      if (!result.discount.fullPrice) throw new Error(this.lineMsg() + "JSON discount doesn't include fullPrice");
      if (!/^\$/.test(result.discount.fullPrice)) throw new Error(this.lineMsg() + "fullPrice " + fullPriceGuess + "doesn't start with dollar");
    }
    if (!result.title) result.title = "It";
  } else {
    var parsed = /^(\w+)\s+(\S+)\s+(.*)/.exec(data);
    if (!parsed) throw new Error(this.lineMsg() + "invalid line; can't parse purchaseable product: " + data);
    result = {product: parsed[1], priceGuess: parsed[2], "goto": parsed[3], title: "It"};
  }
  var product = result.product;
  if (!this.nav.products[product] && product != "adfree") {
    throw new Error(this.lineMsg() + "The product " + product + " wasn't declared in a *product command");
  }
  if (typeof this.temps["choice_purchased_" + product] === "undefined") throw new Error(this.lineMsg() + "Didn't check_purchases on this page");
  return result;
}

Scene.prototype.purchase = function purchase(data) {
  var parsed = this.parsePurchase(data);
  if (parsed.discount) {
    this.buyButtonDiscount(parsed.product, parsed.discount.end, parsed.discount.fullPrice, parsed.discount.lowPrice, parsed['goto'], parsed.title);
  } else {
    this.buyButton(parsed.product, parsed.priceGuess, parsed['goto'], parsed.title);
  }
}

Scene.prototype.buyButton = function(product, priceGuess, label, title) {
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  getPrice(product, function (price) {
    if (!price || "free" == price) {
      self["goto"](label);
      self.finished = false;
      self.resetPage();
    } else {
      if (price == "guess") price = priceGuess + " USD";
      var prerelease = self.getVar('choice_prerelease');
      var buttonText;
      if (prerelease) {
        buttonText = "Pre-Order " + title;
      } else {
        buttonText = "Buy "+title+" Now";
      }
      if (price != "hide") {
        buttonText += " for " + price;
      }
      var target = self.target;
      if (!target) target = document.getElementById('text');
      self.paragraph();
      var button = printButton(buttonText, target, false,
        function() {
          safeCall(self, function() {
              purchase(product, function() {
                safeCall(self, function() {
                  self["goto"](label);
                  self.finished = false;
                  self.resetPage();
                });
              });
          });
        }
      );
      self.prevLine = "block";
      if (isRestorePurchasesSupported()) {
        self.prevLine = "text";
        printLink(printParagraph("If you've already purchased, click here to "), "#", "restore purchases",
          function(e) {
            preventDefault(e);
            safeCall(self, function() {
                restorePurchases(product, function(purchased) {
                  if (purchased) {
                    self["goto"](label);
                    self.finished = false;
                    self.resetPage();
                  } else {
                    // refresh, in case we're on web showing a full-screen login. Not necessary on mobile? But, meh.
                    clearScreen(function() {loadAndRestoreGame("", window.forcedScene);});
                  }
                });
            });
          }
        );
      }

      self.skipFooter = false;
      self.finished = false;
      self.execute();
    }
  });
};

Scene.prototype.purchase_discount = function purchase_discount(line) {
  this.paragraph();
  var args = trim(String(line)).split(" ");
  if (args.length != 5) throw new Error(this.lineMsg() + "expected five arguments, saw "+args.length+": " + line);
  var product = args[0];
  var expectedEndDateString = args[1];
  var expectedEndDate = parseDateStringInCurrentTimezone(expectedEndDateString, this.lineNum+1);
  var fullPriceGuess = this.replaceVariables(args[2]);
  var discountedPriceGuess = this.replaceVariables(args[3]);
  var label = args[4];
  var startsWithDollar = /^\$/;
  if (!startsWithDollar.test(fullPriceGuess)) {
    throw new Error(this.lineMsg() + "full price guess "+fullPriceGuess+"doesn't start with dollar: " + line);
  }
  if (!startsWithDollar.test(discountedPriceGuess)) {
    throw new Error(this.lineMsg() + "discounted price guess "+discountedPriceGuess+"doesn't start with dollar: " + line);
  }
  var title = "It";
  this.buyButtonDiscount(product, expectedEndDate, fullPriceGuess, discountedPriceGuess, label, title);
}

Scene.prototype.buyButtonDiscount = function buyButtonDiscount(product, expectedEndDate, fullPriceGuess, discountedPriceGuess, label, title) {
  var prerelease = this.getVar('choice_prerelease');
  var discountText;
  if (prerelease) {
    discountText = "[b]Buy now before the price increases![/b]";
  } else {
    discountText = "[b]On sale until "+shortMonthStrings[expectedEndDate.getMonth()+1]+" "+expectedEndDate.getDate()+"! Buy now before the price increases![/b]"
  }
  if (typeof printDiscount != "undefined") {
    printDiscount(product, expectedEndDate.getYear()+1900, expectedEndDate.getMonth()+1, expectedEndDate.getDate(), discountText);
  }
  var priceGuess;
  if (new Date().getTime() < expectedEndDate.getTime()) {
    priceGuess = discountedPriceGuess;
  } else {
    priceGuess = fullPriceGuess;
  }
  this.buyButton(product, priceGuess, label, title);
}

Scene.prototype.print_discount = function print_Discount(line) {
  var result = /(\w+) (\d{4})-(\d{2})-(\d{2}) (.*$)/.exec(line);
  if (!result) throw new Error("invalid discount: " + line);
  var product = result[1];
  var fullYear = result[2];
  var oneBasedMonthNumber = parseInt(result[3],10);
  var dayOfMonth = parseInt(result[4],10);
  var discountText = result[5];
  this.temps.choice_discount_ends = "POISONTOKEN";
  discountText = this.replaceVariables(discountText).replace("POISONTOKEN", "${choice_discount_ends}");
  delete this.temps.choice_discount_ends;
  if (typeof printDiscount != "undefined") printDiscount(product, fullYear, oneBasedMonthNumber, dayOfMonth, discountText);
};

// *abort
// halt the scene without showing a button
Scene.prototype.abort = function() {
  this.paragraph();
  this.finished = true;
};

// *create
// create a new permanent stat
Scene.prototype.create = function create(line) {
    var result = /^(\w*)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg()+"Invalid create instruction, no variable specified: " + line);
    var variable = result[1];
    this.validateVariable(variable);
    variable = variable.toLowerCase();
    var expr = result[2];
    var stack = this.tokenizeExpr(expr);
    if (stack.length === 0) throw new Error(this.lineMsg()+"Invalid create instruction, no value specified: " + line);
    var self = this;
    function complexError() {
      throw new Error(self.lineMsg()+"Invalid create instruction, value must be a a number, true/false, or a quoted string: " + line);
    }
    if (stack.length > 1) complexError();
    var token = stack[0];
    if (!/STRING|NUMBER|VAR/.test(token.name)) complexError();
    if ("VAR" == token.name && !/^true|false$/i.test(token.value)) complexError();
    if ("STRING" == token.name && /(\$|@)!?!?{/.test(token.value)) throw new Error(this.lineMsg() + "Invalid create instruction, value must be a simple string without ${} or @{}: " + line);
    var value = this.evaluateExpr(stack);
    if (!this.created) this.created = {};
    if (this.created[variable]) throw new Error(this.lineMsg() + "Invalid create. " + variable + " was previously created on line " + this.created[variable]);
    this.created[variable] = this.lineNum + 1;
    this.stats[variable] = value;
    if (this.nav) this.nav.startingStats[variable] = value;
};

// *temp
// create a temporary stat for the current scene
Scene.prototype.temp = function temp(line) {
    var result = /^(\w*)(.*)/.exec(line);
    if (!result) throw new Error(this.lineMsg()+"Invalid temp instruction, no variable specified: " + line);
    var variable = result[1];
    this.validateVariable(variable);
    var expr = result[2];
    var stack = this.tokenizeExpr(expr);
    if (stack.length === 0) {
      this.temps[variable.toLowerCase()] = null;
      return;
    }
    var value = this.evaluateExpr(stack);
    if (typeof this.stats[variable.toLowerCase()] !== 'undefined') {
      this.warning("This is a temp, but we already ran *create " + variable);
    }
    this.temps[variable.toLowerCase()] = value;
};

// retrieve the value of the variable, preferring temp scope
Scene.prototype.getVar = function getVar(variable) {
    var value;
    variable = String(variable).toLowerCase();
    if (variable && !isNaN(1*variable) && String(1*variable) === variable) return 1*variable;
    if (variable == "true") return true;
    if (variable == "false") return false;
    if (variable == "choice_subscribe_allowed") return true;
    if (variable == "choice_register_allowed") return isRegisterAllowed();
    if (variable == "choice_registered") return typeof window != "undefined" && !!window.registered;
    if (variable == "choice_is_web") return typeof window != "undefined" && !!window.isWeb;
    if (variable == "choice_is_steam") return typeof window != "undefined" && !!window.isSteamApp;
    if (variable == "choice_is_ios_app") return typeof window != "undefined" && !!window.isIosApp;
    if (variable == "choice_is_android_app") return typeof window != "undefined" && !!window.isAndroidApp;
    if (variable == "choice_is_omnibus_app") return typeof window != "undefined" && !!window.isOmnibusApp;
    if (variable == "choice_is_amazon_app") return typeof window != "undefined" && !!window.isAmazonApp;
    if (variable == "choice_is_advertising_supported") return typeof isAdvertisingSupported != "undefined" && !!isAdvertisingSupported();
    if (variable == "choice_is_trial") return !!(typeof isTrial != "undefined" && isTrial);
    if (variable == "choice_release_date") {
      if (typeof window != "undefined" && window.releaseDate) {
        return simpleDateTimeFormat(window.releaseDate);
      }
      return "release day";
    }
    if (variable == "choice_prerelease") return isPrerelease();
    if (variable == "choice_kindle") return typeof isKindle !== "undefined" && !!isKindle;
    if (variable == "choice_randomtest") return !!this.randomtest;
    if (variable == "choice_quicktest") return false; // quicktest will explore "false" paths
    if (variable == "choice_restore_purchases_allowed") return isRestorePurchasesSupported();
    if (variable == "choice_save_allowed") return areSaveSlotsSupported();
    if (variable == "choice_time_stamp") return Math.floor(new Date()/1000);
    if (variable == "choice_nightmode") return typeof isNightMode != "undefined" && isNightMode();
    if ((!this.temps.hasOwnProperty(variable))) {
        if ((!this.stats.hasOwnProperty(variable))) {
            throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
        }
        value = this.stats[variable];
        if (value === null || value === undefined) {
            throw new Error(this.lineMsg() + "Variable '"+variable+"' exists but has no value");
        }
        if (this.debugMode) println("stats["+ variable + "]==" + value);
        return value;
    }
    value = this.temps[variable];
    if (value === null || value === undefined) {
        throw new Error(this.lineMsg() + "Variable '"+variable+"' exists but has no value");
    }
    if (this.debugMode) println("temps["+ variable + "]==" + value);
    return value;
};

// set the value of the variable, preferring temp scope
Scene.prototype.setVar = function setVar(variable, value) {
    variable = variable.toLowerCase();
    if (this.debugMode) println(variable +"="+ value);
    if ("undefined" === typeof this.temps[variable]) {
        if ("undefined" === typeof this.stats[variable]) {
            throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
        }
        this.stats[variable] = value;
        if (this.saveSlot == "temp") tempStatWrites[variable] = value;
        // Implicit control flow flag is ideally set just once in startup.
        // Removing these lines makes this not possible with quicktest.
        if (variable == "implicit_control_flow" && this.nav) {
            this.nav.startingStats["implicit_control_flow"] = value;
        }
    } else {
        this.temps[variable] = value;
    }
};

// *delete variable
// deletes the named variable
Scene.prototype["delete"] = function scene_delete(variable) {
    variable = variable.toLowerCase();
    if ("undefined" === typeof this.temps[variable]) {
        if ("undefined" === typeof this.stats[variable]) {
            throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
        }
        delete this.stats[variable];
    } else {
        delete this.temps[variable];
    }
};

// during a choice, recursively parse the options
Scene.prototype.parseOptions = function parseOptions(startIndent, choicesRemaining, expectedSubOptions) {
    // nextIndent: the level of indentation after the current line
    // For example, in the color/toy sample above, we start at 0
    // then the nextIndent is 2 for "red"
    // then the nextIndent is 4 for "spaceship"
    var nextIndent = null;
    var options = [];
    var choiceEnds = [];
    var line;
    var currentChoice = choicesRemaining[0];
    if (!currentChoice) currentChoice = "choice";
    var suboptionsEncountered = false;
    var bodyExpected = false;
    var previousSubOptions;
    var namesEncountered = {};
    var atLeastOneSelectableOption = false;
    var prevOption, ifResult;
    var startingLine = this.lineNum;
    var self = this;
    function removeModifierCommand(stripParethentical) {
      if (stripParethentical) {
        var openParen = line.indexOf("(")+1;
        var closingParen = matchBracket(line, "()", openParen);
        if (closingParen == -1) {
          throw new Error(self.lineMsg() + "missing closing parenthesis");
        }
        line = trim(line.substr(closingParen+1));
      } else {
        line = trim(line.replace(/^\s*\*(\w+)(.*)/, "$2"));
      }
      parsed = /^\s*\*(\w+)(.*)/.exec(line);
      if (parsed) {
        command = parsed[1].toLowerCase();
        data = trim(parsed[2]);
      } else {
        command = "";
      }
    }
    while(isDefined(line = this.lines[++this.lineNum])) {
        if (!trim(line)) {
            this.rollbackLineCoverage();
            continue;
        }
        var indent = this.getIndent(line);
        if (nextIndent === null || nextIndent === undefined) {
            // initialize nextIndent with whatever indentation the line turns out to be
            // ...unless it's not indented at all
            if (indent <= startIndent) {
                throw new Error(this.lineMsg() + "invalid indent, expected at least one '" + currentChoice + "'");
            }
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) {
            // it's over!
            break;
        }
        if (indent < this.indent) {
            // TODO drift detection
            if (false) /*(indent != nextIndent)*/ {
                // error: indentation has decreased, but not all the way back
                // Example:
                // *choice
                //     red
                //   blue
                throw new Error(this.lineMsg() + "invalid indent, expected "+this.indent+", was " + indent);
            }

            // we must be falling out of a sub-block
            this.dedent(indent);
            this.indent = indent;
        }
        if (indent > this.indent) {
            // body of the choice
            // ...unless we haven't identified our choices yet
            // TODO is this error test valid?
            if (choicesRemaining.length>1) throw new Error(this.lineMsg() + "invalid indent, there were subchoices remaining: [" + choicesRemaining.join(",") + "]");
            this.rollbackLineCoverage();
            bodyExpected = false;
            continue;
        }

        // here's the end of the previous option
        if (options.length) {
          prevOption = options[options.length-1];
          if (!prevOption.endLine) prevOption.endLine = this.lineNum;
        }

        // Execute *if commands (etc.) during option loop
        // sub-commands may modify this.indent
        var parsed = /^\s*\*(\w+)(.*)/.exec(line);
        var unselectable = false;
        var inlineIf = null;
        var selectableIf = null;
        var self = this;

        var overrideDefaultReuseSetting = false;
        var reuse = this.temps.choice_reuse;
        if (parsed) {
            var command = parsed[1].toLowerCase();
            var data = trim(parsed[2]);
            // TODO whitelist commands
            if ("hide_reuse" == command) {
              reuse = "hide";
              overrideDefaultReuseSetting = true;
              removeModifierCommand();
            }
            if ("disable_reuse" == command) {
              reuse = "disable";
              overrideDefaultReuseSetting = true;
              removeModifierCommand();
            }
            if ("allow_reuse" == command) {
              reuse = "allow";
              overrideDefaultReuseSetting = true;
              removeModifierCommand();
            }
            if ("random_weight" == command) {
              removeModifierCommand(true /*stripParenthetical*/);
            }

            if ("print" == command) {
                line = this.evaluateExpr(this.tokenizeExpr(data));
            } else if ("if" == command) {
              choiceEnds.push(this.lineNum);
              ifResult = this.parseOptionIf(data, command);
              if (ifResult) {
                inlineIf = ifResult.condition;
                if (ifResult.result) {
                  line = ifResult.line;
                } else {
                  continue;
                }
              } else {
                this["if"](data, true /*inChoice*/);
                continue;
              }
            } else if (/^(else|elseif|elsif)$/.test(command)) {
              this[command](data, true /*inChoice*/);
              continue;
            } else if ("selectable_if" == command) {
              ifResult = this.parseOptionIf(data, command);
              if (!ifResult) throw new Error(this.lineMsg() + "Couldn't parse the line after *selectable_if: " + data);
              line = ifResult.line;
              selectableIf = ifResult.condition;
              unselectable = unselectable || !ifResult.result;
            } else if ("comment" == command) {
                continue;
            } else if (!command) {
              // command was rewritten by earlier modifier
            } else {
                if (Scene.validCommands[command]) {
                  throw new Error(this.lineMsg() + "Invalid indent? Expected an #option here, not *"+command);
                }  else {
                    throw new Error(this.lineMsg() + "Non-existent command '"+command+"'");
                }
            }
        }

        if ("allow" != reuse) {
          if (!this.temps.choice_used) this.temps.choice_used = {};
          if (this.temps.choice_used[this.lineNum]) {
            if ("hide" == reuse) continue;
            unselectable = true;
          }
        }

        // this line should be a valid option
        if (!/^\s*\#\s*\S/.test(line)) {
            throw new Error(this.lineMsg() + "Expected option starting with #");
        }
        // replace variables here and discard the result, so error messages display the correct line
        this.replaceVariables(line);
        line = trim(trim(line).substring(1));
        var option = {name:line, group:currentChoice};
        if (reuse != "allow") option.reuse = reuse;
        if (this.displayOptionConditions) {
          option.displayIf = [];
          for (var i = 0; i < this.displayOptionConditions.length; i++) {
            option.displayIf[i] = this.displayOptionConditions[i];
          }
          if (inlineIf) option.displayIf.push(inlineIf);
        } else if (inlineIf) {
          option.displayIf = [inlineIf];
        }
        if (selectableIf) {
          option.selectableIf = selectableIf;
        }
        option.line = this.lineNum + 1;
        if (unselectable) {
          option.unselectable = true;
        }
        if (namesEncountered[line]) {
            this.conflictingOptions(this.lineMsg() + "Invalid option; conflicts with option '"+option.name+"' on line " + namesEncountered[line]);
        } else {
            namesEncountered[line] = option.line;
        }
        options.push(option);
        if (choicesRemaining.length>1) {
            // recursive call will modify this.indent
            option.suboptions = this.parseOptions(this.indent, choicesRemaining.slice(1), previousSubOptions);
            // now restore it
            this.indent = nextIndent;
            if (!previousSubOptions) previousSubOptions = option.suboptions;
            suboptionsEncountered = true;
        } else {
            bodyExpected = true;
        }
        if (!unselectable) atLeastOneSelectableOption = true;
    }

    // TODO is this error test valid?
    if (choicesRemaining.length>1 && !suboptionsEncountered) {
        throw new Error(this.lineMsg() + "invalid indent, there were subchoices remaining: [" + choicesRemaining.join(",") + "]");
    }
    if (bodyExpected &&
            (this.temps._fakeChoiceDepth === undefined || this.temps._fakeChoiceDepth < 1)) {
        throw new Error(this.lineMsg() + "Expected choice body");
    }
    if (!atLeastOneSelectableOption) this.conflictingOptions(this.lineMsg() + "No selectable options");
    if (expectedSubOptions) {
        this.verifyOptionsMatch(expectedSubOptions, options);
    }
    this.rollbackLineCoverage();
    prevOption = options[options.length-1];
    this.lineNum = this.previousNonBlankLineNum();
    if (!prevOption.endLine) prevOption.endLine = this.lineNum+1;
    for (i = 0; i < choiceEnds.length; i++) {
        this.temps._choiceEnds[choiceEnds[i]] = this.lineNum;
    }
    this.rollbackLineCoverage();
    return options;
};

// compute *if statement during options
Scene.prototype.parseOptionIf = function parseOptionIf(data) {
  var parsed = /^\s*\((.*)\)\s+(#.*)/.exec(data);
  if (!parsed) {
    return;
  }
  var condition = parsed[1];
  var stack = this.tokenizeExpr(condition);
  var result = this.evaluateExpr(stack);
  if (this.debugMode) println(condition + " :: " + result);
  result = bool(result, this.lineNum+1);
  // In the autotester, all conditionals are enabled
  result = result || this.testPath;
  return {result:result, line:parsed[2], condition:null};
};

// Add this as a separate method so we can override it elsewhere
// We want this error during randomtest but not during autotest
// Because autotest makes impossible situations happen
Scene.prototype.conflictingOptions = function conflictingOptions(str) {
  throw new Error(str);
};

// verify that the current option set corresponds to the previous option set
// (for multichoices)
Scene.prototype.verifyOptionsMatch = function verifyOptionsMatch(prev, current) {
    // find matching option by name
    function findMatch(name, options) {
        for (var i = 0; i < options.length; i++) {
            var option = options[i];
            if (option && name == option.name) {
                return option;
            }
        }
        return null;
    }

    var prevOpt, curOpt;
    for (var i = 0; i < prev.length; i++) {
        prevOpt = prev[i];
        curOpt = findMatch(prevOpt.name, current);
        if (!curOpt) throw new Error(this.lineMsg()+"Missing expected suboption '"+prevOpt.name+"'; all suboptions must have same option list");
    }

    if (prev.length == current.length) return;

    for (i = 0; i < current.length; i++) {
        curOpt = current[i];
        prevOpt = findMatch(curOpt.name, prev);
        if (!prevOpt) throw new Error(this.lineMsg()+"Added unexpected suboption '"+curOpt.name+"'; all suboptions must have same option list");
    }

    throw new Error(this.lineMsg()+"Bug? previous options and current options mismatch, but no particular missing element");
};

// render the prompt and the radio buttons
Scene.prototype.renderOptions = function renderOptions(groups, options, callback) {
    var self = this;
    function replaceVars(options) {
      for (var i = 0; i < options.length; i++) {
        var option = options[i];
        option.name = self.replaceVariables(option.name);
        if (option.suboptions) replaceVars(option.suboptions);
      }
    }
    replaceVars(options);
    this.paragraph();
    printOptions(groups, options, callback);

    if (this.debugMode) println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));

    if (this.finished) printFooter();
};

// *page_break
// pause and prompt the user to press "Next"
Scene.prototype.page_break = function page_break(buttonName) {
    if (this.screenEmpty) return;
    if (!buttonName) buttonName = "Next";
    buttonName = this.replaceVariables(buttonName);
    this.paragraph();
    this.finished = true;

    var self = this;
    printButton(buttonName, main, false,
      function() {
        self.finished = false;
        self.resetPage();
      }
    );
    if (this.debugMode) println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));
};

// *line_break
// single line break in the middle of a paragraph
Scene.prototype.line_break = function line_break() {
    // We want to prevent a huge <p><br></p> between blocks
    // so if there's existing text we'll just toss in a [n/]
    // and if there's no text yet, we'll directly insert a <br>
    if (this.accumulatedParagraph.length) {
      this.accumulatedParagraph.push('[n/]');
    } else {
      println();
    }
};

// *image
Scene.prototype.image = function image(data, invert) {
  this.paragraph();
  data = data || "";
  /* Don't apply the regex match to data:image values, it's far too slow */
  var dataImage = false;
  var dataImageVal;
  if (data.match(/data:image/)) {
    var dataImageEnd = data.indexOf(" ");
    if (dataImageEnd >= 0) {
      dataImageVal = data.substring(0, dataImageEnd);
      data = ("CSIDE_DATA_IMG.png" + data.slice(dataImageEnd));
    } else {
      dataImageVal = data;
      data = "CSIDE_DATA_IMG.png";
    }
    dataImage = true;
  }
  data = this.replaceVariables(data);
  var match = /(\S+) (\S+)(.*)/.exec(data);
  var source, alignment;
  var alt = null;
  if (match) {
    var source = match[1];
    var alignment = match[2];
    var alt = trim(match[3]);
  } else {
    source = data;
  }
  if (source === "") throw new Error(this.lineMsg()+"*image requires the file name of an image");
  if (source === "CSIDE_DATA_IMG.png") source = dataImageVal;
  alignment = alignment || "center";
  if (!/(right|left|center|none)/.test(alignment)) throw new Error(this.lineMsg()+"Invalid alignment, expected right, left, center, or none: " + data);
  printImage(source, alignment, alt, invert);
  if (this.verifyImage && !dataImage) this.verifyImage(source);
  if (alignment == "none") this.prevLine = "text";
  this.screenEmpty = false;
};

Scene.prototype.text_image = function textImage(data) {
  this.image(data, "invert");
}

// *sound
// play named sound file
Scene.prototype.sound = function sound(source) {
    if (typeof playSound == "function") playSound(source);
    if (this.verifyImage) this.verifyImage(source);
};

Scene.prototype.kindle_image = function kindle_image() {
  // Do nothing on non-Kindle devices; show only on Kindle
};

Scene.prototype.youtube = function youtube(slug) {
  if (typeof printYoutubeFrame !== "undefined") {
    printYoutubeFrame(slug);
    this.prevLine = "block";
    this.screenEmpty = false;
  }
}

Scene.prototype.kindle_search = Scene.prototype.kindle_product = function kindle_search(data) {
  var result = /^\((.+)\) ([^\)]+)/.exec(data);
  if (!result) throw new Error(this.lineMsg()+"Invalid arguments: " + data);
  var query = result[1];
  var buttonName = result[2];
  if ("undefined" != typeof kindleButton) kindleButton(this.target, query, buttonName);
};

// *link
// Display URL with anchor text
Scene.prototype.link = function link(data) {
    var result = /^(\S+)\s*(.*)/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have an URL: " + data);
    var href = result[1].replace(/\]/g, "%5D");
    var anchorText = trim(result[2]) || href;
    this.printLine("[url="+href+"]"+anchorText+"[/url]");
    this.prevLine = "text";
    this.screenEmpty = false;
};

// *link_button
// Display button that takes you to an URL
Scene.prototype.link_button = function linkButton(data) {
    if (typeof window == "undefined") return;
    var result = /^(\S+)\s*(.*)/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have an URL: " + data);
    var href = result[1];
    var anchorText = trim(result[2]) || href;
    this.paragraph();
    var target = this.target;
    if (!target) target = document.getElementById('text');
    printButton(anchorText, target, false, function() {
      window.location.href = href;
    });
    this.prevLine = "empty";
    this.screenEmpty = false;
};

// how many spaces is this line indented?
Scene.prototype.getIndent = function getIndent(line) {
    if (line === null || line === undefined) return 0;
    var spaces = line.match(/^([ \t]*)/);
    if (spaces === null || spaces === undefined) return 0;
    var whitespace = spaces[0];
    var len = whitespace.length;
    if (0 === len) return 0;
    var tab = /\t/.test(whitespace);
    var space = / /.test(whitespace);
    if (tab && space) {
        throw new Error(this.lineMsg()+"Tabs and spaces appear on the same line");
    }
    if (tab) {
        this.firstTab = this.lineNum+1;
        if (this.firstSpace) {
            throw new Error(this.lineMsg()+"Illegal mixing of spaces and tabs; this line has a tab, but there were spaces on line " + this.firstSpace);
        }
    } else {
        this.firstSpace = this.lineNum + 1;
        if (this.firstTab) {
            throw new Error(this.lineMsg()+"Illegal mixing of spaces and tabs; this line has a space, but there were tabs on line " + this.firstTab);
        }
    }
    return len;
};

// *comment ignorable text
Scene.prototype.comment = function comment(line) {
    if (this.debugMode) println("*comment " + line);
};

Scene.prototype.advertisement = function advertisement() {
  if (typeof isFullScreenAdvertisingSupported != "undefined" && isFullScreenAdvertisingSupported()) {
    this.finished = true;
    this.skipFooter = true;

    var self = this;
    showFullScreenAdvertisement(function() {
      self.finished = false;
      self.skipFooter = false;
      self.resetPage();
    });
  }

};

// *looplimit 5
// The number of times a given line is allowed to be accessed
Scene.prototype.looplimit_count = 1000;
Scene.prototype.looplimit = function looplimit(count) {
  this.looplimit_count = num(count, this.lineNum, this.name);
};

Scene.prototype.hide_reuse = function hide_reuse() {
  this.temps.choice_reuse = "hide";
};

Scene.prototype.disable_reuse = function disable_reuse() {
  this.temps.choice_reuse = "disable";
};

Scene.prototype.allow_reuse = function allow_reuse() {
  this.temps.choice_reuse = "allow";
};

// *label labelName
// Labels a line for use later in *goto
// Do nothing here; these labels are parsed in this.parseLabel
Scene.prototype.label = function label() {};

// *print expr
// print the value of the specified expression
Scene.prototype.print = function scene_print(expr) {
    var value = this.evaluateExpr(this.tokenizeExpr(expr));
    this.prevLine = "text";
    this.screenEmpty = false;
    this.printLine(value);
};

Scene.prototype.parseInputText = function parseInputText(line) {
  var stack = this.tokenizeExpr(line);
  var variable = this.evaluateReference(stack);
  if ("undefined" === typeof this.temps[variable] && "undefined" === typeof this.stats[variable]) {
    throw new Error(this.lineMsg() + "Non-existent variable '" + variable + "'");
  }

  var inputOptions = { long: false, allow_blank: false };
  for (var i = 0; i < stack.length; i++) {
    var token = stack[i];
    if (token.name !== "VAR") {
      throw new Error(this.lineMsg() + "Couldn't understand this input_text line");
    }
    var option = token.value;
    if (typeof inputOptions[option] === "undefined") {
      throw new Error(this.lineMsg() + "Couldn't understand this input_text option: " + option);
    }
    inputOptions[option] = true;
  }
  return {variable:variable, inputOptions:inputOptions};
}

// *input_text var
// record text typed by the user and store it in the specified variable
Scene.prototype.input_text = function input_text(line) {
    var result = this.parseInputText(line);
    var variable = result.variable;

    this.finished = true;
    this.paragraph();
    var self = this;
    printInput(this.target, result.inputOptions, function(value) {
      safeCall(self, function() {
        value = trim(String(value));
        value = value.replace(/\n/g, "[n/]");
        if (self.nav) self.nav.bugLog.push("*input_text " + variable + " " + value);
        self.finished = false;
        self.setVar(variable, value);
        self.resetPage();
      });
    });
    if (this.debugMode) println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));
};

// *input_number var min max
// record number typed by the user and store it in the specified variable
Scene.prototype.input_number = function input_number(data) {
    var stack = this.tokenizeExpr(data);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var variable = this.evaluateReference(stack);
    if ("undefined" === typeof this.temps[variable] && "undefined" === typeof this.stats[variable]) {
      throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
    }

    var simpleConstants;
    if (stack.length == 2 && stack[0].name == "NUMBER" && stack[1].name == "NUMBER") {
      simpleConstants = true;
    } else {
      simpleConstants = false;
    }

    if (!stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    var minimum = this.evaluateValueToken(stack.shift(), stack);
    if (isNaN(minimum*1)) throw new Error(this.lineMsg() + "Invalid minimum, not numeric: " + minimum);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");

    var maximum = this.evaluateValueToken(stack.shift(), stack);
    if (stack.length) throw new Error(this.lineMsg() + "Invalid input_number statement, expected three args: varname min max");
    if (isNaN(maximum*1)) throw new Error(this.lineMsg() + "Invalid maximum, not numeric: " + maximum);

    // in quicktest, min and max can get mixed up as the interpreter "cheats" on if statements
    // so quicktest will ignore min/max errors unless they're simple constants e.g. *input_number x 6 4
    var checkMinMax = !this.quicktest || simpleConstants;
    if (checkMinMax && parseFloat(minimum) > parseFloat(maximum)) {
      throw new Error(this.lineMsg() + "Minimum " + minimum+ " should not be greater than maximum " + maximum);
    }

    function isInt(x) {
       var y=parseInt(x,10);
       if (isNaN(y)) return false;
       return x==y && x.toString()==y.toString();
    }
    var intRequired;
    if (isInt(minimum) && isInt(maximum)) {
      intRequired = 1;
    }
    this.finished = true;
    this.paragraph();
    var self = this;
    printInput(this.target, {numeric: true}, function(value) {
      safeCall(self, function() {
        var numValue = parseFloat(""+value);
        if (isNaN(numValue)) {
          asyncAlert("Please type in a number.");
          return;
        }
        if (intRequired && !isInt(value)) {
          asyncAlert("Please type in an integer number.");
          return;
        }
        if (numValue < minimum * 1) {
          asyncAlert("Please use a number greater than or equal to " + minimum);
          return;
        }
        if (numValue > maximum * 1 && !this.quicktest) {
          asyncAlert("Please use a number less than or equal to " + maximum);
          return;
        }
        if (self.nav) self.nav.bugLog.push("*input_number " + variable + " " + value);
        self.finished = false;
        self.setVar(variable, numValue);
        self.resetPage();
      });
    }, minimum, maximum, intRequired);
    if (this.debugMode) println(computeCookie(this.stats, this.temps, this.lineNum, this.indent));
};

// *script code
// evaluate the specified ECMAScript
Scene.prototype.script = function script(code) {
    var stats = this.stats;
    var temps = this.temps;
    try {
      if (typeof window == "undefined") {
        (function() {
          var window = _global;
          eval(code);
        }).call(this);
      } else {
        eval(code);
      }
    } catch (e) {
      throw new Error(this.lineMsg() + "error executing *script: " + e + (e.stack ? "\n" + e.stack : ""));
    }
};

// is this a valid variable name?
Scene.prototype.validateVariable = function validateVariable(variable) {
    if (!variable || !/^[a-zA-Z]/.test(variable)) {
        throw new Error(this.lineMsg()+"Invalid variable name, must start with a letter: " + variable);
    }
    if (!/^\w+$/.test(variable)) {
        throw new Error(this.lineMsg()+"Invalid variable name: '" + variable + "'");
    }
    if (/^(and|or|true|false|scene|scenename)$/i.test(variable)) throw new Error(this.lineMsg()+"Invalid variable name, '" + variable + "' is a reserved word");
    if (/^choice_/.test(variable)) throw new Error(this.lineMsg()+"Invalid variable name, variables may not start with 'choice_'; this is a reserved prefix");
};

// *rand varname min max
// Set varname to a random number from min to max
//
// Example:
// *rand foo 1 6
//   roll a cube die
// *rand foo 1.0 6.0
//   compute a decimal from [1.0,6.0)
Scene.prototype.rand = function rand(data) {
    var stack = this.tokenizeExpr(data);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var variable = this.evaluateReference(stack);
    if ("undefined" === typeof this.temps[variable] && "undefined" === typeof this.stats[variable]) {
      throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
    }

    if (!stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var minimum = this.evaluateValueToken(stack.shift(), stack);
    if (!stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var maximum = this.evaluateValueToken(stack.shift(), stack);
    if (stack.length) throw new Error(this.lineMsg() + "Invalid rand statement, expected three args: varname min max");
    var diff;

    diff = maximum - minimum;
    if (isNaN(diff)) {
        throw new Error(this.lineMsg() + "Invalid rand statement, min and max must be numbers");
    }
    if (diff < 0) {
        throw new Error(this.lineMsg() + "Invalid rand statement, min must be less than max: " + minimum + " > " + maximum);
    }
    if (diff === 0) {
      this.setVar(variable, minimum);
      return;
    }
    function isInt(x) {
       var y=parseInt(x,10);
       if (isNaN(y)) return false;
       return x==y && x.toString()==y.toString();
    }
    var result;
    var random = Math.random();
    if (isInt(minimum) && isInt(maximum)) {
        // int random
        result = 1*minimum + Math.floor(random*(diff+1));
    } else {
        result = 1*minimum + random*diff;
    }
    this.setVar(variable, result);
    if (this.randomLog) {
      this.randomLog("*rand " + variable + " " + result);
    }
    if (this.nav) this.nav.bugLog.push("*rand " + variable + " " + result);
};

// *set varname expr
// sets the specified varname to the value of the expr
//
// Examples:
//
// literal
//     literal int: 2
//     literal decimal: 2.3
//     boolean value: true
//     quoted string: "fie"
//         with backslash escaping "she said it was \"ironic\"!"  "c:\\foo"
//     variable name: foo
//
// math
//     +: 2+2
//     -: foo-3
//     *: 2*3
//     /: 8/2
//     if one operand is a string, we'll try to parse it as a number, fail if that doesn't work
//
// fairmath
//     %+: foo%+30
//     %-: foo%-20
//
// concatenate
//     &: "foo"&bar
//
// may omit leading operand
//     *set foo +2
//     *set foo %+30
//     *set foo &"blah blah"
//
// spaces optional
//     *set foo+2
//     *set foo bar + 2
//     *set bar% +30
//
// multiple operators in one line, parentheses mandatory
//     *set foo (foo+2)/4
//     *set foo 2+(foo/2)
//     *set foo (foo/2)+(bar/3)
//     *set foo +(bar/3)
//
// set variable by reference
//
//     *set foo bar
//     *set {foo} 3
//     *comment now bar=3
Scene.prototype.set = function set(line) {
    var stack = this.tokenizeExpr(line);
    var variable = this.evaluateReference(stack);
    if ("undefined" === typeof this.temps[variable] && "undefined" === typeof this.stats[variable]) {
      throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
    }
    if (stack.length === 0) throw new Error(this.lineMsg()+"Invalid set instruction, no expression specified: " + line);
    // if the first token is an operator, then it's implicitly based on the variable
    if (/OPERATOR|FAIRMATH/.test(stack[0].name)) stack.unshift({name:"VAR", value:variable, pos:"(implicit)"});
    var value = this.evaluateExpr(stack);
    this.setVar(variable, value);
};

// *setref variableExpr expr
// just like *set, but variableExpr is a string expression naming a variable reference
//
// Example:
// *set foo "bar"
// *setref foo 3
// *comment now bar=3
Scene.prototype.setref = function setref(line) {
    var stack = this.tokenizeExpr(line);
    var variable = this.evaluateValueToken(stack.shift(), stack);
    variable = String(variable).toLowerCase();

    if ("undefined" === typeof this.temps[variable] && "undefined" === typeof this.stats[variable]) {
      throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
    }

    // if the first token is an operator, then it's implicitly based on the variable
    if (/OPERATOR|FAIRMATH/.test(stack[0].name)) stack.unshift({name:"VAR", value:variable, pos:"(implicit)"});
    var value = this.evaluateExpr(stack);
    this.setVar(variable, value);
};

Scene.prototype.share_this_game = function share_links(now) {
  now = !!trim(now);
  this.paragraph();
  printShareLinks(this.target, now);
  this.prevLine = "empty"; // printShareLinks provides its own paragraph break
};

Scene.prototype.more_games = function more_games(now) {
  if (typeof window == "undefined" || typeof moreGames == "undefined") return;
  if (!!trim(now)) {
    moreGames();
    return;
  }
  var self = this;
  this.paragraph();
  var target = this.target;
  if (!target) target = document.getElementById('text');
  var button = printButton("Play More Games Like This", target, false,
    function() {
      safeCall(self, moreGames);
    }
  );

  setClass(button, "");
  this.prevLine = "block";
};

Scene.prototype.ending = function ending() {
    if (typeof window == "undefined") return;
    this.paragraph();
    var groups = [""];
    options = [];
    options.push({name:"Play again.", group:"choice", restart:true});
    if (!window.isOmnibusApp) options.push({name:"Play more games like this.", group:"choice", moreGames:true});
    options.push({name:"Share this game with friends.", group:"choice", share:true});
    options.push({name:"Email me when new games are available.", group:"choice", subscribe:true});

    var self = this;
    function endingMenu() {
      printFollowButtons();
      self.renderOptions([""], options, function(option) {
        if (option.restart) {
          return restartGame();
        } else if (option.moreGames) {
          self.more_games("now");
          if (typeof curl != "undefined") curl();
        } else if (option.share) {
          clearScreen(function() {
            self.share_this_game("now");
            endingMenu();
          });
        } else if (option.subscribe) {
          subscribeLink();
        }
      });
    }
    endingMenu();
    this.finished = true;
};

Scene.prototype.restart = function restart() {
  delayBreakEnd();
  if (this.secondaryMode) {
    if (this.secondaryMode == "stats") {
      this.reset();
      this.redirect_scene(this.nav.getStartupScene());
    } else {
      throw new Error(this.lineMsg() + "Cannot *restart in " + this.secondaryMode + " mode");
    }
  } else {
    restartGame();
  }
  this.finished = true;
};

/* Subscribe options, in JSON format.
"now" on mobile means we should immediately mailto: the subscribe address
otherwise, we should display a Subscribe button which launches the mailto:
On non-mailte: platforms, we ignore "now"

"allowContinue" is the default; setting it to false blocks the "No, Thanks"
button and the "Next" button after successfully subscribing
Only Coming Soon pages use "allowContinue"

"message" is the message we'll show to justify subscribing
the default message is: "we'll notify you when our next game is ready!" */
Scene.prototype.subscribe = function scene_subscribe(data) {
  this.paragraph();
  var options = {};
  if (data) {
    try {
      options = JSON.parse(data);
    } catch (e) {
      throw new Error(this.lineMsg() + "Couldn't parse subscribe arguments: " + data);
    }
  }
  this.prevLine = "block";
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  subscribe(this.target, options, function(now) {
    self.finished = false;
    // if "now" actually worked, then continue the scene
    // otherwise, reset the page before continuing
    if (now) {
      self.skipFooter = false;
      self.execute();
    } else {
      self.resetPage();
    }
  });
};

Scene.prototype.restore_game = function restore_game(data) {
  var cancelLabel;
  if (data) {
    var result = /^cancel=(\S+)$/.exec(data);
    if (!result) throw new Error(this.lineMsg() + "invalid restore_game line: " + data);
    cancelLabel = result[1];
  }
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  var unrestorableScenes = this.parseRestoreGame(false/*alreadyFinished*/);
  function renderRestoreMenu(saveList, dirtySaveList) {
    self.paragraph();
    var options = [];
    for (var i = 0; i < saveList.length; i++) {
      var save = saveList[i];
      var date = new Date(save.timestamp*1);
      if (!save) continue;
      var name = "";
      if (save.temps && save.temps.choice_restore_name) name = save.temps.choice_restore_name;
      options.push({name:name + " ("+simpleDateTimeFormat(date)+")", group:"choice", state:save});
    }
    if (false) options.push({name:"Restore using a password.", group:"choice", password:true});
    options.push({name:"Retrieve saved games online from choiceofgames.com.", group:"choice", fetch:true});
    if (dirtySaveList.length) options.push({name:"Upload saved games to choiceofgames.com.", group:"choice", upload:true});
    options.push({name:"Cancel.", group:"choice", cancel:true});
    var groups = [""];
    self.renderOptions(groups, options, function(option) {
      if (option.upload) {
        clearScreen(function() {
          fetchEmail(function(defaultEmail){
            self.printLine("Please type your email address to identify yourself.");
            self.paragraph();
            promptEmailAddress(this.target, defaultEmail, "allowContinue", function(cancel, email) {
              if (cancel) {
                self.finished = false;
                if (typeof cancelLabel !== "undefined") {
                  self["goto"](cancelLabel);
                }
                self.resetPage();
                return;
              }
              clearScreen(function() {
                startLoading();
                submitDirtySaves(dirtySaveList, email, function(ok) {
                  doneLoading();
                  self.prevLine = "text"; // Put some space between the message and the option list
                  if (!ok) {
                    self.printLine("Error uploading saves. Please try again later.");
                    renderRestoreMenu(saveList, dirtySaveList);
                  } else {
                    var count = dirtySaveList.length + (dirtySaveList.length == 1 ? " save" : " saves");
                    self.printLine("Uploaded " + count + ".");
                    renderRestoreMenu(saveList, []);
                  }
                });
              });
            });
          });
        });
      } else if (option.fetch) {
        clearScreen(function() {
          fetchEmail(function(defaultEmail){
            self.printLine("Please type your email address to identify yourself.");
            self.paragraph();
            promptEmailAddress(this.target, defaultEmail, "allowContinue", function(cancel, email) {
              if (cancel) {
                self.finished = false;
                if (typeof cancelLabel !== "undefined") {
                  self["goto"](cancelLabel);
                }
                self.resetPage();
                return;
              }
              clearScreen(function() {
                startLoading();
                getRemoteSaves(email, function (remoteSaveList) {
                  doneLoading();
                  self.prevLine = "text";
                  if (!remoteSaveList) {
                    self.printLine("Error downloading saves. Please try again later.");
                    renderRestoreMenu(saveList, dirtySaveList);
                  } else {
                    mergeRemoteSaves(remoteSaveList, "recordDirty", function(saveList, newRemoteSaves, dirtySaveList) {
                      if (!remoteSaveList.length) {
                        self.printLine("No saves downloaded for email address \""+email+"\". (Is that the correct email address?) If you're having trouble, please contact support at "+getSupportEmail()+".");
                        renderRestoreMenu(saveList, dirtySaveList);
                      } else {
                        var downloadCount = remoteSaveList.length + " saved " + (remoteSaveList.length == 1 ? "game" : "games");
                        var newCount = newRemoteSaves + " new saved " + (newRemoteSaves == 1 ? "game" : "games");
                        self.printLine("Synchronized " + downloadCount + ". Downloaded " + newCount + ".");
                        renderRestoreMenu(saveList, dirtySaveList);
                      }
                    });
                  }
                });
              });
            });
          });
        });
      } else if (option.password) {
        clearScreen(function() {
          self.restore_password();
        });
      } else {
        if (option.cancel) {
          self.finished = false;
          if (typeof cancelLabel !== "undefined") {
            self["goto"](cancelLabel);
          }
          self.resetPage();
        } else {
          var state = option.state;
          var sceneName = null;
          if (state.stats && state.stats.sceneName) sceneName = (""+state.stats.sceneName).toLowerCase();
          var unrestorable = unrestorableScenes[sceneName];

          if (unrestorable) {
            asyncAlert(unrestorable);
            self.finished = false;
            self.resetPage();
            return;
          }

          saveCookie(function() {
            clearScreen(function() {
              restoreGame(state, null, /*userRestored*/true);
            });
          }, "", state.stats, state.temps, state.lineNum, state.indent, this.debugMode, this.nav);
        }
      }
    });
  }
  getDirtySaveList(function(dirtySaveList) {
    getSaves(function(saveList) {
      renderRestoreMenu(saveList, dirtySaveList);
    });
  });
};

Scene.prototype.restore_password = function restore_password() {
  var alreadyFinished = this.finished;
  this.finished = true;
  this.paragraph();
  this.printLine('Please paste your password here, then press "Next" below to continue.');
  this.prevLine = "text";
  this.paragraph();
  var self = this;
  var unrestorableScenes = this.parseRestoreGame(alreadyFinished);
  getPassword(this.target, function (cancel, password) {
    if (cancel) {
      self.finished = false;
      self.resetPage();
      return;
    }
    password = password.replace(/\s/g, "");
    password = password.replace(/^.*BEGINPASSWORD-----/, "");
    var token = self.deobfuscatePassword(password);
    token = token.replace(/^[^\{]*/, "");
    token = token.replace(/[^\}]*$/, "");
    var state;
    try {
      state = jsonParse(token);
    } catch (e) {
      asyncAlert("Sorry, that password was invalid. Please contact " + getSupportEmail() + " for assistance. Be sure to include your password in the email.");
      return;
    }

    var sceneName = null;
    if (state.stats && state.stats.sceneName) sceneName = (""+state.stats.sceneName).toLowerCase();

    var unrestorable = unrestorableScenes[sceneName];
    if (unrestorable) {
      asyncAlert(unrestorable);
      self.finished = false;
      self.resetPage();
      return;
    }

    saveCookie(function() {
      clearScreen(function() {
        // we're going to pretend not to be user restored, so we get reprompted to save
        restoreGame(state, null, /*userRestored*/false);
      });
    }, "", state.stats, state.temps, state.lineNum, state.indent, this.debugMode, this.nav);
  });
  if (alreadyFinished) printFooter();
};

Scene.prototype.parseRestoreGame = function parseRestoreGame(alreadyFinished) {
    if (alreadyFinished) {
      // if we're already finished, the printLoop bumped us an extra line ahead
      this.lineNum--;
      this.rollbackLineCoverage();
    }
    // nextIndent: the level of indentation after the current line
    var nextIndent = null;
    var unrestorableScenes = {};
    var line;
    var startIndent = this.indent;
    while(isDefined(line = this.lines[++this.lineNum])) {
        if (!trim(line)) {
            this.rollbackLineCoverage();
            continue;
        }
        var indent = this.getIndent(line);
        if (nextIndent === null || nextIndent === undefined) {
            // initialize nextIndent with whatever indentation the line turns out to be
            // ...unless it's not indented at all
            if (indent > startIndent) {
                this.indent = nextIndent = indent;
            }
        }
        if (indent <= startIndent) {
            // it's over!
            if (!alreadyFinished) {
              this.lineNum--;
              this.rollbackLineCoverage();
            }
            return unrestorableScenes;
        }
        if (indent != this.indent) {
            // all chart rows are supposed to be at the same indentation level
            // anything at the wrong indentation level might be a mis-indented title/definition
            // or just a typo
            throw new Error(this.lineMsg() + "invalid indent, expected "+this.indent+", was " + indent);
        }

        //
        // *restore_game
        //   ending You can't restore to the ending.

        line = trim(line);
        var result = /^(\w+)\s+(.*)/.exec(line);
        if (!result) throw new Error(this.lineMsg() + "invalid line; this line should have a scene name followed by an error message: " + line);
        var sceneName = result[1].toLowerCase();
        var error = trim(result[2]);
        unrestorableScenes[sceneName] = error;
    }
    if (!alreadyFinished) {
      this.lineNum--;
      this.rollbackLineCoverage();
    }
    return unrestorableScenes;
};

Scene.prototype.check_registration = function scene_checkRegistration() {
  if (typeof window == "undefined" || typeof isRegistered == "undefined") return;
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  isRegistered(function() {
    self.finished = false;
    self.skipFooter = false;
    self.execute();
  });
};

Scene.prototype.login = function scene_login(optional) {
  if (typeof window == "undefined" || typeof loginForm == "undefined") return;
  optional = trim(optional);
  if (optional) {
    if (optional != "optional") throw new Error(this.lineMsg() + "invalid *login option: " + optional);
    optional = 1;
  }
  var self = this;
  this.finished = true;
  this.skipFooter = true;
  this.paragraph();
  var target = this.target;
  if (!target) target = document.getElementById('text');
  loginForm(target, optional, null, function() {
    clearScreen(function() {
      self.finished = false;
      self.prevLine = "empty";
      self.screenEmpty = true;
      self.execute();
    });
  });
};

Scene.prototype.save_game = function save_game(destinationSceneName) {
  if (!destinationSceneName) throw new Error(this.lineMsg()+"*save_game requires a destination file name, e.g. *save_game Episode2");
  if (this.temps.choice_user_restored) return;
  var self = this;
  this.finished = true;
  this.skipFooter = true;
  fetchEmail(function(defaultEmail){
    self.paragraph();
    var form = document.createElement("form");
    setClass(form, "saveGame");

    form.action="#";

    var message = document.createElement("div");
    message.style.color = "red";
    message.style.fontWeight = "bold";
    form.appendChild(message);

    var saveName = document.createElement("input");
    saveName.type="text";
    saveName.name="saveName";
    saveName.setAttribute("placeholder", "Type a name for your saved game");
    saveName.setAttribute("style", "display:block; font-size: 25px; width: 90%; margin: 1rem 0");
    form.appendChild(saveName);

    var hideEmailForm = false;
    // hideEmailForm = _global.automaticCloudStorage;
    if (!hideEmailForm) {
      println("Please login to the choiceofgames.com save system with your email address below.", form);

      var emailInput = document.createElement("input");
      // This can fail on IE
      try { emailInput.type="email"; } catch (e) {}
      emailInput.name="email";
      emailInput.value=defaultEmail;
      emailInput.setAttribute("placeholder", "you@example.com");
      emailInput.setAttribute("style", "display:block; font-size: 25px; width: 90%; margin: 1rem 0");
      form.appendChild(emailInput);

      var subscribeLabel = document.createElement("label");
      subscribeLabel.setAttribute("for", "subscribeBox");
      var subscribeBox = document.createElement("input");
      subscribeBox.type = "checkbox";
      subscribeBox.name = "subscribe";
      subscribeBox.setAttribute("id", "subscribeBox");
      subscribeBox.setAttribute("checked", true);
      subscribeLabel.appendChild(subscribeBox);
      subscribeLabel.appendChild(document.createTextNode("Email me when new games are available."));
      form.appendChild(subscribeLabel);
    }

    var target = this.target;
    if (!target) target = document.getElementById('text');
    target.appendChild(form);
    printButton("Next", form, true);

    printButton("Cancel", target, false, function() {
      clearScreen(function() {
        self.finished = false;
        self.prevLine = "empty";
        self.screenEmpty = true;
        self.execute();
      });
    });

    form.onsubmit = function(e) {
      preventDefault(e);
      safeCall(this, function() {
        var messageText;
        if (!trim(saveName.value)) {
          messageText = document.createTextNode("Please type a name for your saved game.");
          message.innerHTML = "";
          message.appendChild(messageText);
          return;
        }

        var slot = "save" + new Date().getTime();
        // create a clone stats object whose scene name is the destination scene
        var saveStats = {};
        for (var stat in self.stats) {
          if ("scene" == stat) continue;
          saveStats[stat] = self.stats[stat];
        }
        saveStats.scene = {name:destinationSceneName};

        if (hideEmailForm) {
          clearScreen(function() {
            saveCookie(function() {
              recordSave(slot, function() {
                self.finished = false;
                self.prevLine = "empty";
                self.screenEmpty = true;
                self.execute();
              });
            }, slot, saveStats, {choice_reuse:"allow", choice_user_restored:true, choice_restore_name:saveName.value}, 0, 0, false, self.nav);
          });
          return;
        }

        var shouldSubscribe = subscribeBox.checked;
        var subscribe = shouldSubscribe && window.isHeartsChoice ? "hc" : "cog";
        var email = trim(emailInput.value);
        if (!/^\S+@\S+\.\S+$/.test(email)) {
          messageText = document.createTextNode("Sorry, \""+email+"\" is not an email address.  Please type your email address again.");
          message.innerHTML = "";
          message.appendChild(messageText);
          return;
        }

        recordEmail(email, function() {
          clearScreen(function() {
            saveCookie(function() {
              recordSave(slot, function() {
                startLoading();
                submitRemoteSave(slot, email, subscribe, function(ok) {
                  doneLoading();
                  if (!ok) {
                    asyncAlert("Couldn't upload your saved game to choiceofgames.com. You can try again later from the Restore menu.", function() {
                      self.finished = false;
                      self.prevLine = "empty";
                      self.screenEmpty = true;
                      self.execute();
                    });
                  } else {
                    self.finished = false;
                    self.prevLine = "empty";
                    self.screenEmpty = true;
                    self.execute();
                  }
                });
              });
            }, slot, saveStats, {choice_reuse:"allow", choice_user_restored:true, choice_restore_name:saveName.value}, 0, 0, false, self.nav);
          });
        });
      });
    };

    printFooter();
  });
};

Scene.prototype.show_password = function show_password() {
  if (this.temps.choice_user_restored) return;
  this.paragraph();
  if (typeof(window) != "undefined" && !window.isMobile) {
    this.printLine('Please copy and paste the password in a safe place, then press "Next" below to continue.');
    println("", this.target);
    println("", this.target);
  }
  var password = computeCookie(this.stats, this.temps, this.lineNum, this.indent);
  password = this.obfuscate(password);
  showPassword(this.target, password);
  this.prevLine = "block";
};

Scene.prototype.obfuscate = function obfuscate(password) {
  var self = this;
  return password.replace(/./g,
    function(x) {
      var y = self.obfuscator[x];
      return y;
    }
  );
};

// The obfuscator must take US-ASCII and obfuscate it
// for use in a password.  This password will be sent via
// HTML email and its whitespace handling will be unpredictable,
// So we can't output any of these characters: [ <>&]
// Since we're losing four characters of output, we JSON-escape
// four characters of input [^`|~].
Scene.prototype.obfuscator = {
  " ": "k",
  "!": "E",
  "\"": "`",
  "#": "\\",
  "$": "r",
  "%": "J",
  "&": "o",
  "'": "0",
  "(": "Z",
  ")": "M",
  "*": "G",
  "+": "t",
  ",": "Y",
  "-": "f",
  ".": "2",
  "/": "!",
  "0": "i",
  "1": "*",
  "2": "1",
  "3": "3",
  "4": "[",
  "5": "6",
  "6": "v",
  "7": "\"",
  "8": "F",
  "9": "9",
  ":": "{",
  ";": "Q",
  "<": "?",
  "=": "5",
  ">": "#",
  "?": "K",
  "@": "/",
  "A": "=",
  "B": "N",
  "C": "z",
  "D": "$",
  "E": "W",
  "F": "(",
  "G": ")",
  "H": "q",
  "I": "C",
  "J": "+",
  "K": "U",
  "L": ".",
  "M": "H",
  "N": "B",
  "O": "S",
  "P": "X",
  "Q": "I",
  "R": "-",
  "S": "m",
  "T": "D",
  "U": "^",
  "V": "A",
  "W": "a",
  "X": "y",
  "Y": ",",
  "Z": "d",
  "[": "O",
  "\\": "s",
  "]": "8",
  "^": "sVii6h",
  "_": "]",
  "`": "sViivi",
  "a": "4",
  "b": "g",
  "c": "%",
  "d": "w",
  "e": "h",
  "f": "n",
  "g": "b",
  "h": "7",
  "i": "x",
  "j": "~",
  "k": "_",
  "l": "l",
  "m": ":",
  "n": "c",
  "o": "L",
  "p": "j",
  "q": "u",
  "r": "R",
  "s": "}",
  "t": "p",
  "u": "V",
  "v": "P",
  "w": "'",
  "x": "T",
  "y": "|",
  "z": "@",
  "{": "e",
  "|": "sVii\"%",
  "}": ";",
  "~": "sVii\"h"
};
Scene.prototype.deobfuscator = {
  "k": " ",
  "E": "!",
  "`": "\"",
  "\\": "#",
  "r": "$",
  "J": "%",
  "o": "&",
  "0": "'",
  "Z": "(",
  "M": ")",
  "G": "*",
  "t": "+",
  "Y": ",",
  "f": "-",
  "2": ".",
  "!": "/",
  "i": "0",
  "*": "1",
  "1": "2",
  "3": "3",
  "[": "4",
  "6": "5",
  "v": "6",
  "\"": "7",
  "F": "8",
  "9": "9",
  "{": ":",
  "Q": ";",
  "?": "<",
  "5": "=",
  "#": ">",
  "K": "?",
  "/": "@",
  "=": "A",
  "N": "B",
  "z": "C",
  "$": "D",
  "W": "E",
  "(": "F",
  ")": "G",
  "q": "H",
  "C": "I",
  "+": "J",
  "U": "K",
  ".": "L",
  "H": "M",
  "B": "N",
  "S": "O",
  "X": "P",
  "I": "Q",
  "-": "R",
  "m": "S",
  "D": "T",
  "^": "U",
  "A": "V",
  "a": "W",
  "y": "X",
  ",": "Y",
  "d": "Z",
  "O": "[",
  "s": "\\",
  "8": "]",
  "]": "_",
  "4": "a",
  "g": "b",
  "%": "c",
  "w": "d",
  "h": "e",
  "n": "f",
  "b": "g",
  "7": "h",
  "x": "i",
  "~": "j",
  "_": "k",
  "l": "l",
  ":": "m",
  "c": "n",
  "L": "o",
  "j": "p",
  "u": "q",
  "R": "r",
  "}": "s",
  "p": "t",
  "V": "u",
  "P": "v",
  "'": "w",
  "T": "x",
  "|": "y",
  "@": "z",
  "e": "{",
  ";": "}"
};

Scene.prototype.deobfuscatePassword = function deobfuscatePassword(password) {
  var self = this;
  password = password.replace(/./g,
    function(x) {
      var y = self.deobfuscator[x];
      return y;
    }
  );
  return password;
};

Scene.prototype.stat_chart = function stat_chart() {
  this.paragraph();
  var rows = this.parseStatChart();
  var target = this.target;
  if (!target) target = document.getElementById('text');

  var barWidth = 0;
  var standardFontSize = 0;

  function fixFontSize(span1, span2) {
    if (!standardFontSize) {
      if (window.getComputedStyle) {
        standardFontSize = parseInt(getComputedStyle(document.body).fontSize, 10);
      } else if (document.body.currentStyle) {
        standardFontSize = parseInt(document.body.currentStyle.fontSize, 10);
      } else {
        standardFontSize = 16;
      }
    }
    if (!barWidth) barWidth = span1.parentNode.offsetWidth;
    var spanMaxWidth, biggestSpanWidth;
    if (span2) {
      spanMaxWidth = barWidth / 2 - 1; /* minus one as a fudge factor; why is this needed? */
      biggestSpanWidth = Math.max(span1.offsetWidth, span2.offsetWidth);
    } else {
      spanMaxWidth = barWidth;
      biggestSpanWidth = span1.offsetWidth;
    }

    if (biggestSpanWidth > spanMaxWidth) {
      var newSize = Math.floor(standardFontSize * spanMaxWidth / biggestSpanWidth);
      span1.parentNode.style.fontSize = newSize + "px";
      if (window.getComputedStyle) {
        // on Android, if the user is using non-standand styles, browser may try to ignore our font setting
        var actual = parseInt(getComputedStyle(span1).fontSize, 10);
        if (actual > newSize) {
          newSize *= newSize / actual;
          span1.parentNode.style.fontSize = newSize + "px";
        }
      }
    }

  }

  for (i = 0; i < rows.length; i++) {
    var row = rows[i];
    var type = row.type;
    var variable = row.variable;
    var value = this.evaluateExpr(this.tokenizeExpr(variable));
    var label = this.replaceVariables(row.label);
    var definition = this.replaceVariables(row.definition || "");

    var statWidth, div, span, statValue;
    if (type == "text") {
      div = document.createElement("div");
      setClass(div, "statText");
      span = document.createElement("span");
      if (trim(label) || trim(value)) {
        printx(label + ": " + value, span);
      } else {
        // unofficial line_break
        printx(" ", span);
      }
      div.appendChild(span);
      target.appendChild(div);
    } else if (type == "percent") {
      div = document.createElement("div");
      setClass(div, "statBar statLine");
      span = document.createElement("span");
      printx("\u00a0\u00a0"+label+": "+value+"%", span);
      div.appendChild(span);
      statValue = document.createElement("div");
      setClass(statValue, "statValue");
      statValue.style.width = value+"%";
      statValue.innerHTML = "&nbsp;";
      div.appendChild(statValue);
      target.appendChild(div);
      fixFontSize(span);
    } else if (type == "opposed_pair") {
      div = document.createElement("div");
      setClass(div, "statBar statLine opposed");
      span0 = document.createElement("span");
      printx("\u00a0\u00a0"+label+": "+value+"% ", span0);
      div.appendChild(span0);
      span = document.createElement("span");
      span.setAttribute("style", "float: right");
      printx(this.replaceVariables(row.opposed_label)+": "+(100-value)+"%\u00a0\u00a0", span);
      div.appendChild(span);
      statValue = document.createElement("div");
      setClass(statValue, "statValue");
      statValue.style.width = value+"%";
      statValue.innerHTML = "&nbsp;";
      div.appendChild(statValue);
      target.appendChild(div);
      fixFontSize(span0, span);
    } else {
      throw new Error("Bug! Parser accepted an unknown row type: " + type);
    }
  }
  this.prevLine = "block";
  this.screenEmpty = false;
};

Scene.prototype.parseStatChart = function parseStatChart() {
    // nextIndent: the level of indentation after the current line
    var nextIndent = null;
    var rows = [];
    var line, line1, line2, line2indent;
    var startIndent = this.indent;
    while(isDefined(line = this.lines[++this.lineNum])) {
        if (!trim(line)) {
            this.rollbackLineCoverage();
            continue;
        }
        var indent = this.getIndent(line);
        if (nextIndent === null || nextIndent === undefined) {
            // initialize nextIndent with whatever indentation the line turns out to be
            // ...unless it's not indented at all
            if (indent <= startIndent) {
                throw new Error(this.lineMsg() + "invalid indent, expected at least one row");
            }
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) {
            // it's over!
            this.rollbackLineCoverage();
            this.lineNum = this.previousNonBlankLineNum();
            this.rollbackLineCoverage();
            return rows;
        }
        if (indent != this.indent) {
            // all chart rows are supposed to be at the same indentation level
            // anything at the wrong indentation level might be a mis-indented title/definition
            // or just a typo
            throw new Error(this.lineMsg() + "invalid indent, expected "+this.indent+", was " + indent);
        }

        //
        // *stat_chart
        //   text wounds Wounds
        //     Definition
        //   percent Infamy Infamy
        //     Definition
        //   opposed_pair brutality
        //     Brutality
        //       Strength and cruelty
        //     Finesse
        //       Precision and aerial maneuverability
        //

        // TODO opposed_pair
        // TODO definitions
        // TODO variable substitutions
        // TODO *if/*else
        // TODO *line_break
        line = trim(line);
        var result = /^(text|percent|opposed_pair)\s+(.*)/.exec(line);
        if (!result) throw new Error(this.lineMsg() + "invalid line; this line should start with 'percent', 'text', or 'opposed_pair'");
        var type = result[1].toLowerCase();
        var data = trim(result[2]);
        if ("opposed_pair" == type) {
          this.getVar(data);
          line1 = this.lines[++this.lineNum];
          this.replaceVariables(line1);
          line1indent = this.getIndent(line1);
          if (line1indent <= this.indent) throw new Error(this.lineMsg() + "invalid indent; expected at least one indented line to indicate opposed pair name. indent: " + line1indent + ", expected greater than " + this.indent);
          line2 = this.lines[this.lineNum + 1];
          line2indent = this.getIndent(line2);
          if (line2indent <= this.indent) {
            // line1 was the only line
            rows.push({type: type, variable: data, label: data, opposed_label: trim(line1)});
          } else {
            this.lineNum++;
            this.replaceVariables(line2);
            if (line2indent == line1indent) {
              // two lines: first label, second label
              rows.push({type: type, variable: data, label: trim(line1), opposed_label: trim(line2)});
            } else if (line2indent > line1indent) {
              // line 2 is a definition; therefore the opposed_label and its definition must be on lines 3 and 4
              var line1definition = line2;
              var line3 = this.lines[++this.lineNum];
              this.replaceVariables(line3);
              var line3indent = this.getIndent(line3);
              if (line3indent != line1indent) throw new Error(this.lineMsg() + "invalid indent; this line should be the opposing label name. expected " + line1indent + " was " + line3indent);
              var line4 = this.lines[++this.lineNum];
              this.replaceVariables(line4);
              var line4indent = this.getIndent(line4);
              if (line4indent != line2indent) throw new Error(this.lineMsg() + "invalid indent; this line should be the opposing label definition. expected " + line2indent + " was " + line4indent);
              rows.push({type: type, variable: data, label: trim(line1), definition:trim(line2), opposed_label: trim(line3), opposed_definition: trim(line4)});
            } else {
              throw new Error(this.lineMsg() + "invalid indent; expected a second line with indent " + line1indent + " to match line " + this.lineNum + ", or else no more opposed_pair lines");
            }
          }
        } else {
          var variable, label;
          if (!/ /.test(data)) {
            variable = data;
            label = data;
          } else if (/^\(/.test(data)) {
            var parens = 0;
            var closingParen = -1;
            for (var i = 1; i < data.length; i++) {
              var c = data.charAt(i);
              if (c === "(") {
                parens++;
              } else if (c === ")") {
                if (parens) {
                  parens--;
                } else {
                  closingParen = i;
                  break;
                }
              }
            }
            if (closingParen == -1) {
              throw new Error(this.lineMsg() + "missing closing parenthesis");
            }
            variable = data.substring(1, closingParen);
            label = trim(data.substring(closingParen+1))
            if (label === "") {
              label = variable;
            }
          } else {
            result = /^(\S+) (.*)/.exec(data);
            if (!result) throw new Error(this.lineMsg() + "Bug! can't find a space when a space was found");
            variable = result[1];
            label = result[2];
          }
          this.evaluateExpr(this.tokenizeExpr(variable));
          this.replaceVariables(label);
          line2 = this.lines[this.lineNum + 1];
          line2indent = this.getIndent(line2);
          if (line2indent <= this.indent) {
            // No definition line
            rows.push({type: type, variable: variable, label: label});
          } else {
            this.lineNum++;
            this.replaceVariables(line2);
            rows.push({type: type, variable: variable, label: label, definition: trim(line2)});
          }
        }
    }
    return rows;
};

// *timer Dec 25, 2016 9:30:00 PDT
Scene.prototype.timer = function(dateString) {
  var end;
  if (dateString == "release") {
    if (typeof window === "undefined" || !window.releaseDate) return;
    end = window.releaseDate/1000;
  } else {
    end = Date.parse(dateString)/1000;
  }
  var now = new Date()/1000;
  if (now < end) {
    var target = this.target;
    if (!target) {
      target = document.createElement("p");
      document.getElementById('text').appendChild(target);
    }
    var self = this;
    showTicker(target, end, function() {
      clearScreen(loadAndRestoreGame());
    });
  }
}

// *delay_break 1200
Scene.prototype.delay_break = function(durationInSeconds) {
  if (isNaN(durationInSeconds * 1)) throw new Error(this.lineMsg() + "invalid duration");
  this.finished = true;
  this.skipFooter = true;
  var target = this.target;
  if (!target) {
    target = document.createElement("p");
    document.getElementById('text').appendChild(target);
  }
  this.paragraph();
  var self = this;
  delayBreakStart(function(delayStart) {
    window.blockRestart = true;
    var endTimeInSeconds = durationInSeconds * 1 + delayStart * 1;
    showTicker(target, endTimeInSeconds, function() {
      printButton("Next", target, false, function() {
        delayBreakEnd();
        self.finished = false;
        self.resetPage();
      });
    });
    printFooter();
  });
};

// *delay_ending 1200 $2.99 $0.99
Scene.prototype.delay_ending = function(data) {
  // Steam doesn't do delay breaks and especially not skiponce
  if (typeof window != "undefined" && !!window.isSteamApp) {
    return this.ending();
  }
  var args = data.split(/ /);
  var durationInSeconds = args[0];
  var fullPriceGuess = args[1];
  var singleUsePriceGuess = args[2];
  if (isNaN(durationInSeconds * 1)) throw new Error(this.lineMsg() + "invalid duration");
  if (!/^\$/.test(fullPriceGuess)) throw new Error(this.lineMsg() + "invalid fullPriceGuess: \""+fullPriceGuess+"\"");
  if (singleUsePriceGuess && !/^\$/.test(singleUsePriceGuess)) throw new Error(this.lineMsg() + "invalid singleUsePriceGuess: \""+singleUsePriceGuess+"\"");
  this.finished = true;
  this.skipFooter = true;
  var self = this;
  checkPurchase("adfree", function(ok, result) {
    if (result.adfree || !result.billingSupported) {
      self.ending();
      return;
    }
    getPrice("adfree", function (fullPrice) {
      if (fullPrice == "guess") fullPrice = fullPriceGuess;
      getPrice("skiponce", function (singleUsePrice) {
        if (singleUsePrice == "guess") singleUsePrice = singleUsePriceGuess;

        options = [];
        var finishedWaiting = {name: "Play again after a short wait. ", unselectable: true};
        options.push(finishedWaiting);
        var upgradeSkip = {name: "Upgrade to the unlimited version for " + fullPrice + " to skip the wait forever."};
        options.push(upgradeSkip);
        var skipOnce = {name: "Skip the wait one time for " + singleUsePrice + "."};
        if (singleUsePriceGuess) options.push(skipOnce);
        var restorePurchasesOption = {name: "Restore purchases from another device."};
        if (isRestorePurchasesSupported()) options.push(restorePurchasesOption);
        var playMoreGames = {name: "Play more games like this."};
        options.push(playMoreGames);
        var emailMe = {name: "Email me when new games are available."};
        options.push(emailMe);

        function restartNow() {
          window.blockRestart = false;
          restartGame();
        }

        self.paragraph();
        printOptions([""], options, function(option) {
          if (option == playMoreGames) {
            self.more_games("now");
            if (typeof curl != "undefined") curl();
          } else if (option == emailMe) {
            subscribeLink();
          } else if (option == upgradeSkip) {
            purchase("adfree", restartNow);
          } else if (option == skipOnce) {
            purchase("skiponce", restartNow);
          } else if (option == restorePurchasesOption) {
            restorePurchases("adfree", function() {
              clearScreen(loadAndRestoreGame);
            });
          } else {
            return restartGame();
          }
        });

        var target = document.querySelector(".choice label");

        delayBreakStart(function(delayStart) {
          window.blockRestart = true;
          var endTimeInSeconds = durationInSeconds * 1 + delayStart * 1;
          showTicker(target, endTimeInSeconds, function() {
            clearScreen(function() {
              self.ending();
            });
          });
          printFooter();
        });
      });
    });
  });

};

// *if booleanExpr
// execute different code depending on whether the booleanExpr is true or false
//
// Examples:
// *if bool-expression
//     blah
//     blah
// *elseif bool-expression
//     blah
//     blah
// *else
//     blah
//     blah
// bool-expression
//     by reference
//         *set foo true
//         *if foo ...
//     equality
//         foo=2
//         foo="blah"
//         2="2"
//             true
//     inequality
//         foo>2
//         foo<2
//         foo<=2
//         foo>=2
//     and/or logic, parentheses mandatory
//         (foo=2) or (foo=3)
//         ((foo>4) and (foo<8)) or (bar=0)
//
// NOTE: *if commands may be used inside *choices, to make some choices conditionally available
Scene.prototype["if"] = function scene_if(line) {
    var stack = this.tokenizeExpr(line);
    var result = this.evaluateExpr(stack);
    if (this.debugMode) println(line + " :: " + result);
    result = bool(result, this.lineNum+1);
    if (result) {
        // "true" branch, just go on to the next line
        this.indent = this.getIndent(this.nextNonBlankLine());
    } else {
        // "false" branch; skip over the true branch
        this.skipTrueBranch(false);
    }
};

// TODO Rename this function to just skipBranch
Scene.prototype.skipTrueBranch = function skipTrueBranch(inElse) {
  var startIndent = this.indent;
  var nextIndent = null;
  while (isDefined(line = this.lines[++this.lineNum])) {
      this.rollbackLineCoverage();
      if (!trim(line)) continue;
      var indent = this.getIndent(line);
      if (nextIndent === null || nextIndent === undefined) {
          if (indent <= startIndent) throw new Error(this.lineMsg() + "invalid indent, expected at least one line in 'if' true block");
          nextIndent = indent;
      }
      if (indent <= startIndent) {
          // true block is over
          var parsed = null;
          // check to see if this is an *else or *elseif
          if (indent == startIndent) parsed = /^\s*\*(\w+)(.*)/.exec(line);
          if (!parsed || inElse) {
              this.lineNum = this.previousNonBlankLineNum();
              this.rollbackLineCoverage();
              this.indent = indent;
              return;
          }
          var command = parsed[1].toLowerCase();
          var data = trim(parsed[2]);
          if ("else" == command) {
              if (data) {
                if (/^if\b/.test(data)) {
                  throw new Error(this.lineMsg() + "'else if' is invalid, use 'elseif'");
                }
                throw new Error(this.lineMsg() + "nothing should appear on a line after 'else': " + data);
              }
              this.lineNum = this.lineNum; // code coverage
              // go on to the next line
              this.indent = this.getIndent(this.nextNonBlankLine());
          } else if (/^else?if$/.test(command)) {
              this.lineNum = this.lineNum; // code coverage
              this["if"](data);
          } else if ("comment" == command) {
              continue;
          } else {
              this.lineNum = this.previousNonBlankLineNum();
              this.rollbackLineCoverage();
              this.indent = this.getIndent(this.nextNonBlankLine());
          }
          return;
      }
      if (indent < nextIndent) {
          // *if foo
          //      foo
          //    bar
          throw new Error(this.lineMsg() + "invalid indent, expected "+nextIndent+", was " + indent);
      }
  }
};

Scene.prototype["else"] = Scene.prototype.elsif = Scene.prototype.elseif = function scene_else(data, inChoice) {
    // Authors can avoid using goto to get out of an if branch with:  *set implicit_control_flow true
    // This avoids the error message at the end of the function.
    if (inChoice || this.stats["implicit_control_flow"]) {
      this.skipTrueBranch(true);
      return;
    }
    throw new Error(this.lineMsg() + "It is illegal to fall in to an *else statement; you must *goto or *finish before the end of the indented block.");
};

// break the string up into a stack of tokens, defined in Scene.tokens below
Scene.prototype.tokenizeExpr = function tokenizeExpr(str) {
    var stack = [];
    var tokenTypes = Scene.tokens;
    var tokenTypesLength = tokenTypes.length;
    var pos = 0;
    while (str) {
        var matched = false;
        for (var i = 0; i < tokenTypesLength; i++) {
            var tokenType = tokenTypes[i];
            var token = tokenType.test(str, this.lineNum+1, this);
            if (token) {
                matched = true;
                str = str.substr(token.length);
                pos += token.length;
                var item = {name:tokenType.name, value:token, pos:pos};
                if ("WHITESPACE" == tokenType.name) {
                    break;
                } else if ("CURLY_QUOTE" == tokenType.name) {
                  throw new Error(this.lineMsg()+"Invalid use of curly smart quote: " + token + "\nUse straight quotes \" instead")
                } else if ("FUNCTION" == tokenType.name) {
                  item.func = /^\w+/.exec(token)[0];
                }
                stack.push(item);
                break;
            }
        }
        if (!matched) throw new Error(this.lineMsg()+"Invalid expression, couldn't extract another token: " + str);
    }
    return stack;
};

// evaluate the stack of tokens
// parenthetical == true if we're evaluating a parenthetical expression
// all expressions consist of either a "singleton" value (2) or two values and one operator (2+2)
Scene.prototype.evaluateExpr = function evaluateExpr(stack, parenthetical) {
    if (!stack.length) {
        throw new Error(this.lineMsg() + "no expression specified");
    }
    var self = this;
    function getToken() {
        var token = stack.shift();
        if (!token) throw new Error(self.lineMsg() + "null token");
        return token;
    }

    var token, value1, value2, operator, result;

    value1 = this.evaluateValueToken(getToken(), stack);

    if (!stack.length) {
        if (parenthetical) {
            throw new Error(this.lineMsg() + "Invalid expression, expected " + parenthetical);
        }
        return value1;
    }

    token = getToken();

    if (parenthetical && parenthetical == token.name) {
        return value1;
    }

    // Since this isn't a singleton, it must be an operator
    operator = Scene.operators[token.value];
    if (!operator) {
      throw new Error(this.lineMsg() + "Invalid expression at char "+token.pos+", expected OPERATOR"+
        (parenthetical?" or " + parenthetical : "")+
        ", was: " + token.name + " [" + token.value + "]");
    }

    if (token.value === '%') {
      this.warning("this is a bare % sign, which should be replaced with %+, %-, or modulo if you're really advanced.");
      this.warning("For more details on modulo, see: https://forum.choiceofgames.com/t/21176");
    }

    if (!stack[0]) {
      throw new Error(this.lineMsg() + "Invalid expression at char "+token.pos+", expected something after a "+token.value);
    }

    if (stack[0].func == "auto") {
      value2 = this.autobalance(stack, token, value1);
    } else {
      value2 = this.evaluateValueToken(getToken(), stack);
    }

    // and do the operator
    result = operator(value1, value2, this.lineNum+1, this);

    if (parenthetical) {
        // expect close parenthesis
        if (stack.length) {
            token = getToken();
            if (parenthetical == token.name) {
                return result;
            } else {
                throw new Error(this.lineMsg() + "Invalid expression at char "+token.pos+", expected "+parenthetical+", was: " + token.name + " [" + token.value + "]");
            }
        } else {
            throw new Error(this.lineMsg() + "Invalid expression, expected " + parenthetical);
        }
    } else {
        // if not parenthetical, expect no more tokens
        if (stack.length) {
            token = getToken();
            throw new Error(this.lineMsg() + "Invalid expression at char "+token.pos+", expected no more tokens, found: " + token.name + " [" + token.value + "]");
        } else {
            return result;
        }
    }
    throw new Error(this.lineMsg() + "bug, how did I get here?");
};

// turn a number, string, or var token into its value
// or, if this is an open parenthesis, evaluate the parenthetical expression
Scene.prototype.evaluateValueToken = function evaluateValueToken(token, stack) {
    var name = token.name;
    var value;
    if ("OPEN_PARENTHESIS" == name) {
        return this.evaluateExpr(stack, "CLOSE_PARENTHESIS");
    } else if ("OPEN_CURLY" == name) {
        value = this.evaluateExpr(stack, "CLOSE_CURLY");
        return this.getVar(value);
    } else if ("FUNCTION" == name) {
        if (!this.functions[token.func]) throw new Error(this.lineMsg + "Unknown function " + token.func);
        value = this.evaluateExpr(stack, "CLOSE_PARENTHESIS");
        return this.functions[token.func].call(this, value);
    } else if ("NUMBER" == name) {
        return token.value;
    } else if ("STRING" == name) {
        // strip off the quotes and unescape backslashes
        return this.replaceVariables(token.value.slice(1,-1).replace(/\\(.)/g, "$1"));
    } else if ("VAR" == name) {
        var variable = String(token.value);
        while (stack.length && stack[0].name == "OPEN_SQUARE") {
          stack.shift();
          variable += "_" + this.evaluateExpr(stack, "CLOSE_SQUARE");
        }
        return this.getVar(variable);
    } else {
        throw new Error(this.lineMsg() + "Invalid expression at char "+token.pos+", expected NUMBER, STRING, VAR or PARENTHETICAL, was: " + name + " [" + token.value + "]");
    }
};

// turn a var token into its name, remove it from the stack
// or if it's a curly parenthesis, evaluate that
// or if it's an array expression, convert it into its raw underscore name
Scene.prototype.evaluateReference = function evaluateReference(stack, options) {
  var toLowerCase = true;
  if (options && options.hasOwnProperty("toLowerCase")) toLowerCase = !!options.toLowerCase;
  function findClosingBracket(stack, type, offset) {
    if (!offset) offset = 0;
    var opens = 0;
    var openType = "OPEN_"+type;
    var closeType = "CLOSE_"+type;
    for (var i = offset; i < stack.length; i++) {
      if (stack[i].name == openType) {
        opens++;
      } else if (stack[i].name == closeType) {
        if (opens) {
          opens--;
        } else {
          return i;
        }
      }
    }
    return -1;
  }
  function normalizeCase(name) {
    if (toLowerCase) {
      return String(name).toLowerCase();
    } else {
      return name;
    }
  }
  if (!stack.length) throw new Error(this.lineMsg()+"Invalid expression, expected a name");
  var name;
  if (stack[0].name === "OPEN_CURLY") {
    stack.shift();
    var closingCurly = findClosingBracket(stack, "CURLY");
    if (closingCurly == -1) throw new Error(this.lineMsg()+"Invalid expression, no closing curly bracket: " + data);
    name = this.evaluateExpr(stack.slice(0, closingCurly));
    stack.splice(0, closingCurly+1);
    return normalizeCase(name);
  } else if (stack[0].name === "NUMBER") {
    // you could have a label that's just a number
    name = stack[0].value;
    stack.shift();
    return name;
  } else {
    if (stack[0].name !== "VAR") throw new Error(this.lineMsg() + "Invalid expression; expected name, found " + stack[0].name + " at char " + stack[0].pos);
    name = String(stack[0].value);
    stack.shift();
    while(stack.length && stack[0].name == "OPEN_SQUARE") {
      var closingBracket = findClosingBracket(stack, "SQUARE", 1);
      if (closingBracket == -1) throw new Error(this.lineMsg()+"Invalid expression, no closing array bracket at char " + stack[1].pos);
      var index = this.evaluateExpr(stack.slice(1, closingBracket));
      name += "_" + index;
      stack.splice(0, closingBracket+1);
    }
    return normalizeCase(name);
  }
};

Scene.prototype.functions = {
  not: function(value) {
    return !bool(value, this.lineNum+1);
  },
  round: function(value) {
    if (isNaN(value*1)) throw new Error(this.lineMsg()+"round() value is not a number: " + value);
    return Math.round(value);
  },
  timestamp: function(value) {
    return Date.parse(value)/1000;
  },
  log: function(value) {
    if (isNaN(value*1)) throw new Error(this.lineMsg()+"log() value is not a number: " + value);
    return Math.log(value)/Math.log(10);
  },
  length: function(value) {
    return String(value).length;
  },
  auto: function() {
    throw new Error(this.lineMsg()+"Invalid expression, auto() must come after a < or > symbol");
  }
};

Scene.prototype.autobalance = function autobalance(stack, operatorToken, value) {
  if (operatorToken.name !== "INEQUALITY") {
    throw new Error(this.lineMsg()+"Invalid expression, auto() must come after a < or > symbol");
  }
  stack.shift(); // remove auto function

  if (stack.length < 4 ||
    stack[0].name !== "NUMBER" ||
    stack[1].name !== "COMMA" ||
    !(stack[2].name == "VAR" || stack[2].name == "NUMBER") ||
    stack[3].name !== "CLOSE_PARENTHESIS"
  ) {
    throw new Error(this.lineMsg()+"Invalid expression, auto() requires (percentage, id)");
  }
  var rateString = stack.shift().value;
  var rate = parseFloat(rateString);
  if (isNaN(rate) || rate < 1 || rate > 99) {
    throw new Error(this.lineMsg()+"the first auto() parameter should be a number between 1 and 99: " + rateString);
  }
  stack.shift(); // comma
  var id = stack.shift().value;
  stack.shift(); // close parenthesis
  var result = this.stats['auto' + '_' + this.name + '_' + id];
  if (typeof result != "undefined") {
    return result;
  } else if (this.recordBalance) {
    return this.recordBalance(value, operatorToken.value, rate, id);
  }
  return 50;
}

Scene.prototype.evaluateValueExpr = function evaluateValueExpr(expr) {
    var stack = this.tokenizeExpr(expr);
    var token = stack.shift();
    if (!token) throw new Error(this.lineMsg() + "null token");
    var value = this.evaluateValueToken(token, stack);
    if (stack.length) {
        token = stack.shift();
        if (!token) throw new Error(this.lineMsg() + "null token");
        throw new Error(this.lineMsg() + "Invalid expression at char "+token.pos+", expected no more tokens, found: " + token.name + " [" + token.value + "]");
    }
    return value;
};

Scene.prototype.goto_random_scene = function gotoRandomScene(data) {
  var parsed = this.parseGotoRandomScene(data);
  var allowReuseGlobally = /\ballow_reuse\b/.test(data);
  var allowNoSelection = /\ballow_no_selection\b/.test(data);
  var option = this.computeRandomSelection(Math.random(), parsed, allowReuseGlobally);

  if (option) {
    this.goto_scene(option.name);
  } else {
    if (allowNoSelection) {
      return;
    } else {
      throw new Error(this.lineMsg() + "No selectable scenes");
    }
  }

};

Scene.prototype.parseGotoRandomScene = function parseGotoRandomScene(data) {
    data = data || "";
    var directives = data.split(" ");
    var allowReuseGlobally = false;
    var allowNoSelection = false;
    for (var i = 0; i < directives; i++) {
      var directive = trim(directives[i]);
      if (!directive) continue;
      if (directive == "allow_reuse") {
        allowReuseGlobally = true;
      } else if (directive == "allow_no_selection") {
        allowNoSelection = true;
      } else {
        throw new Error(this.lineMsg() + "invalid command: '" + directive + "'");
      }
    }

    // nextIndent: the level of indentation after the current line
    var nextIndent = null;
    var options = [];
    var line;
    var startIndent = this.indent;
    while(isDefined(line = this.lines[++this.lineNum])) {
        if (!trim(line)) {
            this.rollbackLineCoverage();
            continue;
        }
        var indent = this.getIndent(line);
        if (nextIndent === null || nextIndent === undefined) {
            // initialize nextIndent with whatever indentation the line turns out to be
            // ...unless it's not indented at all
            if (indent <= startIndent) {
                throw new Error(this.lineMsg() + "invalid indent, expected at least one line in *goto_random_scene");
            }
            this.indent = nextIndent = indent;
        }
        if (indent <= startIndent) {
            // it's over!
            this.rollbackLineCoverage();
            this.lineNum--;
            this.rollbackLineCoverage();
            break;
        }
        if (indent != this.indent) {
            // all chart rows are supposed to be at the same indentation level
            // anything at the wrong indentation level might be a mis-indented title/definition
            // or just a typo
            throw new Error(this.lineMsg() + "invalid indent, expected "+this.indent+", was " + indent);
        }
        line = trim(line);

        var option = {allowReuse:allowReuseGlobally};
        var command;
        while(!!(command = /^\*(\S+)/.exec(line))) {
          command = command[1];
          if ("allow_reuse" == command) {
            option.allowReuse = true;
            line = trim(line.substring("*allow_reuse".length));
            command = /^\*(\S+)/.exec(line);
            continue;
          } else if ("if" == command) {
            var conditional = /^\*if\s+\((.+)\)\s+([^\)]+)/.exec(line);
            if (!conditional) throw new Error(this.lineMsg() + " invalid *if, expected () followed by scene name: " + line);
            line = conditional[2];
            var stack = this.tokenizeExpr(conditional[1]);
            this.evaluateExpr(stack);
            option.conditional = conditional[1];
          } else {
            throw new Error(this.lineMsg() + " invalid command: " + line);
          }
        }
        // TODO weights
        option.name = trim(line);
        options.push(option);
    }
    return options;
};

Scene.prototype.computeRandomSelection = function computeRandomSelection(randomFloat, options, allowReuseGlobally) {
  var filtered = [];
  var finished = {};
  if (!allowReuseGlobally) {
    if (!this.stats.choice_grs) this.stats.choice_grs = [];
  }
  var grs = this.stats.choice_grs;
  for (var i = 0; i < grs.length; i++) {
    finished[grs[i]] = 1;
  }
  var option;
  for (i = 0; i < options.length; i++) {
    option = options[i];
    if (!option.allowReuse) {
      if (finished[option.name]) continue;
    }
    if (option.conditional) {
      var stack = this.tokenizeExpr(option.conditional);
      var pass = this.evaluateExpr(stack);
      if (!pass) continue;
    }
    filtered.push(option);
  }
  if (!filtered.length) return null;
  // TODO weights
  var randomSelection = Math.floor(randomFloat*filtered.length);
  option = filtered[randomSelection];
  if (!option.allowReuse) {
    this.stats.choice_grs.push(option.name);
  }
  return option;
};

Scene.prototype.end_trial = function endTrial() {
  this.paragraph();
  printLink(this.target, "#", "Start Over from the Beginning", function(e) {
    preventDefault(e);
    return restartGame("prompt");
  });
  this.prevLine = "block";
  this.screenEmpty = false;
  this.finished = true;
};

Scene.prototype.achieve = function scene_achieve(name) {
  name = name.toLowerCase();
  if (!this.nav.achievements.hasOwnProperty(name)) {
    throw new Error(this.lineMsg() + "the achievement name "+name+" was not declared as an *achievement in startup");
  }
  var achievement = this.nav.achievements[name];
  this.nav.achieved[name] = true;
  if (typeof window != "undefined" && typeof achieve != "undefined") {
    achieve(name, achievement.title, achievement.earnedDescription);
  }
};

Scene.prototype.check_achievements = function scene_checkAchievements() {
  var self = this;
  function callback(immediately) {
    for (var achievement in nav.achievements) {

      self.temps["choice_achieved_"+achievement] = nav.achieved.hasOwnProperty(achievement);
    }
    if (!immediately) {
      self.finished = false;
      self.skipFooter = false;
      self.execute();
    }
  }
  if (typeof checkAchievements == "undefined") {
    callback("immediately");
  } else {
    this.finished = true;
    this.skipFooter = true;
    checkAchievements(callback);
  }
};

Scene.prototype.scene_list = function scene_list() {
  var scenes = this.parseSceneList();
  this.nav.setSceneList(scenes);
};

Scene.prototype.parseSceneList = function parseSceneList() {
  var nextIndent = null;
  var scenes = [];
  var line;
  var startIndent = this.indent;
  while(isDefined(line = this.lines[++this.lineNum])) {
      if (!trim(line)) {
          this.rollbackLineCoverage();
          continue;
      }
      var indent = this.getIndent(line);
      if (nextIndent === null || nextIndent === undefined) {
          // initialize nextIndent with whatever indentation the line turns out to be
          // ...unless it's not indented at all
          if (indent <= startIndent) {
              throw new Error(this.lineMsg() + "invalid indent, expected at least one row");
          }
          this.indent = nextIndent = indent;
      }
      if (indent <= startIndent) {
          // it's over!
          this.rollbackLineCoverage();
          this.lineNum--;
          this.rollbackLineCoverage();
          return scenes;
      }
      if (indent != this.indent) {
          // all scenes are supposed to be at the same indentation level
          throw new Error(this.lineMsg() + "invalid indent, expected "+this.indent+", was " + indent);
      }

      line = trim(line);
      var purchaseMatch = /^\$(\w*)\s+(.*)/.exec(line);
      if (purchaseMatch) {
        line = purchaseMatch[2];
      }
      if (!scenes.length && "startup" != String(line).toLowerCase()) scenes.push("startup");
      scenes.push(line);
  }
  return scenes;
};

Scene.prototype.title = function scene_title(title) {
  if (typeof changeTitle != "undefined") {
    changeTitle(title);
  }
};

Scene.prototype.author = function scene_author(author) {
  if (typeof changeAuthor != "undefined") {
    changeAuthor(author);
  }
};

// *achievement name hidden|visible 100 Achievement Title
//     Earned description
//     Pre-earned description
Scene.prototype.achievement = function scene_achievement(data) {
  var parsed = /(\S+)\s+(\S+)\s+(\S+)\s+(.*)/.exec(data);
  if (!parsed) throw new Error(this.lineMsg() + "Invalid *achievement, requires short name, visibility, points, and display title: " + data);
  var achievementName = parsed[1];
  if (!/^[a-z][a-z0-9_]+$/.test(achievementName)) throw new Error(this.lineMsg()+"Invalid achievement name: " +achievementName);

  if (!this.parsedAnAchievment && Object.keys(this.nav.achievements).length > 0) {
    // blow away pre-existing mygame.js achievements
    this.nav.achievements = {};
    this.nav.achievementList = [];
    this.achievementTotal = 0;
    this.seenAchievementTitles = {};
  }

  this.parsedAnAchievment = true;

  if (this.nav.achievements.hasOwnProperty(achievementName)) {
    var preExisting = this.nav.achievements[achievementName];
    throw new Error(this.lineMsg()+"Achievement "+achievementName+" already defined on line " + this.nav.achievements[achievementName].lineNumber);
  }

  var lineNumber = this.lineNum+1;
  var visibility = parsed[2];
  if (visibility != "hidden" && visibility != "visible") {
    throw new Error(this.lineMsg()+"Invalid *achievement, the second word should be either 'hidden' or 'visible': " +visibility);
  }
  var visible = (visibility != "hidden");
  var pointString = parsed[3];
  if (!/[1-9][0-9]*/.test(pointString)) {
    throw new Error(this.lineMsg()+"Invalid *achievement, the third word should be an integer number of points: " + pointString);
  }
  var points = parseInt(pointString, 10);
  if (points > 100) throw new Error(this.lineMsg()+"Invalid *achievement, no achievement may be worth more than 100 points: " + points);
  if (points < 1) throw new Error(this.lineMsg()+"Invalid *achievement, no achievement may be worth less than 1 point: " + points);
  if (!this.achievementTotal) this.achievementTotal = 0;
  this.achievementTotal += points;
  if (this.achievementTotal > 1000) {
    throw new Error(this.lineMsg()+"Invalid achievements. Adding " + points + " would add up to more than 1,000 points: " + this.achievementTotal);
  }
  var title = parsed[4];
  if (/(\$\{)/.test(title)) throw new Error(this.lineMsg()+"Invalid *achievement. ${} not permitted in achievement title: " + title);
  if (/(\@\{)/.test(title)) throw new Error(this.lineMsg()+"Invalid *achievement. @{} not permitted in achievement title: " + title);
  if (/(\[)/.test(title)) throw new Error(this.lineMsg()+"Invalid *achievement. [] not permitted in achievement title: " + title);
  if (title.length > 50) throw new Error(this.lineMsg()+"Invalid *achievement. Title must be 50 characters or fewer: " + title);

  // Get the description from the next indented line
  var line = this.lines[++this.lineNum];
  var indent = this.getIndent(line);
  if (!indent) {
    throw new Error(this.lineMsg()+"Invalid *achievement. An indented description is required.");
  }
  var preEarnedDescription = trim(line);
  if (/(\$\{)/.test(preEarnedDescription)) throw new Error(this.lineMsg()+"Invalid *achievement. ${} not permitted in achievement description: " + preEarnedDescription);
  if (/(\@\{)/.test(preEarnedDescription)) throw new Error(this.lineMsg()+"Invalid *achievement. @{} not permitted in achievement description: " + preEarnedDescription);
  if (/(\[)/.test(preEarnedDescription)) throw new Error(this.lineMsg()+"Invalid *achievement. [] not permitted in achievement description: " + preEarnedDescription);
  if (preEarnedDescription.length > 200) throw new Error(this.lineMsg()+"Invalid *achievement. Pre-earned description must be 200 characters or fewer: " + preEarnedDescription);

  if (!visible) {
    if (preEarnedDescription.toLowerCase() != "hidden") throw new Error(this.lineMsg()+"Invalid *achievement. Hidden achievements must set their pre-earned description to 'hidden'.");
  }

  // Optionally get a post-earned description from the next line
  var postEarnedDescription = null;
  while(isDefined(line = this.lines[++this.lineNum])) {
    if (trim(line)) break;
    this.rollbackLineCoverage();
  }
  indent = this.getIndent(line);
  if (indent) {
    postEarnedDescription = trim(line);
    if (/(\$\{)/.test(postEarnedDescription)) throw new Error(this.lineMsg()+"Invalid *achievement. ${} not permitted in achievement description: " + postEarnedDescription);
    if (/(\@\{)/.test(postEarnedDescription)) throw new Error(this.lineMsg()+"Invalid *achievement. @{} not permitted in achievement description: " + postEarnedDescription);
    if (/(\[)/.test(postEarnedDescription)) throw new Error(this.lineMsg()+"Invalid *achievement. [] not permitted in achievement description: " + postEarnedDescription);
    if (postEarnedDescription.length > 200) throw new Error(this.lineMsg()+"Invalid *achievement. Post-earned description must be 200 characters or fewer: " + postEarnedDescription);
  } else {
    // No indent means the next line is not a post-earned description
    this.rollbackLineCoverage();
    this.lineNum--;
    this.rollbackLineCoverage();
  }

  if (!postEarnedDescription) {
    if (!visible) throw new Error(this.lineMsg()+"Invalid *achievement. Hidden achievements must set a post-earned description.");
    postEarnedDescription = preEarnedDescription;
  }

  if (!this.nav.achievements.hasOwnProperty(achievementName)) {
    this.nav.achievementList.push(achievementName);
    if (this.nav.achievementList.length > 100) {
      throw new Error(this.lineMsg()+"Too many *achievements. Each game can have up to 100 achievements.");
    }
  }

  if (!this.seenAchievementTitles) this.seenAchievementTitles = {};

  if (this.seenAchievementTitles[title]) {
    throw new Error(this.lineMsg()+"An achievement with display title \"" + title + "\" was already defined at line " + this.seenAchievementTitles[title]);
  }

  this.seenAchievementTitles[title] = this.lineNum+1;

  this.nav.achievements[achievementName] = {
    visible: visible,
    points: points,
    title: title,
    earnedDescription: postEarnedDescription,
    preEarnedDescription: preEarnedDescription,
    lineNumber: lineNumber
  };

  if (typeof setButtonTitles != "undefined") setButtonTitles();
};


Scene.prototype.bug = function scene_bug(message) {
  if (message) {
    message = "Bug: " + this.replaceVariables(message);
  } else {
    message = "Bug";
  }
  throw new Error(this.lineMsg() + message);
};

Scene.prototype.warning = function scene_warning(message) {
  // quicktest implements this
}

Scene.prototype.feedback = function scene_feedback() {
  if (typeof window == "undefined" || this.randomtest) return;
  this.paragraph();
  this.printLine("On a scale from 1 to 10, how likely are you to recommend this game to a friend?");
  this.paragraph();
  var options = [{name:"10 (Most likely)"}];
  for (var i = 9; i > 1; i--) {
    options.push({name:i});
  }
  options.push({name:"1 (Least likely)"});
  options.push({name:"No response."});
  var self = this;
  this.renderOptions([""], options, function(option) {
    var value = "null";
    var numberMatch = /^(\d+)/.exec(option.name);
    if (numberMatch) value = numberMatch[1]*1;
    if (!window.storeName) {
      self.finished = false;
      self.resetPage();
      return;
    }

    var postFeedback = function() {
      xhrAuthRequest("POST", "feedback", function(ok, response) {
        if (window.console) console.log("ok", ok, response);
      }, "game", window.storeName, "platform", platformCode(), "rating", value);
      if (/^(9|10)/.test(option.name)) {
        if (isReviewSupported()) {
          return clearScreen(function() {
            self.printLine("Great! ");
            promptForReview();
            self.screenEmpty = false;
            self.prevLine = "text";
            self.page_break();
            printFooter();
          });
        }
      }
      self.finished = false;
      self.resetPage();
    }

    if (value == "null") {
      self.finished = false;
      self.resetPage();
      return;
    }

    isRegistered(function(registered) {
      if (registered) {
        postFeedback();
      } else {
        clearScreen(function() {
          loginForm(main, 1/*optional*/, "Please sign in to have your vote counted!", postFeedback);
        });
      }
    });
  });
  this.finished = true;
};

Scene.prototype.parseTrackEvent = function(data) {
  var event = {};
  var stack = this.tokenizeExpr(data);
  if (!stack.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at least two args: category and action");
  event.category = this.evaluateValueToken(stack.shift(), stack);
  if (!stack.length) throw new Error(this.lineMsg() + "Invalid track_event statement, expected at least two args: category and action");
  event.action = this.evaluateValueToken(stack.shift(), stack);
  if (stack.length) {
    event.label = this.evaluateValueToken(stack.shift(), stack);
    if (stack.length) {
      event.value = this.evaluateValueToken(stack.shift(), stack);
      if (stack.length) {
        throw new Error(this.lineMsg() + "Invalid track_event statement, expected at most four args: category, action, label, value");
      }
      var intValue = parseInt(event.value, 10);
      if (isNaN(intValue) || event.value != intValue || event.value.toString() != intValue.toString()) {
        throw new Error(this.lineMsg() + "Invalid track_event statement, value must be an integer: " + event.value);
      }
    }
  }
  return event;
}

Scene.prototype.track_event = function track_event(data) {
  var event = this.parseTrackEvent(data);
  if (typeof ga !== "undefined") {
    ga('send', 'event', event.category, event.action, event.label, event.value);
  }
}

Scene.prototype.ai = function ai(data) {}

Scene.prototype.config = function config(data) {
    var stack = this.tokenizeExpr(data);
    var variable = this.evaluateReference(stack);
    if ("undefined" === typeof this.temps[variable] && "undefined" === typeof this.stats[variable]) {
      throw new Error(this.lineMsg() + "Non-existent variable '"+variable+"'");
    }
    if (stack.length === 0) throw new Error(this.lineMsg()+"Invalid set instruction, no expression specified: " + line);
    var value = this.evaluateExpr(stack);
    this.setVar(variable, value);
    if ("undefined" !== typeof remoteConfig && !this.randomtest && !this.quicktest) {
      this.finished = true;
      this.skipFooter = true;
      var self = this;
      remoteConfig(variable, function(result) {
        if (result !== null) self.setVar(variable, result);
        self.finished = false;
        self.skipFooter = false;
        self.execute();
      })
    }
};

Scene.prototype.ifid = function ifid(id) {
  if (!/^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/.test(id)) {
    throw new Error(this.lineMsg() + "Invalid IFID. It should have five parts, like \"a0a0a0a0-a0a0-a0a0-a0a0-a0a0a0a0a0a0\: " + id);
  }
  if (!/^[A-F0-9\-]{36}$/i.test(id)) {
    throw new Error(this.lineMsg() + "Invalid IFID. It should contain only numbers, letters A-F, and dashes: " + id);
  }
}

Scene.prototype.lineMsg = function lineMsg() {
    return this.name + " line " + (this.lineNum+1) + ": ";
};

Scene.prototype.rollbackLineCoverage = function() {};

Scene.baseUrl = "scenes";
Scene.regexpMatch = function regexpMatch(str, re) {
    var result = re.exec(str);
    if (!result) return null;
    return result[0];
};
// Each token has a name and a test, which returns the matching string
Scene.tokens = [
    {name:"OPEN_PARENTHESIS", test:function(str){ return Scene.regexpMatch(str,/^\(/); } },
    {name:"CLOSE_PARENTHESIS", test:function(str){ return Scene.regexpMatch(str,/^\)/); } },
    {name:"OPEN_CURLY", test:function(str){ return Scene.regexpMatch(str,/^\{/); } },
    {name:"CLOSE_CURLY", test:function(str){ return Scene.regexpMatch(str,/^\}/); } },
    {name:"OPEN_SQUARE", test:function(str){ return Scene.regexpMatch(str,/^\[/); } },
    {name:"CLOSE_SQUARE", test:function(str){ return Scene.regexpMatch(str,/^\]/); } },
    {name:"FUNCTION", test:function(str){ return Scene.regexpMatch(str,/^(not|round|timestamp|log|length|auto)\s*\(/); } },
    {name:"NUMBER", test:function(str){ return Scene.regexpMatch(str,/^\d+(\.\d+)?\b/); } },
    {name:"STRING", test:function(str, line, sceneObj) {
            var i;
            if (!/^\"/.test(str)) return null;
            for (i = 1; i < str.length; i++) {
                var x = str.charAt(i);
                if ("\\" == x) {
                    i++;
                } else if ('"' == x) {
                    return str.substring(0,i+1);
                }
            }
            var errMessage = "line " + line + ": ";
            if (sceneObj) {
              errMessage = sceneObj.lineMsg();
            }
            throw new Error(errMessage+"Invalid string, open quote with no close quote: " + str);
        }
    },
    {name:"CURLY_QUOTE", test:function(str){ return Scene.regexpMatch(str,/^[\u201c\u201d]/); } },
    {name:"WHITESPACE", test:function(str){ return Scene.regexpMatch(str,/^\s+/); } },
    {name:"NAMED_OPERATOR", test:function(str){ return Scene.regexpMatch(str,/^(and|or|modulo)\b/); } },
    {name:"VAR", test:function(str){ return Scene.regexpMatch(str,/^\w*/); } },
    {name:"FAIRMATH", test:function(str){ return Scene.regexpMatch(str,/^%[\+\-]/); } },
    {name:"OPERATOR", test:function(str){ return Scene.regexpMatch(str,/^[\+\-\*\/\&\%\^\#]/); } },
    {name:"INEQUALITY", test:function(str){ return Scene.regexpMatch(str,/^[\!<>]\=?/); } },
    {name:"EQUALITY", test:function(str){ return Scene.regexpMatch(str,/^=/); } },
    {name:"COMMA", test:function(str){ return Scene.regexpMatch(str,/^,/); } }
    //
];
Scene.operators = {
    "+": function add(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) + num(v2,line,name); },
    "-": function subtract(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) - num(v2,line,name); },
    "*": function multiply(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) * num(v2,line,name); },
    "/": function divide(v1,v2,line,sceneObj) {
      var name = null; if (sceneObj) name = sceneObj.name; 
      v2 = num(v2, line, name);
      if (v2 === 0) throw new Error(name+" line "+line+": can't divide by zero");
      return num(v1,line,name) / num(v2,line,name);
    },
    "^": function exponent(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return Math.pow(num(v1,line,name), num(v2,line,name)); },
    "&": function concatenate(v1,v2) { return [v1,v2].join(""); },
    "#": function charAt(v1,v2,line,sceneObj) {
      var name = null;
      var errMessage = "line " + line + ": ";
      if (sceneObj) {
        name = sceneObj.name;
        errMessage = sceneObj.lineMsg();
      }
      var i = num(v2,line,name);
      if (i < 1) {
        throw new Error(errMessage+"There is no character at position " + i + "; the position must be greater than or equal to 1.");
      }
      if (i > String(v1).length) {
        throw new Error(errMessage+"There is no character at position " + i + ". \""+v1+"\" is only " + String(v1).length + " characters long.");
      }
      return String(v1).charAt(i-1);
    },
    "%+": function fairAdd(v1, v2, line, sceneObj) {
        var name = null;
        var errMessage = "line " + line + ": ";
        if (sceneObj) {
          name = sceneObj.name;
          errMessage = sceneObj.lineMsg();
        }
        v1 = num(v1,line,name);
        v2 = num(v2,line,name);
        var validValue = (v1 >= 0 && v1 <= 100);
        if (!validValue) {
            throw new Error(errMessage+"Can't fairAdd to non-percentile value: " + v1);
        }
        if (v2 > 0) {
          var multiplier = (100 - v1) / 100;
          var actualModifier = v2 * multiplier;
          var value = 1 * v1 + actualModifier;
          value = Math.floor(value);
          if (value > 99) value = 99;
          return value;
        } else {
          var multiplier = v1 / 100;
          var actualModifier = (0-v2) * multiplier;
          var value = v1 - actualModifier;
          value = Math.ceil(value);
          if (value < 1) value = 1;
          return value;
        }
    },
    "%-": function fairSubtract(v1, v2, line, sceneObj) {
        var name = null; if (sceneObj) name = sceneObj.name; 
        v2 = num(v2,line,name);
        return Scene.operators["%+"](v1,0-v2,line,sceneObj);
    },
    "=": function equals(v1,v2) { return v1 == v2 || String(v1) == String(v2); },
    "<": function lessThan(v1,v2,line,sceneObj) {
        var name = null; if (sceneObj) name = sceneObj.name; 
        return num(v1,line,name) < num(v2,line,name); },
    ">": function greaterThan(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) > num(v2,line,name); },
    "<=": function lessThanOrEquals(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) <= num(v2,line,name); },
    ">=": function greaterThanOrEquals(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) >= num(v2,line,name); },
    "!=": function notEquals(v1,v2) { return v1 != v2; },
    "and": function and(v1, v2, line, sceneObj) {
        var name = null; if (sceneObj) name = sceneObj.name; 
        return bool(v1,line,name) && bool(v2,line,name);
    },
    "or": function or(v1, v2, line, sceneObj) {
        var name = null; if (sceneObj) name = sceneObj.name; 
        return bool(v1,line,name) || bool(v2,line,name);
    },
    "modulo": function modulo(v1,v2,line,sceneObj) { var name = null; if (sceneObj) name = sceneObj.name; return num(v1,line,name) % num(v2,line,name); },
};

Scene.initialCommands = {"create":1,"scene_list":1,"title":1,"author":1,"comment":1,"achievement":1,"product":1,"ifid":1};

Scene.validCommands = {"comment":1, "goto":1, "gotoref":1, "label":1, "looplimit":1, "finish":1, "abort":1,
    "choice":1, "create":1, "temp":1, "delete":1, "set":1, "setref":1, "print":1, "if":1, "rand":1,
    "page_break":1, "line_break":1, "script":1, "else":1, "elseif":1, "elsif":1, "reset":1,
    "goto_scene":1, "fake_choice":1, "input_text":1, "ending":1, "share_this_game":1, "stat_chart":1,
    "subscribe":1, "show_password":1, "gosub":1, "return":1, "hide_reuse":1, "disable_reuse":1, "allow_reuse":1,
    "check_purchase":1,"restore_purchases":1,"purchase":1,"restore_game":1,"advertisement":1,
    "kindle_search":1,"kindle_product":1,"feedback":1,
    "save_game":1,"delay_break":1,"image":1,"kindle_image":1,"link":1,"input_number":1,"goto_random_scene":1,
    "restart":1,"more_games":1,"delay_ending":1,"end_trial":1,"login":1,"achieve":1,"scene_list":1,"title":1,
    "bug":1,"link_button":1,"check_registration":1,"sound":1,"author":1,"gosub_scene":1,"achievement":1,
    "check_achievements":1,"redirect_scene":1,"print_discount":1,"purchase_discount":1,"track_event":1,
    "timer":1,"youtube":1,"product":1,"text_image":1,"ai":1,"params":1,"config":1,"ifid":1
    };


;/*
 * Copyright 2010 by Dan Fabulich.
 * 
 * Dan Fabulich licenses this file to you under the
 * ChoiceScript License, Version 1.0 (the "License"); you may
 * not use this file except in compliance with the License. 
 * You may obtain a copy of the License at
 * 
 *  http://www.choiceofgames.com/LICENSE-1.0.txt
 * 
 * See the License for the specific language governing
 * permissions and limitations under the License.
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 */
function SceneNavigator(sceneList) {
    this.setSceneList(sceneList);
    this.startingStats = {implicit_control_flow:false};
}

SceneNavigator.prototype.setSceneList = function setSceneList(sceneList) {
    this._sceneList = sceneList;
    this._sceneMap = {};
    for (var i = 0; i < sceneList.length-1; i++) {
        var scene1 = sceneList[i];
        var scene2 = sceneList[i+1];
        this._sceneMap[scene1] = scene2;
    }
    this._startupScene = sceneList[0];
};

SceneNavigator.prototype.nextSceneName = function nextSceneName(currentSceneName) {
    var nextScene = this._sceneMap[currentSceneName];
    //if (!nextScene) throw new Error("No scene follows " + currentSceneName);
    return nextScene;
};

SceneNavigator.prototype.getStartupScene = function getStartupScene() {
    return this._startupScene;
};

SceneNavigator.prototype.setStartingStatsClone = function setStartingStatsClone(stats) {
  this.startingStats = {};
  for (var i in stats) {
    this.startingStats[i] = stats[i];
  }
};

SceneNavigator.prototype.resetStats = function resetStats(stats) {
  for (var i in stats) {
    delete stats[i];
  }
  for (i in this.startingStats) {
    stats[i] = this.startingStats[i];
  }
  this.bugLog = [];
};

SceneNavigator.prototype.repairStats = function repairStats(stats) {
  for (var i in this.startingStats) {
    var startingStat = this.startingStats[i];
    if (startingStat === null || startingStat === undefined) continue;
    if (typeof(stats[i]) === "undefined" || stats[i] === null) {
      stats[i] = this.startingStats[i];
    }
  }
};

SceneNavigator.prototype.bugLog = [];
SceneNavigator.prototype.achievements = {};
SceneNavigator.prototype.achievementList = [];
SceneNavigator.prototype.achieved = {};
SceneNavigator.prototype.products = {};

SceneNavigator.prototype.loadAchievements = function(achievementArray) {
  if (!achievementArray) return;
  this.achievements = {};
  this.achievementList = [];
  for (var i = 0; i < achievementArray.length; i++) {
    var achievement = achievementArray[i];
    var achievementName = achievement[0];
    var visible = achievement[1];
    var points = achievement[2];
    var title = achievement[3];
    var earnedDescription = achievement[4];
    var preEarnedDescription = achievement[5];
    this.achievements[achievementName] = {
      visible: visible,
      points: points,
      title: title,
      earnedDescription: earnedDescription,
      preEarnedDescription: preEarnedDescription
    };
    this.achievementList.push(achievementName);
  }
};
SceneNavigator.prototype.loadProducts = function(productArray, purchaseMap) {
  if (!productArray && !purchaseMap) return;
  this.products = {};
  for (var i = 0; i < productArray; i++) {
    this.products[productArray[i]] = {};
  }
  for (var scene in purchaseMap) {
    var product = purchaseMap[scene];
    this.products[product] = {};
  }
}


;/*
 * Copyright 2010 by Dan Fabulich.
 * 
 * Dan Fabulich licenses this file to you under the
 * ChoiceScript License, Version 1.0 (the "License"); you may
 * not use this file except in compliance with the License. 
 * You may obtain a copy of the License at
 * 
 *  http://www.choiceofgames.com/LICENSE-1.0.txt
 * 
 * See the License for the specific language governing
 * permissions and limitations under the License.
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.
 */

_global = typeof globalThis !== "undefined" ? globalThis : this;

(function() {
  var userAgent, url, protocol, appMeta;
  if (typeof window !== "undefined") {
    userAgent = navigator.userAgent;
    url = window.location.href;
    protocol = window.location.protocol;
    appMeta = window.document.querySelector("meta[name=apple-itunes-app]");
  }
  _global.isWebOS = /webOS/.test(userAgent);
  _global.isMobile = _global.isWebOS || /Mobile/.test(userAgent);
  _global.isFile = /^file:/.test(url);
  _global.isXul = /^chrome:/.test(url);
  try {
    _global.greenworks = require('greenworks');
    _global.isGreenworks = true;
  } catch (ignored) {}
  _global.isWinOldApp = false;
  try {
    isWinOldApp = window.external.IsWinOldApp();
  } catch (ignored) {}
  _global.isAndroid = /Android/.test(userAgent);
  _global.isOmnibusApp = /CoGnibus/.test(userAgent);
  _global.isIosApp = _global.isIosApp || (_global.isOmnibusApp && !_global.isAndroid);
  _global.isAndroidApp = _global.isAndroidApp || (_global.isOmnibusApp && _global.isAndroid);
  _global.isAmazonAndroidApp = _global.isAmazonAndroidApp || (_global.isAndroidApp && _global.flavor && _global.flavor.isAmazon());
  _global.isWeb = !_global.isIosApp && !_global.isAndroidApp && !_global.isWinOldApp && /^https?:/.test(url);
  _global.isSecureWeb = /^https:?$/.test(protocol);
  _global.isSafari = /Safari/.test(userAgent);
  _global.isIE = /(MSIE|Trident)/.test(userAgent);
  _global.isIPad = /iPad/.test(userAgent);
  _global.isIPhone = /iPhone/.test(userAgent);
  _global.isKindleFire = /Kindle Fire/.test(userAgent);
  _global.isWinStoreApp = "ms-appx:" == protocol;
  _global.isCef = !!_global.cefQuery;
  _global.isNode = typeof process !== "undefined";
  _global.isHeartsChoice = appMeta && /1487052276/.test(appMeta.getAttribute("content"))
})();

_global.loadTime = new Date().getTime();

function callIos(scheme, path) {
  if (!_global.isIosApp) return;
  if (typeof webkit !== "undefined" && webkit.messageHandlers) {
    return webkit.messageHandlers.choicescript.postMessage([scheme, path]);
  }
  if (path) {
    path = encodeURIComponent(path).replace(/[!~*')(]/g, function(match) {
      return "%" + match.charCodeAt(0).toString(16);
    });
  } else {
    path = "";
  }
  setTimeout(function() {
    var iframe = document.createElement("IFRAME");
    iframe.setAttribute("src", scheme + "://" + path);
    iframe.setAttribute("style", "display:none");
    document.documentElement.appendChild(iframe);
    iframe.parentNode.removeChild(iframe);
    iframe = null;
  }, 0);
}

function safeCall(obj, fn) {
    if (!fn) return;
    var isHeadless = typeof window == "undefined";
    var debug = false || (!isHeadless && window.debug);
    if (isIE || isHeadless) {
        // just call through; onerror will be called and debugger will handle it
        if (typeof MSApp != "undefined") {
            if (obj) {
                MSApp.execUnsafeLocalFunction(function () { fn.call(obj); });
            } else {
                MSApp.execUnsafeLocalFunction(fn);
            }
        } else if (obj) {
            fn.call(obj);
        } else {
            fn.call();
        }
    } else {
        try {
            if (obj) {
                fn.call(obj);
            } else {
                fn.call();
            }
        } catch (e) {
            if (e.message) {
              window.onerror(e.message, e.fileName, e.lineNumber, e.stack);
            } else if (e.stack) {
              window.onerror(e.stack, e.fileName, e.lineNumber, e.stack);
            } else {
              window.onerror(toJson(e, '\n'));
            }

            if (window.console) {
              window.console.error(e);
              if (e.message) window.console.error("Message: " + e.message);
              if (e.stack) window.console.error("Stack: " + e.stack);
            }
            // Rethrow here so the debugger can handle it
            // On Firefox this causes a second prompt.  Meh!
            if (debug) throw e;
        }
    }
}

function safeCallback(callback) {
  return function() {
    safeCall(null, callback);
  };
}

function safeTimeout(fn, time) {
  setTimeout(function() {
    safeCall(null, fn);
  }, time);
}

function isDefined(x) {
    return "undefined" !== typeof x;
}

function jsonStringifyAscii(obj) {
  var output = JSON.stringify(obj).replace(/(.)/g, function(x) {
    var code = x.charCodeAt(0);
    if (code > 127 || code < 32) {
     var outCode = code.toString(16);
     switch (outCode.length) {
       case 4:
         return "\\u" + outCode;
       case 3:
         return "\\u0" + outCode;
       case 2:
         return "\\u00" + outCode;
       case 1:
         return "\\u000" + outCode;
       default:
         return x;
     }
    }
    return x;
  });
  return output;
}

function toJson(obj, standardized) {
 if (typeof JSON != "undefined" && JSON.stringify) {
  return jsonStringifyAscii(obj);
 }
 switch (typeof obj) {
  case 'object':
   if (obj) {
    var list = [];
    if (obj instanceof Array) {
     for (var i=0;i < obj.length;i++) {
      list.push(toJson(obj[i], standardized));
     }
     return '[' + list.join(',') + ']';
    } else {
     for (var prop in obj) {
      if (prop == "scene") continue;
      if (!standardized && /^[a-zA-Z][a-zA-Z_0-9]\w+$/.test(prop) && !/\b(abstract|boolean|break|byte|case|catch|char|class|comment|const|continue|debugger|default|delete|do|double|else|enum|export|extends|false|final|finally|float|for|function|goto|if|implements|import|in|instanceof|int|interface|label|long|native|new|null|package|private|protected|public|return|short|static|super|switch|synchronized|this|throws|transient|true|try|typeof|var|void|volatile|while|with)\b/.test(prop)) {
        list.push(prop + ':' + toJson(obj[prop], standardized));
      } else {
        list.push('"' + prop + '":' + toJson(obj[prop], standardized));
      }
     }
     return '{' + list.join(',') + '}';
    }
   } else {
    return 'null';
   }
   break;
  case 'string':
   var encoded = obj.replace(/(.)/g, function(x) {
     if (x == "'" || x == '"' || x == '\\') {
       return "\\" + x;
     }
     var code = x.charCodeAt(0);
     if (code > 127 || code < 32) {
       var outCode = code.toString(16);
       switch (outCode.length) {
         case 4:
           return "\\u" + outCode;
         case 3:
           return "\\u0" + outCode;
         case 2:
           return "\\u00" + outCode;
         case 1:
           return "\\u000" + outCode;
         default:
           return x;
       }
     }
     return x;
   });
   return '"' + encoded + '"';
  case 'number':
  case 'boolean':
   return String(obj);
  case 'function':
   return 'badfunction';
  case 'undefined':
    return 'undefined';
  default:
   throw new Error("invalid type: " + typeof obj);
 }
}

var loginUrlBase = "https://www.choiceofgames.com/api/";
function xhrAuthRequest(method, endpoint, callback) {
  var paramBuilder = new Array(arguments.length*3);
  for (var i = 3; i < arguments.length; i=i+2) {
    if (i > 3) paramBuilder.push("&");
    paramBuilder.push(arguments[i]);
    paramBuilder.push("=");
    paramBuilder.push(arguments[i+1]);
  }
  var params = paramBuilder.join("");
  var xhr = findXhr();
  if (method == "POST") {
    xhr.open(method, loginUrlBase + endpoint + ".php", true);
    xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
  } else {
    xhr.open(method, loginUrlBase + endpoint + ".php?" + params, true);
  }

  var done = false;

  xhr.onreadystatechange = function() {
    if (done) return;
    if (xhr.readyState != 4) return;
    done = true;
    var ok = xhr.status == 200;
    var response = {};
    try {
      if (xhr.responseText) response = JSON.parse(xhr.responseText);
    } catch (e) {
      ok = false;
    }
    if (!ok) {
      if (!response.error) response.error = "unknown error";
      response.status = xhr.status;
    }
    if (callback) safeCall(null, function() {callback(ok, response);});
  };
  xhr.send(params);
}

function login(email, password, register, subscribe, callback) {
  xhrAuthRequest("POST", "login", callback, "email", encodeURIComponent(email), "password", encodeURIComponent(password), "register", register, "subscribe", subscribe);
}

function forgotPassword(email, callback) {
  xhrAuthRequest("POST", "forgot", callback, "email", encodeURIComponent(email));
}

function logout(callback) {
  document.cookie = 'login=0;path=/;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
  xhrAuthRequest("GET", "logout", callback);
  recordLogin(false);
  window.knownPurchases = null;
  window.registered = false;
  if (typeof FB != "undefined" && FB.logout) FB.logout();
  if (typeof gapi != "undefined" && gapi.auth && gapi.auth.signOut) gapi.auth.signOut();
}

function recordLogin(registered, loginId, email, callback) {
  if (initStore()) {
    if (registered) recordEmail(email);
    window.store.set("login", loginId || 0, function() {safeCall(null, callback);});
    window.registered = registered;
  } else {
    safeTimeout(callback, 0);
  }
}

function getRemoteEmail(callback) {
  xhrAuthRequest("GET", "getuser", callback);
}

function saveCookie(callback, slot, stats, temps, lineNum, indent) {
    var value = computeCookie(stats, temps, lineNum, indent);
    return writeCookie(value, slot, callback);
}

function computeCookie(stats, temps, lineNum, indent) {
  var scene = stats.scene;
  delete stats.scene;
  if (scene) stats.sceneName = scene.name;
  var version = "UNKNOWN";
  if (typeof(window) != "undefined" && window && window.version) version = window.version;
  var value = toJson({version:version, stats:stats, temps:temps, lineNum: lineNum, indent: indent});
  stats.scene = scene;
  return value;
}

function writeCookie(value, slot, callback) {
  if (!_global.pseudoSave) _global.pseudoSave = {};
  if (!slot) {
    slot = "";
  }
  _global.pseudoSave[slot] = value;
  if (!initStore()) {
    if (callback) safeTimeout(callback, 0);
    return;
  }
  window.store.set("state"+slot, value, safeCallback(callback));
}

function clearCookie(callback, slot) {
    writeCookie('', slot, safeCallback(callback));
}

function areSaveSlotsSupported() {
  return !!(initStore() && window.Persist.type != "cookie");
}

function recordSave(slot, callback) {
  if (!areSaveSlotsSupported()) {
    safeTimeout(callback, 0);
    return;
  }
  restoreObject(initStore(), "save_list", [], function (saveList) {
    saveList.push(slot);
    window.store.set("save_list", toJson(saveList), safeCallback(callback));
  });
}

function recordDirtySlots(slots, callback) {
  if (!areSaveSlotsSupported()) {
    safeTimeout(callback, 0);
    return;
  }
  restoreObject(initStore(), "dirty_save_list", [], function (saveList) {
    saveSet = {};
    for (var i = 0; i < saveList.length; i++) {
      saveSet[saveList[i]] = 1;
    }
    for (i = 0; i < slots.length; i++) {
      if (!saveSet[slots[i]]) saveList.push(slots[i]);
    }
    window.store.set("dirty_save_list", toJson(saveList), safeCallback(callback));
  });
}

function recordEmail(email, callback) {
  if (initStore()) {
    window.recordedEmail = email;
    window.store.set("email", email, safeCallback(callback));
  } else {
    safeTimeout(callback, 0);
  }
}

function fetchEmail(callback) {
  if (!initStore()) {
    safeTimeout(function(){callback("");}, 0);
    return;
  }
  if (window.recordedEmail) {
    return safeTimeout(function() {
      callback(window.recordedEmail);
    })
  }
  if (window.isWeb) {
    var cookieEmail = getCookieByName("login");
    if (/@/.test(cookieEmail)) {
      return recordEmail(cookieEmail, function() {
        callback(cookieEmail);
      });
    }
  }
  // For some reason, this get seems to not respond sometimes
  // adding a fallback timeout
  window.store.get("email", function(ok, value) {
    safeCall(null, function() {
      if (ok) window.recordedEmail = value;
      if (!callback) return;
      var temp = callback;
      callback = null;
      if (ok && value) {
        temp(value);
      } else {
        temp("");
      }
    });
  });
  safeTimeout(function() {
    if (!callback) return;
    var temp = callback;
    callback = null;
    temp("");
  }, 1000);
}

function restoreObject(store, key, defaultValue, callback) {
  if (!store) {
    safeTimeout(function() {callback(defaultValue);}, 0);
    return;
  }
  store.get(key, function(ok, value) {
    var result = defaultValue;
    if (ok && value) {
      try{
        result = jsonParse(value);
      } catch (e) {}
    }
    safeCall(null, function() {callback(result);});
  });
}

function getDirtySaveList(callback) {
  restoreObject(initStore(), "dirty_save_list", [], function (slotList) {
    callback(slotList);
  });
}

function remoteSaveMerger(i, callback) {
  var remoteStore = new Persist.Store(window.remoteStoreNames[i]);
  restoreObject(remoteStore, "save_list", [], function (remoteSlotList) {
    fetchSavesFromSlotList(remoteStore, remoteSlotList, 0, [], function(remoteSaveList) {
      mergeRemoteSaves(remoteSaveList, 0/*recordDirty*/, function() {
        i++;
        if (i < window.remoteStoreNames.length) {
          remoteSaveMerger(i, callback);
        } else {
          callback.apply(null, arguments);
        }
      });
    });
  });
}

function getSaves(callback) {
  if (window.remoteStoreNames && window.remoteStoreNames.length) {
    remoteSaveMerger(0, callback);
  } else if (window.remoteStoreName && window.storeName != window.remoteStoreName) {
    var remoteStore = new Persist.Store(window.remoteStoreName);
    restoreObject(remoteStore, "save_list", [], function (remoteSlotList) {
      fetchSavesFromSlotList(remoteStore, remoteSlotList, 0, [], function(remoteSaveList) {
        mergeRemoteSaves(remoteSaveList, 0/*recordDirty*/, callback);
      });
    });
  } else {
    restoreObject(initStore(), "save_list", [], function (localSlotList) {
      fetchSavesFromSlotList(initStore(), localSlotList, 0, [], callback);
    });
  }
}

function fetchSavesFromSlotList(store, slotList, i, saveList, callback) {
  if (i >= slotList.length) {
    return safeCall(null, function() {callback(saveList);});
  }
  restoreObject(store, "state"+slotList[i], null, function(saveState) {
    if (saveState) {
      saveState.timestamp = slotList[i].substring(4/*"save".length*/);
      saveList.push(saveState);
    }
    fetchSavesFromSlotList(store, slotList, i+1, saveList, callback);
  });
}

function isWebSavePossible() {
  if (!initStore()) return false;
  if (/^http/.test(window.location.protocol)) {
    return document.domain == window.webSaveDomain || document.domain == "localhost";
  }
  // if it's a file URL with a valid store, either you're a 3rd party developer
  // who knows what you're doing, or you're a mobile app
  return true;
}


webSaveDomain = "www.choiceofgames.com";
webSaveUrl = "https://" + webSaveDomain + "/ajax_proxy.php/websave";

function submitRemoteSave(slot, email, subscribe, callback) {
  if (!isWebSavePossible()) return safeTimeout(function() { callback(false); });
  window.store.get("state"+slot, function(ok, value) {
    if (ok) {
      var timestamp = slot.substring(4/*"save".length*/);
      var xhr = findXhr();
      var gameName = window.remoteStoreName || window.storeName;
      var params = "email="+email+"&game="+gameName+"&realGame="+window.storeName+"&json="+encodeURIComponent(value)+"&timestamp="+ timestamp+"&subscribe="+subscribe;
      xhr.open("POST", webSaveUrl,true);
      xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
      var done = false;

      xhr.onreadystatechange = function() {
        if (done) return;
        if (xhr.readyState != 4) return;
        done = true;
        var ok = xhr.status == 200;
        if (ok) {
          safeCall(null, function() {callback(true);});
        } else {
          recordDirtySlots([slot], function() {
            safeCall(null, function() {callback(false);});
          });
        }
      };
      xhr.send(params);
    } else {
      recordDirtySlots([slot], function() {
        asyncAlert("There was a problem uploading the saved game. This is probably a bug; please contact support@choiceofgames.com with code 17891.", function() {
          safeCall(null, function() {callback(false);});
        });
      });
    }
  });
}

function submitDirtySaves(dirtySaveList, email, callback) {
  function submitDirtySave(i) {
    if (dirtySaveList[i]) {
      submitRemoteSave(dirtySaveList[i], email, false, function(ok) {
        if (ok) {
          submitDirtySave(i+1);
        } else {
          safeCall(null, function() {callback(false);});
        }
      });
    } else {
      window.store.remove("dirty_save_list", function() {
        safeCall(null, function() {callback(true);});
      });
    }
  }
  submitDirtySave(0);
}

function submitAnyDirtySaves(callback) {
  if (!callback) callback = function(ok) {};
  try {
    getDirtySaveList(function(dirtySaveList) {
      if (dirtySaveList && dirtySaveList.length) {
        try {
          fetchEmail(function(email) {
            if (email) {
              submitDirtySaves(dirtySaveList, email, callback);
            } else {
              callback(false);
            }
          });
        } catch (e) {
          callback(false);
        }
      }
    });
  } catch (e) {
    callback(false);
  }
}

function getRemoteSaves(email, callback) {
  if (!isWebSavePossible()) {
    safeTimeout(function() {callback([]);}, 0);
    return;
  }
  var xhr = findXhr();
  var gameName = window.remoteStoreName || window.storeName;
  xhr.open("GET", webSaveUrl + "?email="+email+"&game="+gameName, true);
  var done = false;
  xhr.onreadystatechange = function() {
    if (done) return;
    if (xhr.readyState != 4) return;
    done = true;
    if (xhr.status != 200) {
      if (window.console) console.log("Couldn't load remote saves. " + xhr.status + ": " + xhr.responseText);
      safeCall(null, function() {callback(null);});
    } else {
      var result = xhr.responseText;
      result = jsonParse(result);
      var remoteSaveList = [];
      for (var i = 0; i < result.length; i++) {
        if (!result[i]) continue;
        var save = result[i].json;
        if (!save) continue;
        save.timestamp = result[i].timestamp;
        remoteSaveList.push(save);
      }
      safeCall(null, function() {callback(remoteSaveList);});
    }
  };
  xhr.send();
}

function mergeRemoteSaves(remoteSaveList, recordDirty, callback) {
  if (!isWebSavePossible()) {
    safeTimeout(function() { callback([], 0, []); }, 0);
    return;
  }
  restoreObject(initStore(), "save_list", [], function (localSlotList) {
    fetchSavesFromSlotList(initStore(), localSlotList, 0, [], function(localSaveList) {
      var localSlotMap = {};
      for (var i = 0; i < localSlotList.length; i++) {
        localSlotMap[localSlotList[i]] = 1;
      }
      var remoteSlotMap = {};
      for (i = 0; i < remoteSaveList.length; i++) {
        remoteSlotMap["save"+remoteSaveList[i].timestamp] = 1;
      }
      var newRemoteSaves = 0;
      for (i = 0; i < remoteSaveList.length; i++) {
        var remoteSave = remoteSaveList[i];
        var slot = "save"+remoteSave.timestamp;
        if (!localSlotMap[slot]) {
          saveCookie(null, slot, remoteSave.stats, remoteSave.temps, remoteSave.lineNum, remoteSave.indent);
          localSlotList.push(slot);
          localSaveList.push(remoteSave);
          newRemoteSaves++;
        }
      }

      var dirtySaveList = [];
      for (i = 0; i < localSlotList.length; i++) {
        if (!remoteSlotMap[localSlotList[i]]) {
          dirtySaveList.push(localSlotList[i]);
        }
      }

      if (recordDirty) {
        window.store.set("dirty_save_list", toJson(dirtySaveList), finale);
      } else {
        finale();
      }

      function finale() {
        if (newRemoteSaves) {
          window.store.set("save_list", toJson(localSlotList), function() {
            safeCall(null, function() { callback(localSaveList, newRemoteSaves, dirtySaveList); });
          });
        } else {
          safeCall(null, function() {callback(localSaveList, newRemoteSaves, dirtySaveList);});
        }
      }
    });
  });
}

function getAppId() {
  if (window.isIosApp) {
    var appBanner = document.querySelector("meta[name=apple-itunes-app]");
    return /app-id=(\d+)/.exec(appBanner.getAttribute("content"))[1];
  } else if (window.isAndroidApp) {
    var androidLink = document.getElementById('androidLink');
    return /id=([\.\w]+)/.exec(androidLink.href)[1];
  }
}

function submitReceipts(receipts, callback) {
  console.log("submitReceipts: " + JSON.stringify(receipts));
  if (!callback) callback = function(error) {
    if (window.transferPurchaseCallback) {
      window.transferPurchaseCallback(error || "done");
    }
  };
  var appId = receipts.appId;
  var count = 0;
  var error;
  function submitCallback(product) {
    return function submitCallback(ok, response) {
      if (!ok) {
        console.log("failed: " + product + " " + JSON.stringify(response));
        if (!error) {
          var match = /^receipt transaction already processed: (\d+) current login (\d+)$/.exec(response.error);
          if (match) {
            callback("409-" + match[1] + "-" + match[2]);
          } else {
            callback("" + response.status + "r");
          }
        }
        error = true;
      }
      if (error) return;
      count--;
      if (!count) {
        if (!receipts.avoidOverrides) cacheKnownPurchases(response);
        callback();
      }
    }
  }

  if (window.isAndroidApp) {
    window.store.get("login", function(ok, loginId) {
      loginId = loginId || 0;
      var platform = window.isAmazonAndroidApp ? 'amazon' : 'google';
      if (receipts.prePurchased && platform === 'google') {
        for (var i = 0; i < receipts.prePurchased.length; i++) {
          var product = receipts.prePurchased[i];
          count++;
          xhrAuthRequest("POST", "submit-device-receipt", submitCallback(product),
            'platform', platform,
            'company', receipts.company,
            'game_id', window.storeName,
            'app_package', appId,
            'product_id', product,
            'signature', encodeURIComponent(receipts.signature),
            'receipt', encodeURIComponent(receipts.signedData),
            'login_id', loginId
          );
        }
      }
      if (receipts.iaps) {
        for (var product in receipts.iaps) {
          count++;
          xhrAuthRequest("POST", "submit-device-receipt", submitCallback(product),
            'platform', platform,
            'company', receipts.company,
            'game_id', window.storeName,
            'app_package', appId,
            'product_id', product,
            'receipt', encodeURIComponent(receipts.iaps[product]),
            'login_id', loginId
          );
        }
      }
      if (!count) safeTimeout(function () { callback(); }, 0);
    });
  } else {
    callback("error");
  }
}

function delayBreakStart(callback) {
  var nowInSeconds = Math.floor(new Date().getTime() / 1000);
  if (!initStore()) {
    safeTimeout(function() {callback(nowInSeconds);}, 0);
    return;
  }
  window.store.get("delayBreakStart", function(ok, value) {
    var valueNum = value*1;
    safeCall(null, function() {
      if (ok && value && !isNaN(valueNum)) {
        callback(valueNum);
      } else {
        window.store.set("delayBreakStart", nowInSeconds);
        callback(nowInSeconds);
      }
    });
  });
}

function delayBreakEnd() {
  if (initStore()) window.store.remove("delayBreakStart");
}

function initStore() {
  if (!window.storeName) return false;
  if (window.store) return window.store;
  try {
    window.store = new Persist.Store(window.storeName);
  } catch (e) {}
  return window.store;
}
function loadAndRestoreGame(slot, forcedScene) {
  function valueLoaded(ok, value) {
    safeCall(null, function() {
      var state = null;
      if (ok && value && ""+value) {
        //console.log("successfully loaded slot " + slot);
        state = jsonParse(value);
      } else if (slot == "backup") {
        console.log("loadAndRestoreGame couldn't find backup");
        return loadAndRestoreGame("", forcedScene);
      }
      restoreGame(state, forcedScene);
    });
  }
  if (!slot) slot = "";
  if (_global.pseudoSave && pseudoSave[slot]) return valueLoaded(true, pseudoSave[slot]);
  if (!initStore()) return restoreGame(null, forcedScene);
  window.store.get("state"+slot, valueLoaded);
}

function isStateValid(state) {
  if (!state) return false;
  if (!state.stats) return false;
  if (!state.stats.sceneName) return false;
  return true;
}

function restartGame(shouldPrompt) {
  if (_global.blockRestart) {
    asyncAlert("Please wait until the timer has run out.");
    return;
  }
  function actuallyRestart(result) {
    if (!result) return;
    delayBreakEnd();
    submitAnyDirtySaves();
    clearCookie(function() {}, 'temp');
    clearCookie(function() {
      _global.nav.resetStats(_global.stats);
      clearScreen(restoreGame);
    }, "");
  }
  if (shouldPrompt) {
    asyncConfirm("Start over from the beginning?", actuallyRestart);
  } else {
    actuallyRestart(true);
  }
}

function restoreGame(state, forcedScene, userRestored) {
    var scene;
    var secondaryMode = null;
    var saveSlot = "";
    var forcedSceneLabel = null;
    if (/\|/.test(forcedScene)) {
      var parts = forcedScene.split("|");
      forcedScene = parts[0];
      forcedSceneLabel = parts[1];
    }
    if (forcedScene == "choicescript_stats") {
      secondaryMode = "stats";
      saveSlot = "temp";
    } else if (forcedScene == "choicescript_upgrade") {
      secondaryMode = "upgrade";
      saveSlot = "temp";
    }
    if (!isStateValid(state)) {
        var startupScene = forcedScene ? forcedScene : _global.nav.getStartupScene();
        scene = new Scene(startupScene, _global.stats, _global.nav, {debugMode:_global.debug, secondaryMode:secondaryMode, saveSlot:saveSlot});
    } else {
      if (forcedScene) state.stats.sceneName = forcedScene;
      _global.stats = state.stats;
      // Someday, inflate the navigator using the state object
      scene = new Scene(state.stats.sceneName, state.stats, _global.nav, {debugMode:state.debug || _global.debug, secondaryMode:secondaryMode, saveSlot:saveSlot});
      if (!forcedScene) {
        scene.temps = state.temps;
        scene.lineNum = state.lineNum;
        scene.indent = state.indent;
      }
      if (userRestored) {
        scene.temps.choice_user_restored = true;
      }
    }
    if (forcedSceneLabel !== null) {
      scene.targetLabel = {label:forcedSceneLabel, origin:"url", originLine:0}
    }
    safeCall(scene, scene.execute);
}

function redirectScene(sceneName, label, originLine) {
  var scene = new Scene(sceneName, window.stats, window.nav, {debugMode:window.debug});
  if (label) scene.targetLabel = {label:label, origin:"choicescript_stats", originLine:originLine};
  scene.redirectingFromStats = true;
  clearScreen(function() {scene.execute();});
}

tempStatWrites = {};

function transferTempStatWrites() {
  if (!_global.isIosApp) return;
  callIos("transferwrites", JSON.stringify(tempStatWrites));
}

function getCookieByName(cookieName, ck) {
    if (!ck) ck = window.document.cookie;
    if (!ck) return null;
    var ckPairs = ck.split(/;/);
    for (var i = 0; i < ckPairs.length; i++) {
        var ckPair = trim(ckPairs[i]);
        var ckNameValue = ckPair.split(/=/);
        var ckName = decodeURIComponent(ckNameValue[0]);
        if (ckName === cookieName) {
            return decodeURIComponent(ckNameValue[1]);
        }
    }
    return null;
}

function parseQueryString(str) {
  if (!str) return null;
  str = String(str).substring(1);
  if (!str) return null;
  var map = {};
  var pairs = str.split("&");
  var i = pairs.length;
  while (i--) {
    var pair = pairs[i];
    var parts = pair.split("=");
    map[parts[0]] = parts[1];
  }
  return map;
}

function trim(str) {
    if (str === null || str === undefined) return null;
    var result = str.replace(/^\s+/g, "");
    // strip leading
    return result.replace(/\s+$/g, "");
    // strip trailing
}


function findOptimalDomain(docDomain) {
    if (!docDomain) docDomain = document.domain;
    // localhost and 127.0.0.1 will cause cookie not to be set; just omit them, it works fine
    if (docDomain == "localhost" || docDomain == "127.0.0.1") return null;
    // ip address
    if (/^\d+\.\d+\.\d+\.\d+$/.test(docDomain)) return null;
    // dotcom
    var result = docDomain.match(/(\w+\.\w{3}$)/);
    if (result) return result[1];
    return null;
}

function num(x, line, sceneName) {
    if (!line) line = "UNKNOWN";
    errorInfo = "line "+line;
    if (sceneName) errorInfo = sceneName + " " + errorInfo;
    var x_num = parseFloat(x);
    if (isNaN(x_num)) throw new Error(errorInfo+": Not a number: " + x);
    if (!isFinite(x_num)) throw new Error(errorInfo+": Not finite " + x);
    return x_num;
}

function bool(x, line, sceneName) {
  if (!line) line = "UNKNOWN";
  if ("boolean" == typeof x) {
    return x;
  } else if ("true" === x) {
    return true;
  } else if ("false" === x) {
    return false;
  }
  errorInfo = "line "+line;
  if (sceneName) errorInfo = sceneName + " " + errorInfo;
  throw new Error(errorInfo+": Neither true nor false: " + x);
}

function findXhr() {
  var ieFile = isIE && isFile;
  if (window.XMLHttpRequest && !ieFile) return new window.XMLHttpRequest();
  var ids = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
  for (var i = 0; i < 3; i++) {
    try {
      return new ActiveXObject(ids[i]);
    } catch (e) {}
  }
  throw new Error("Couldn't create XHR object");
}

    crcTable = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";

    /* Number */
    function crc32( /* String */ str, /* Number */ crc ) {
        if( !crc ) crc = 0;
        var n = 0; //a number between 0 and 255 
        var x = 0; //an hex number 

        crc = crc ^ (-1);
        for( var i = 0, iTop = str.length; i < iTop; i++ ) {
            n = ( crc ^ str.charCodeAt( i ) ) & 0xFF;
            x = "0x" + crcTable.substr( n * 9, 8 );
            crc = ( crc >>> 8 ) ^ x;
        }
        return crc ^ (-1);
    }

function simpleDateTimeFormat(date) {
  var day = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][date.getDay()];
  var month = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][date.getMonth()];
  var minutes = date.getMinutes();
  if (minutes < 10) minutes = "0" + (""+minutes);
  var oneYearInMillis = 1000 * 60 * 60 * 24 * 365;
  var millisAgo = new Date().getTime() - date.getTime();
  var yearString = ""
  if (millisAgo > oneYearInMillis) {
    yearString = ", " + date.getFullYear();
  }
  return day + ", " + month + " " + date.getDate() + yearString + ", " + date.getHours() + ":" + minutes;
}

function jsonParse(str) {
  if (typeof JSON != "undefined") {
    try {
      return JSON.parse(str);
    } catch (e) {
      // try to handle unquoted keys
      try {
        return eval('('+str+')');
      } catch (e2) {
        // that might have failed because eval is forbidden
        try {
          eval("1");
        } catch (e3) {
          // eval forbidden; let's try a hack to fix unquoted keys
          var str2 = (str+"").replace(/([,\{])\s*(\w+)\s*\:/g, '$1"$2":');
          try {
            return JSON.parse(str2);
          } catch (e4) {}
        }
        // at this point, just report a clear error
        return JSON.parse(str);
      }
    }
  } else {
    return eval('('+str+')');
  }
}

function cefQuerySimple(method) {
  cefQuery({
    request:method,
    onSuccess: function(response) {console.log(method + " success");},
    onFailure: function(error_code, error_message) {console.error(method + " error: " + error_message);}
  });
}

shortMonthStrings = [null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse
// "Given a date string of "March 7, 2014", parse() assumes a local time zone, but given an
// ISO format such as "2014-03-07" it will assume a time zone of UTC for ES5 or local for
// ECMAScript 2015."
function parseDateStringInCurrentTimezone(YYYY_MM_DD, line) {
  var result = /^(\d{4})-(\d{2})-(\d{2})$/.exec(YYYY_MM_DD);
  if (!result) throw new Error("line "+line+": invalid date string " + YYYY_MM_DD);
  var fullYear = result[1];
  var oneBasedMonthNumber = parseInt(result[2],10);
  var dayOfMonth = parseInt(result[3],10);
  var shortMonthString = shortMonthStrings[oneBasedMonthNumber];
  return new Date(shortMonthString + " " + dayOfMonth + ", " + fullYear);
}

function matchBracket(line, brackets, startIndex) {
  var openBracket = brackets[0];
  var closeBracket = brackets[1];
  var brackets = 0;
  for (var i = startIndex; i < line.length; i++) {
    var c = line.charAt(i);
    if (c === openBracket) {
      brackets++;
    } else if (c === closeBracket) {
      if (brackets) {
        brackets--;
      } else {
        return i;
      }
    }
  }
  return -1;
}

function isStoreSceneCacheRequired() {
  if (!(initStore() &&
    _global.purchases &&
    _global.checkPurchase &&
    _global.hashes &&
    !(_global.isOmnibusApp && _global.isIosApp) &&
    hashes.scenes
  )) return false;
  var empty = true;
  for (var scene in purchases) {
    if (/^fake:/.test(scene)) continue;
    empty = false;
    break;
  }
  return !empty;
}

function updateSinglePaidSceneCache(sceneName, callback) {
  sceneName = sceneName.replace(/ /g, "_");
  var fileName = sceneName + ".txt.json";
  if (initStore() && _global.hashes && hashes.scenes && hashes.scenes[fileName]) {
    function actualRequest(receiptsSent) {
      var xhr = new XMLHttpRequest();
      var canonical = document.querySelector("link[rel=canonical]");
      var canonicalHref = canonical && canonical.getAttribute("href");
      var url = canonicalHref + "scenes/" + fileName + "?hash="+hashes.scenes[fileName];
      xhr.open("GET", url);
      xhr.onload = function() {
        var error;
        if (xhr.status !== 200) {
          try {
            error = JSON.parse(xhr.responseText).error;
          } catch (e) {}
        }
        if (xhr.status === 404) {
          try {
            if (error === "hash doesn't match") {
              return awaitAppUpdate(function() {
                callback("strange");
              })
            }
          } catch (e) {
            if (window.console) console.error(e, e.stack);
          }
        }
        if (xhr.status == 403 && _global.isOmnibusApp && _global.isAndroidApp) {
          if (!receiptsSent) {
            window.receiptRequestCallback = function(receipts) {
              window.receiptRequestCallback = null;
              submitReceipts(receipts, function(error) {
                if (error) {
                  return callback(error);
                } else {
                  actualRequest("receiptsSent");
                }
              });
            }
            androidBilling.requestReceipts();
            return;
          } else if (error === "not registered" || error == "not purchased") {
            return callback(error);
          }
        } else if (xhr.status !== 200) {
          return callback(xhr.status);
        }
        var result;
        try {
          result = jsonParse(xhr.responseText);
        } catch (e) {
          if (window.console) console.error(e, e.stack);
        }
        var ok = result && result.crc && result.lines && result.labels;
        if (!ok) return callback("network");
        window.store.set("cache_scene_"+sceneName, xhr.responseText, function() {
          window.store.set("cache_scene_hash_"+sceneName, hashes.scenes[fileName], function() {
            callback(null, result);
          });
        });
      };
      xhr.onerror = function() {
        callback("network");
      }
      console.log("updateSinglePaidSceneCache " + url);
      xhr.send();
    }
    actualRequest();
  }
}

function updateAllPaidSceneCaches(receiptsSent) {
  if (!isStoreSceneCacheRequired()) {
    if (window.isOmnibusApp && window.isAndroidApp) {
      window.receiptRequestCallback = submitReceipts;
      androidBilling.requestReceipts();
    }
    return;
  }
  if (_global.isOmnibusApp && _global.isAndroidApp && !receiptsSent) {
    window.receiptRequestCallback = function(receipts) {
      submitReceipts(receipts, function() {updateAllPaidSceneCaches("receiptsSent");});
    };
    androidBilling.requestReceipts();
    return;
  }
  var flipped = {};
  for (var scene in purchases) {
    if (/^fake:/.test(scene)) continue;
    scene = scene.replace(/ /g, "_");
    if (!flipped[purchases[scene]]) flipped[purchases[scene]] = [];
    flipped[purchases[scene]].push(scene);
  }
  var products = [];
  for (var product in flipped) {
    products.push(product);
  }
  if (!products.length) return;
  checkPurchase(products.join(" "), function(ok, result) {
    if (!ok || !result) return;
    var sceneList = [];
    var push = Array.prototype.push;
    for (var product in flipped) {
      if (result[product]) {
        push.apply(sceneList, flipped[product]);
      }
    }
    if (!sceneList.length) return;
    for (var i = 0; i < sceneList.length; i++) {
      (function(i) {
        var scene = sceneList[i];
        var fileName = scene + ".txt.json";
        window.store.get("cache_scene_hash_"+scene, function(ok, result) {
          if (!ok || result !== hashes.scenes[fileName]) {
            updateSinglePaidSceneCache(scene, function() {});
          }
        });
      })(i);
    }
  })
}

function checkForAppUpdates() {
  if (navigator.serviceWorker) {
    navigator.serviceWorker.getRegistration().then(function(reg) {
      if (reg) reg.update();
    });
  }
}

function refreshIfAppUpdateReady() {
  if (navigator.serviceWorker) {
    if (window.controllerchanged) {
      return window.location.reload();
    }
    navigator.serviceWorker.getRegistration().then(function(reg) {
      if (reg.waiting) {
        reg.waiting.postMessage('skipWaiting');
        return window.location.reload();
      }
    });
  }
}

function awaitAppUpdate(callback) {

  var serviceWorkerExists = (navigator.serviceWorker && navigator.serviceWorker.controller);
  if (!serviceWorkerExists) return callback();

  var calledBack = false;
  var maybeCallback = function() {
    if (calledBack) return;
    calledBack = true;
    callback();
  }

  if (window.controllerchanged) return maybeCallback();
  setTimeout(maybeCallback, 10000);
  navigator.serviceWorker.getRegistration().then(function(reg) {
    if (!reg) return maybeCallback();
    if (reg.waiting) {
      reg.waiting.postMessage('skipWaiting');
      return maybeCallback();
    }
    var watchStateChange = function() {
      if (this.state == 'installed') {
        if (reg.waiting) reg.waiting.postMessage('skipWaiting');
        maybeCallback();
      }
    };
    if (reg.installing) reg.installing.addEventListener('statechange', watchStateChange);
    reg.update();
    reg.addEventListener('updatefound', function() {
      reg.installing.addEventListener('statechange', watchStateChange);
    })
  });
}

function remoteConfig(variable, callback) {
  if (!_global.isOmnibusApp) {
    safeTimeout(function() {callback(null);}, 0);
    return;
  }
  if (_global.isIosApp) {
    var nonce = "remoteConfig" + variable + (+new Date);
    window[nonce] = function(value) {
      delete window[nonce];
      callback(value);
    }
    callIos("remoteconfig", variable + " " + nonce);
  } else {
    var result = (_global.androidRemoteConfig && androidRemoteConfig.remoteConfig(variable)) || null;
    return safeTimeout(function() {callback(result);}, 0);
  }
}


;nav = new SceneNavigator(["startup"]);
stats = {};



;function autotester(sceneText, nav, sceneName, extraLabels) {
  if (sceneText.length > 1.9 * 1000 * 1000) {
    throw new Error(sceneName + ": this scene is too large. It may crash on some devices")
  }
  function log(msg) {
    if (typeof(console) != "undefined") console.log(msg)
  }
  var coverage = [];

  var printed = [];
  printx = printParagraph = function printx(msg, parent) {
      //printed.push(msg);
  }
    
  var sceneList = [];
  
  if (!Scene.prototype.oldSceneList) Scene.prototype.oldSceneList = Scene.prototype.scene_list;
  Scene.prototype.scene_list = function test_scene_list() {
    if ("startup" != this.name || !this.screenEmpty || !this.initialCommands) throw new Error(this.lineMsg() +
    "Invalid scene_list instruction, only allowed at the top of startup.txt");
    var scenes = this.parseSceneList();
    for (var i = 0; i < scenes.length; i++) {
      this.verifySceneFile(scenes[i]);
    }
  }

  Scene.prototype.quicktest = true;

  Scene.prototype.finish = function test_finish(buttonName) {
    this.paragraph();
    this.finished = true;
    if (!buttonName) buttonName = "Next Chapter";
    buttonName = this.replaceVariables(buttonName);
    if (this.testFinish) this.testFinish();
  }

  // Don't test for *bugs; *if cheating makes *bugs fake-reachable
  Scene.prototype.bug = function test_bug() {
    this.finished = true;
  };

  Scene.prototype.page_break = function(buttonName) {
    this.replaceVariables(buttonName);
    this.resetCheckedPurchases();
  };
  Scene.prototype.subscribe = function() {};
  Scene.prototype.feedback = function() {};
  Scene.prototype.save = function() {};
  Scene.prototype.restore_purchases = function() {};
  Scene.prototype.buyButton = function (product, priceGuess, label) {
    if (seen[label]) return;
    var scene = this.clone();
    scene.testPath.push(',');
    scene.testPath.push(this.lineNum+1);
    scene.testPath.push('$');
    scene.lineNum = this.lineNum;
    scene.rollbackLineCoverage();
    scene.indent = this.indent;
    scene["goto"](label);
    scene.rollbackLineCoverage(); // we haven't actually covered the line yet
    scene.resume = function() {
      this.lineNum = this.lineNum; // NOW we've covered it
      scene.printLoop(); }
    sceneList.push(scene);
  };
  
  Scene.prototype.delay_break = function() {};

  Scene.prototype.delay_ending = function test_delayEnding(data) {
    var args = data.split(/ /);
    var durationInSeconds = args[0];
    var price = args[1];
    if (isNaN(durationInSeconds * 1)) throw new Error(this.lineMsg() + "invalid duration");
    if (!/^\$/.test(price)) throw new Error(this.lineMsg() + "invalid price");
    this.paragraph();
    this.finished = true;
  }

  Scene.prototype.check_purchase = function scene_checkPurchase(data) {
    var products = data.split(/ /);
    for (var i = 0; i < products.length; i++) {
      this.temps["choice_purchased_"+products[i]] = true;
      if ((!this.nav.products || !this.nav.products[products[i]]) && products[i] != "adfree") {
        this.warning("The product " + products[i] + " wasn't declared in a *product command");
      }
    }
    this.temps.choice_purchase_supported = false;
    this.temps.choice_purchased_everything = true;
  }
  
  var inputCallback;

  printInput = function printInput(target, inputOptions, callback, minimum) {
    inputCallback = function() {
      if (inputOptions.numeric) {
        callback(minimum);
      } else {
        callback("blah blah");
      }
    }
  }

  if (!Scene.prototype.oldInputText) Scene.prototype.oldInputText = Scene.prototype.input_text;
  if (!Scene.prototype.oldInputNumber) Scene.prototype.oldInputNumber = Scene.prototype.input_number;

  Scene.prototype.input_text = function test_input_text(data) {
    this.oldInputText(data);
    this.lineNum++;
    inputCallback();
  }
  
  Scene.prototype.input_number = function test_input_number(data) {
    this.oldInputNumber(data);
    this.lineNum++;
    inputCallback();
  }

  Scene.prototype.goto_random_scene = function testGotoRandomScene(data) {
    var parsed = this.parseGotoRandomScene(data);
    for (var i = 0; i < parsed.length; i++) {
      var name = parsed[i].name;
      this.verifySceneFile(name);
    }

    if (!/\ballow_no_selection\b/.test(data)) {
      this.finished = true;
    }
  }
  
  Scene.prototype.save_game = function(destinationSceneName) {
    if (!destinationSceneName) throw new Error(this.lineMsg()+"*save_game requires a destination file name, e.g. *save_game Episode2");
    this.verifySceneFile(destinationSceneName);
  }
  
  Scene.prototype.restore_game = function(data) {
    this.parseRestoreGame(false/*alreadyFinished*/);
    if (data) {
      var result = /^cancel=(\S+)$/.exec(data);
      if (!result) throw new Error(this.lineMsg() + "invalid restore_game line: " + data);
      cancel = result[1];
      this["goto"](cancel);
    }
  };
  
  Scene.prototype.rollbackLineCoverage = function(lineNum) {
    if (!lineNum) lineNum = this.lineNum;
    coverage[lineNum]--;
    // print("un-covered: " + (lineNum+1) + " (" + coverage[lineNum] + ")");
  }
  
  try {
    Scene.prototype.__defineGetter__("lineNum", function() { return this._lineNum; });
    Scene.prototype.__defineSetter__("lineNum", function(val) {
        if (coverage[val]) {
            coverage[val]++;
        } else {
            coverage[val] = 1;
        }
        // print("covered: " + (val+1) + " (" + coverage[val] + ")");
        this._lineNum = val;
    });
  } catch (e) {
    // IE doesn't support getters/setters; no coverage for you!
  }
  
  
  Scene.prototype.choice = function choice(data) {
      var groups = ["choice"];
      if (data) {
        groups = data.split(/ /);
        for (var i = 0; i < groups.length; i++) {
          if (!/^\w*$/.test(groups[i])) {
            throw new Error(this.lineMsg() + "invalid choice group name: " + groups[i]);
          }
        }
      }
      var choiceLine = this.lineNum;
      var options = this.parseOptions(this.indent, groups);
      if (!this.temps._choiceEnds) {
        this.temps._choiceEnds = {};
      }
      for (i = 0; i < options.length; i++) {
        this.temps._choiceEnds[options[i].line-1] = this.lineNum;
      }
      var flattenedOptions = [];
      flattenOptions(flattenedOptions, options);
      
      for (var index = 0; index < flattenedOptions.length; index++) {
          var item = flattenedOptions[index];
          this.printLine(item.ultimateOption.name);
          var scene = this.clone();
          scene.testOption = item;
          scene.testChoiceLine = choiceLine;
          scene.testPath.push(',');
          scene.testPath.push(choiceLine+1);
          scene.testPath.push('#');
          scene.testPath.push(index+1);
          scene.testPath.push(' (');
          scene.testPath.push(item.ultimateOption.line);
          scene.testPath.push(')');
          scene.resume = function() {this.standardResolution(this.testOption.ultimateOption);}
          sceneList.push(scene);
      }
      
      this.finished = true;
      
      function flattenOptions(list, options, flattenedOption) {
        if (!flattenedOption) flattenedOption = {};
        for (var i = 0; i < options.length; i++) {
          var option = options[i];
          flattenedOption[option.group] = i;
          if (option.suboptions) {
            flattenOptions(list, option.suboptions, flattenedOption);
          } else {
            flattenedOption.ultimateOption = option;
            list.push(dojoClone(flattenedOption));
          }
        }
      }
  }
  
  Scene.prototype.clone = function clone() {
    this.stats.scene = null;
    var clonedStats = dojoClone(this.stats);
    var scene = new Scene(this.name, clonedStats, this.nav, {secondaryMode:this.secondaryMode});
    scene.lines = this.lines;
    scene.labels = this.labels;
    scene.temps = dojoClone(this.temps);
    scene.loaded = true;
    scene.testPath = dojoClone(this.testPath);
    scene.firstTab = this.firstTab;
    scene.firstSpace = this.firstSpace;
    this.stats.scene = this;
    return scene;
  }
  
  function dojoClone(/*anything*/ o){
  	// summary:
  	//		Clones objects (including DOM nodes) and all children.
  	//		Warning: do not clone cyclic structures.
  	if(!o){ return o; }
  	if(o instanceof Array || typeof o == "array"){
  		var r = [];
  		for(var i = 0; i < o.length; ++i){
  			r.push(dojoClone(o[i]));
  		}
  		return r; // Array
  	}
  	if(typeof o != "object" && typeof o != "function"){
  		return o;	/*anything*/
  	}
  	if(o.nodeType && o.cloneNode){ // isNode
  		return o.cloneNode(true); // Node
  	}
  	if(o instanceof Date){
  		return new Date(o.getTime());	// Date
  	}
  	// Generic objects
    if (typeof o.constructor === "function") {
      r = new o.constructor(); // specific to dojo.declare()'d classes!
    } else {
      r = {};
    }
  	for(i in o){
  		if(!(i in r) || r[i] != o[i]){
  			r[i] = dojoClone(o[i]);
  		}
  	}
  	return r; // Object
  }
  
  // In autotest, impossible combinations occur, so ignore all conflicting options
  // We'll catch these with randomtest instead
  Scene.prototype.conflictingOptions = function() {};

  if (!Scene.prototype.oldRunCommand) Scene.prototype.oldRunCommand = Scene.prototype.runCommand;
  Scene.prototype.runCommand = function test_runCommand(line) {
    // skip commands that have already been covered
    if (!this.ignoreCoverage && coverage[this._lineNum] > 1) {
        if (/^\s*\*else/i.test(line)) {
          // else statements will have been covered by the "false" clones
          // but the fact that we're here means we must have fallen into an *else
          return this.oldRunCommand(line);
        } else if (seenInChoice[this.lineNum]) {
          // this is probably a case where we're falling out of an #option block
          // but the subsequent #option is *if conditional. Running the old
          // command will correctly raise an error.
          return this.oldRunCommand(line);
        } else {
          //log("overcovered " + (this._lineNum+1) + " " + coverage[this._lineNum]);
          this["return"]();
          return true;
        }
    } else {
      return this.oldRunCommand(line);
    }
    
  }
  
  if (!Scene.prototype.oldGoto) Scene.prototype.oldGoto = Scene.prototype["goto"];
  
  var seen = {};
  Scene.prototype["goto"] = function scene_goto(label, inChoice) {
      if (inChoice) {
        this.oldGoto(label, true);
        return;
      }
      //more specific keys are better tests!
      var key = label.toLowerCase();
      //var key = toJson(this.stats) + toJson(this.temps) + label;
      if (seen[key]) {
          //throw new Error("yay! seen!");
          this["return"]();
          return;
      }
      seen[key] = 1;
      //log("unseen: " + key);
      this.oldGoto(label);
  }

  if (!Scene.prototype.oldGosub) Scene.prototype.oldGosub = Scene.prototype.gosub;

  Scene.prototype.gosub = function scene_gosub(label, inChoice) {
    if (!seen[label.toLowerCase()]) this.oldGosub(label);
  }

  Scene.prototype.ending = function test_ending() {
    this.finished = true;
  };
  Scene.prototype.restart = Scene.prototype.ending;
  
  Scene.prototype.goto_scene = function testGotoScene(data) {
    var result = this.parseGotoScene(data);
    this.verifySceneFile(result.sceneName);
    this.finished = true;
  }

  Scene.prototype.redirect_scene = function testRedirectScene(data) {
    if (this.secondaryMode != "stats") throw new Error(this.lineMsg() + "The *redirect_scene command can only be used from the stats screen.");
    this.goto_scene(data);
  }

  Scene.prototype.gosub_scene = function testGosubScene(data) {
    var result = this.parseGotoScene(data);
    this.verifySceneFile(result.sceneName);
  }

  Scene.prototype["return"] = function scene_return() {
    var stackFrame;
    if (this.temps.choice_substack && this.temps.choice_substack.length) {
      stackFrame = this.temps.choice_substack.pop();
      this.lineNum = stackFrame.lineNum;
      this.indent = stackFrame.indent;
    } else {
      // testing the scenes in isolation, there's no way to know if a given *return is truly invalid
      this.finished = true;
    }
    
};
  
  if (!Scene.prototype.oldElse) Scene.prototype.oldElse = Scene.prototype["else"];
  Scene.prototype["else"] = function test_else(data, inChoice) {
    if (inChoice) {
      this.oldIf("true");
    } else {
      this.oldElse();
    }
  }
  
  Scene.prototype.elseif = Scene.prototype.elsif = function test_elseif(data, inChoice) {
    // Does the expression evaluate to a boolean?
    var stack = this.tokenizeExpr(data);
    var result = this.evaluateExpr(stack);
    if ("boolean" != typeof result) {
        throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + result);
    }
    this["else"](data, inChoice);
  }

  if (!Scene.prototype.oldIf) Scene.prototype.oldIf = Scene.prototype["if"];
  var seenInChoice = {};
  Scene.prototype["if"] = function test_if(line, inChoice) {
    // Does the expression evaluate to a boolean?
    var stack = this.tokenizeExpr(line);
    var result = this.evaluateExpr(stack);
    if ("boolean" != typeof result) {
        throw new Error(this.lineMsg() + "Invalid boolean expression; this isn't a boolean: " + result);
    }
    
    if (inChoice) {
      seenInChoice[this.lineNum] = 1;
      this.oldIf("true");
      return;
    }
    
    // add false branch to sceneList
    var scene = this.clone();
    scene.testPath.push(',');
    scene.testPath.push(this.lineNum+1);
    scene.testPath.push('F');
    scene.lineNum = this.lineNum;
    scene.rollbackLineCoverage();
    scene.indent = this.indent;
    scene.skipTrueBranch();
    scene.lineNum++;
    scene.rollbackLineCoverage(); // we haven't actually covered the line yet
    scene.resume = function() {
      this.lineNum = this.lineNum; // NOW we've covered it
      scene.printLoop(); }
    sceneList.push(scene);
    this.oldIf("true");
  }
  
  Scene.prototype.stat_chart = function() {
    this.parseStatChart();
  }

  Scene.operators["/"] = function divide(v1,v2,line,sceneObj) {
    let name = null;
    if (sceneObj) {
      name = sceneObj.name;
    }
    v2 = num(v2, line, name);
    if (v2 === 0) return 9007199254740991; //Number.MAX_SAFE_INTEGER
    return num(v1,line,name) / num(v2,line,name);
  };
  
  //Scene.prototype.choice = function() { this.finished = true;}
  
  if (!sceneName) sceneName = "test";
  
  var startingStats = {};
  if (!nav) {
    nav = {
      repairStats: function() {},
      resetStats: function() {},
      startingStats: {},
      bugLog: [],
      products: {},
    }
  }
  nav.resetStats(startingStats);

  // *finish will barf if we use the real sceneName
  var secondaryMode = undefined;
  if (sceneName == "choicescript_stats") {
    secondaryMode = "stats";
  } else if (sceneName == "choicescript_upgrade") {
    secondaryMode = "upgrade";
  }
  var scene = new Scene(sceneName, startingStats, nav, {secondaryMode: secondaryMode});
  var originalScene = scene;
  scene.testPath = [sceneName];
  scene.loadLines(sceneText);
  
  log("executing");
  scene.execute();
  
  while(scene = sceneList.shift()) {
    log (scene.testPath.join(''));
    //log(sceneList.length);
    scene.resume();
  }

  if (extraLabels) {
    for (var i = 0; i < extraLabels.length; i++) {
      var extraLabel = extraLabels[i];
      scene = new Scene(sceneName, startingStats, nav, {secondaryMode: secondaryMode});
      scene.lines = originalScene.lines;
      scene.labels = originalScene.labels;
      scene.loaded = true;
      scene.targetLabel = extraLabel;
      seen = {};
      scene.ignoreCoverage = true;
      scene.testPath = [sceneName,",","goto " + extraLabel.label];
      log (scene.testPath.join(''));
      scene.execute();
      while(scene = sceneList.shift()) {
        log (scene.testPath.join(''));
        //log(sceneList.length);
        scene.resume();
      }
    }
  }

  while(scene = sceneList.shift()) {
      log (scene.testPath.join(''));
      //log(sceneList.length);
      scene.resume();
  }
  
  //log(printed.join('\n'));
  var uncovered = [];
  var startRange = null;
  for (var i = 0; i < coverage.length; i++) {
      //log("line "+(i+1) +": " +coverage[i]);
      line = trim(originalScene.lines[i]);
      if (!coverage[i]) {
        if (startRange === null) {
          if (!line || /\*(comment|bug)\b/.test(line)) continue;
          startRange = i+1;
        }
      } else if (startRange == i) {
        uncovered.push(startRange);
        startRange = null;
      } else if (startRange) {
        uncovered.push(startRange + "-" + i);
        startRange = null;
      }
  }
  if (startRange) {
    uncovered.push(startRange + "-" + (i-1));
  }
  
  if (uncovered.length) {
      log("UNCOVERED:");
      log(uncovered.join('\n'));
      return [coverage, uncovered];
  }
  return [coverage];
}
