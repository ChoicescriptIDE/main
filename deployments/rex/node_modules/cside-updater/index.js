'use strict';
var https = require('https');
var fs = require('fs');
var BASE_URL = "";
var cachedUpdateData = null;
var installFolderPath, packageFilename;
if (process.platform === "darwin") {
    installFolderPath = process.execPath.substring(0, process.execPath.lastIndexOf("CSIDE.app")) + "CSIDE.app/Contents/Resources/";
    packageFilename = "app.nw";
}
else {
    if (process.platform === "linux") {
        installFolderPath = process.execPath.slice(0, process.execPath.lastIndexOf("/")) + "/";
    }
    else {
        installFolderPath = process.execPath.slice(0, process.execPath.lastIndexOf("\\")) + "\\";
    }
    packageFilename = "package.nw";
}

function getUpdateDetails(channel, cb) {
    var request = https.get("https://choicescriptide.github.io/downloads/updates/versions.json", function(response) {
        if (response.statusCode != 200) {
            return cb(new Error("Could not connect to update server."));
        }
        var content = "";
        var updateInfo = {};
        response.on('data', function(chunk) {
            content += chunk.toString();
        })
        .on('end', function (chunk) {
            //alert(1);
            try {
                updateInfo = JSON.parse(content);
                cachedUpdateData = updateInfo; //opportunity to cache here?
            }
            catch(err) {
                return cb(err, null);
            }
            if (typeof channel === "string" && typeof updateInfo[channel] != "undefined") {
                return cb(null, updateInfo[channel]);
            }
            return cb(new Error("Bad update channel"), null);
        })
        .on('error', function(err) {
            return cb(err, null);
        });
    });
		request.on('error', function(err) {
			return cb(err);
		});
    request.end();
}

function isNewVer(oldVer, newVer) {
    var patt = /[0-9]{1}(?=\.)?/gi;
    var currentVer = oldVer.match(patt);
    newVer = newVer.match(patt);
    var shortestVer = (newVer.length < currentVer.length) ? newVer : currentVer;
    var update = false;
    for (var i = 0; i < shortestVer.length; i++) {
        if ((parseInt(newVer[i]) > parseInt(currentVer[i]))) {
            update = true;
            break;
        }
        else if ((parseInt(newVer[i]) < parseInt(currentVer[i]))) {
            break;
        }
        if (i == shortestVer.length - 1 && !update && (newVer.length > currentVer.length)) {
            //if we've not got an update yet
            //but the new version is longer, we also update
            update = true;
        }
    }
    return update;
}

function createBackup(cb) {
    try {
        fs.rename(installFolderPath + packageFilename, installFolderPath + "prev-" + packageFilename, function(err) {
            if (err) {
                return cb(err);
            }
            return cb(null);
        });
    }
    catch (e) { //if we can't make a valid backup, don't attempt to update
        return cb(err);
    }
}

function update(channel, handlers, cb) {
    var timeOut, filePath;
    var timeOutAllowance = 3;
    var succesful = true;
    if (cachedUpdateData) {
        filePath = cachedUpdateData[channel].target;
    }
    else {
        return cb(new Error("Build update cache before attempting to update"));
    }
    var download = function(url, dest, dcb) {
      var fileStream = fs.createWriteStream(dest);
      var request = https.get(url, function(response) {
        if (!response || typeof response.statusCode !== "number" || response.statusCode != 200) {
          return dcb(new Error("Update download failed due to a server error: " + response.statusCode.toString()));
        }
        var fileSize = parseInt(response.headers["content-length"]);
        fileStream.on('finish', function() {
            if (succesful) {
                fileStream.close(dcb);
            }
            //else we should have already cb'd
        });
        response.on('data', function(data) {
            clearInterval(timeOut);
            timeOut = setInterval(function() {
                if (--timeOutAllowance < 1) {
                    request.abort();
                }
                handlers.error("Connection Error", "The application isn't receiving any data. Please check your internet connection.");
            }, 10000);
            fileStream.write(data);
            var percentComplete = ((100 / (fileSize / fileStream.bytesWritten)).toFixed(2));
            handlers.progress(percentComplete);
        })
        .on('end', function() {
            clearInterval(timeOut);
            fileStream.end();
        });
    });
    request.on('response', function() {
        //alert("check");
    });
    request.on('abort', function() {
        succesful = false;
        return dcb(new Error("Connection timed out"));
    });
    request.on('error', function(err) {
        succesful = false;
        return dcb(err);
    });
  }
  download(BASE_URL + filePath, installFolderPath + packageFilename, function(err) {
      if (err) {
          return cb(err);
      }
      cb(null);
  });
 }
    /*var request = http.get("http://cside.mazdrak.com/updates/" + filePath, function(response) {
        console.log(response);
        //var fileStream = fs.createWriteStream(installFolderPath + packageFilename);
        //var fileSize = parseInt(response.headers["content-length"]);
        //if (response.statusCode != 200) {
            //notification("Update Failed", "Unable to connect to the server", {type:"error", closeWith: ["click"], timeout: false});
            //cb(...)
        //}
        /*response.on('data', function(chunk) {
            clearInterval(timeOut);
            timeOut = setInterval(function() {
                handlers.error("Connection Error", "The application isn't receiving any data. Please check your internet connection.");
            }, 5000);
            var mbWritten = (fileStream.bytesWritten / 1048576); //1024^2 (converts from bytes to megabytes)
            mbWritten += "MB"
            var percentComplete = (100 / (fileSize / fileStream.bytesWritten)).toFixed(2);
            handlers.progress(percentComplete);
        })
        .on('error', function(err) {
            console.log(1);
            return cb(new Error("ERROR"));
        })
        .on('close', function(chunk) {
            console.log(2);
            return cb(new Error("CLOSE"));
        })
        .on('connect', function(chunk) {
            console.log(3);
            return cb(new Error("CONNECT"));
        })
        .on('finish', function() {
            console.log(4);
            clearInterval(timeOut);
            cb(null);
        /*    if (!failed) {
                //notification("Update Successful", "Please restart the program", {type: "success", timeout: false});
            }
            else {
                //notification("Update Failed", "Package is likely to be corrupt. Attempting to revert changes.", {type: "error", timeout: 5000});
                //CALLBACK Failed
                              fh.copyFile(installFolderPath + ("prev-" + packageFilename), installFolderPath + packageFilename, function(err) {
                                    if (err) {
                                        //notification("Warning - Program is Corrupt", "Failed to revert changes. Please seek out support.", {type: "error", timeout: false});
                                    }
                                    else {
                                        //notification("Update Reverted", "Update successfully reverted", {timeout: 5000});
                                    }
                                });
            }
        });
        fileStream.on('close', function() {
            console.log(5);
            handlers.error("LOLOLOLOLOL", "FILESTREAM CLOSED");
            //never fires?
        })
        .on('error', function(err) {
            console.log(6);
            cb(err);
        });
        fileStream.pipe(response);*/

module.exports =  {
	"checkForUpdates": function(versions, channel, cb) {
      getUpdateDetails(channel, function(err, details) {
        if (err) {
            return cb(err, null);
        }
        if (isNewVer(versions.cside, details.CSIDE_version)) {
            if (!isNewVer(versions.nw, details.nw_version)) {
                return cb(null, details);
            }
            else {
                return cb(new Error("An available update does not support this version of the application. Please download the latest CSIDE installer."), null);
            }
        }
        return cb(null, null);
      });
    },
    "update": function(channel, handlers, cb) {
        createBackup(function(err) {
            if (err) {
                return cb(new Error("Failed to create backup. Update aborted."));
            }
            update(channel, handlers, function(err) {
                if (err) {
                    return cb(err);
                }
                cb(null);
            });
        });
    },
    "restore": function(cb) {
        fs.readFile(installFolderPath + ("prev-" + packageFilename), {}, function(err, data) {
            if (err) {
                return cb(new Error("Failed to read previous application package. Please seek support."));
            }
            else {
                fs.writeFile(installFolderPath + packageFilename, data, function(err) {
                    if (err) {
                        return cb(new Error("Failed to copy previous application package. Please seek support."));
                    }
                    cb(null);
                });
            }
        });
    },
    "getInstallPath": function() {
        return installFolderPath;
    }
}
